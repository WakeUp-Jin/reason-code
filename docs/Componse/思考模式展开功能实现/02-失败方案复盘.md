# 02 - 失败方案复盘

## 📐 方案演进历程

```
方案 A: 状态切换 → 失败（Static 残留）
    ↓
方案 B: 动态/静态分支渲染 → 失败（还是残留）
    ↓
方案 C: 强制 Static key 变化 → 失败（内容叠加）
    ↓
方案 D: 清屏 + 状态切换 → 失败（Ink 渲染位置错乱）
    ↓
方案 E: Remount + 清屏 → 失败（清屏不彻底）
    ↓
方案 F: Remount + \x1bc (RIS) → 失败（更差）
    ↓
方案 G: Remount + 屏幕缓冲区切换 → ✅ 成功
```

---

## ❌ 方案 A：简单状态切换

### 思路

```tsx
const [isExpanded, setIsExpanded] = useState(false);

// 根据状态决定显示内容
const displayContent = isExpanded ? fullContent : truncatedContent;
```

### 失败原因

Static 组件的内容一旦输出就变成终端历史，状态变化不会让旧内容消失。

```
结果：旧内容 + 新内容 = 内容叠加
```

---

## ❌ 方案 B：动态/静态分支渲染

### 思路

```tsx
{isExpanded ? (
  // 展开模式：动态渲染所有消息
  <Box>
    {allMessages.map(m => <Message {...m} />)}
  </Box>
) : (
  // 折叠模式：Static 渲染
  <Static items={messages}>
    {m => <Message {...m} />}
  </Static>
)}
```

### 失败原因

切换时，之前 Static 输出的内容还在终端历史中，新的动态内容追加在下面。

```
问题：终端历史无法被 React 条件渲染清除
```

---

## ❌ 方案 C：强制 Static key 变化

### 思路

通过改变 Static 组件的 key，强制 React 销毁并重建组件。

```tsx
<Static 
  key={`static-${isExpanded}`}  // key 变化 → 组件重建
  items={items}
>
  {/* ... */}
</Static>
```

### 失败原因

React 确实会重建组件，但 Ink 只会输出新内容，不会清除旧的终端历史。

```
结果：
- React 层面：组件被销毁重建 ✅
- 终端层面：旧内容还在 ❌
```

---

## ❌ 方案 D：清屏 + 状态切换

### 思路

在状态切换时，先清空终端屏幕。

```tsx
const toggleExpanded = () => {
  // 清屏
  process.stdout.write('\x1b[2J\x1b[H');
  // 切换状态
  setIsExpanded(!isExpanded);
};
```

### 失败原因

清屏后，Ink 的内部光标位置和终端实际位置不同步，导致渲染位置错乱。

```
现象：
- 清屏成功 ✅
- 新内容渲染到屏幕外（需要向上滚动才能看到）❌
```

### 技术分析

```
Ink 内部状态：
┌─────────────────┐
│ 光标位置: 第 50 行 │  ← Ink 认为光标在这里
│ 已输出内容: 50 行  │
└─────────────────┘

终端实际状态（清屏后）：
┌─────────────────┐
│ 光标位置: 第 1 行  │  ← 终端光标在这里
│ 已输出内容: 0 行   │
└─────────────────┘

结果：Ink 继续从第 50 行开始输出，但终端只有 1 行可见
```

---

## ❌ 方案 E：Remount + 清屏

### 思路

彻底销毁 Ink 实例，清屏，然后重新渲染。

```tsx
// app.tsx
export function remountApp() {
  inkInstance.unmount();
  process.stdout.write('\x1b[2J\x1b[3J\x1b[H');  // 清屏 + 清滚动缓冲区
  inkInstance = render(<Root />);
}
```

### 失败原因

1. **清屏不彻底**：`\x1b[3J` 在某些终端不生效
2. **状态丢失**：remount 后 React 状态重置
3. **重复初始化**：App 组件的 useEffect 重新执行

### 解决尝试

```tsx
// 模块级变量持久化状态
let persistedThinkingExpanded = false;
let appInitialized = false;

function App() {
  // 从持久化变量初始化
  const [isExpanded, setIsExpanded] = useState(persistedThinkingExpanded);
  
  useEffect(() => {
    if (!appInitialized) {
      appInitialized = true;
      // 初始化逻辑
    }
  }, []);
}
```

### 仍然失败的原因

清屏序列 `\x1b[2J\x1b[3J\x1b[H` 无法彻底清除所有终端的滚动缓冲区。

```
现象：向上滚动仍能看到旧内容
```

---

## ❌ 方案 F：使用 RIS (Reset to Initial State)

### 思路

使用更激进的终端重置命令 `\x1bc`（RIS - Reset to Initial State）。

```tsx
export function remountApp() {
  inkInstance.unmount();
  process.stdout.write('\x1bc');  // 完全重置终端
  inkInstance = render(<Root />);
}
```

### 失败原因

1. **过于激进**：重置了终端的所有设置（颜色、编码等）
2. **副作用大**：可能影响终端的其他配置
3. **仍有残留**：某些终端模拟器对 RIS 的实现不完整

```
现象：情况变得更差，终端显示异常
```

---

## 📊 失败方案总结

| 方案 | 核心思路 | 失败原因 |
|------|---------|---------|
| A | 状态切换 | Static 内容无法被 React 清除 |
| B | 分支渲染 | 终端历史无法被条件渲染清除 |
| C | key 变化 | Ink 只输出新内容，不清旧内容 |
| D | 清屏 + 状态 | Ink 内部状态与终端不同步 |
| E | Remount + 清屏 | 清屏序列不彻底 |
| F | RIS 重置 | 过于激进，副作用大 |

---

## 🎯 关键洞察

经过这些失败，我们得到了关键洞察：

```
┌─────────────────────────────────────────────────────┐
│  问题不是"如何清屏"，而是"如何让终端进入干净状态"    │
│                                                     │
│  终端有两个屏幕缓冲区：                              │
│  - 主屏幕（Main Screen）：正常使用                   │
│  - 备用屏幕（Alternate Screen）：全屏应用使用        │
│                                                     │
│  切换屏幕缓冲区 = 进入一个全新的干净屏幕             │
└─────────────────────────────────────────────────────┘
```

这个洞察直接导向了最终的成功方案。

