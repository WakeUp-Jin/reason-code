# 03 - 最终解决方案

## 📐 方案概述

### 核心思路

```
┌─────────────────────────────────────────────────────┐
│  利用终端的备用屏幕缓冲区（Alternate Screen Buffer） │
│  实现"屏幕切换"而非"屏幕清除"                        │
└─────────────────────────────────────────────────────┘
```

### 执行流程

```
ctrl+o 按下
    │
    ↓
┌─────────────────────┐
│ 1. 更新持久化状态    │  ← 保存新的展开状态
└─────────────────────┘
    │
    ↓
┌─────────────────────┐
│ 2. unmount Ink      │  ← 销毁当前渲染实例
└─────────────────────┘
    │
    ↓
┌─────────────────────┐
│ 3. 切换屏幕缓冲区    │  ← 关键步骤！
│    退出 → 进入       │
└─────────────────────┘
    │
    ↓
┌─────────────────────┐
│ 4. 重新 render      │  ← 在干净屏幕上渲染
└─────────────────────┘
    │
    ↓
┌─────────────────────┐
│ 5. 从持久化状态读取  │  ← 恢复展开状态
│    渲染对应内容      │
└─────────────────────┘
```

---

## 🎯 终端屏幕缓冲区原理

### 什么是备用屏幕缓冲区？

终端有两个独立的屏幕缓冲区：

```
┌─────────────────────────────────────────────────────┐
│                    终端模拟器                        │
│  ┌───────────────────┐  ┌───────────────────┐       │
│  │   主屏幕缓冲区     │  │   备用屏幕缓冲区   │       │
│  │   (Main Screen)   │  │ (Alternate Screen)│       │
│  │                   │  │                   │       │
│  │  - 有滚动历史     │  │  - 无滚动历史     │       │
│  │  - 正常 shell     │  │  - 全屏应用       │       │
│  │  - 如：bash       │  │  - 如：vim, less  │       │
│  └───────────────────┘  └───────────────────┘       │
└─────────────────────────────────────────────────────┘
```

### ANSI 转义序列

```
进入备用屏幕：\x1b[?1049h
退出备用屏幕：\x1b[?1049l
```

### 为什么这能解决问题？

```
┌─────────────────────────────────────────────────────┐
│  切换屏幕缓冲区的效果：                              │
│                                                     │
│  1. 退出备用屏幕 → 备用屏幕内容被丢弃               │
│  2. 进入备用屏幕 → 得到一个全新的空白屏幕           │
│                                                     │
│  这比"清屏"更彻底，因为是换了一个全新的画布！        │
└─────────────────────────────────────────────────────┘
```

---

## 📁 实现架构

### 文件结构

```
packages/cli/src/
├── app.tsx                    # Ink 实例管理 + remountApp
├── context/
│   └── execution.tsx          # 状态管理 + toggleThinkingExpanded
└── routes/session/
    └── index.tsx              # UI 渲染
```

### 数据流

```
┌─────────────────────────────────────────────────────────────────┐
│                         app.tsx                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  模块级变量（跨 remount 持久化）                         │    │
│  │  - persistedThinkingExpanded: boolean                   │    │
│  │  - appInitialized: boolean                              │    │
│  │  - commandsRegistered: boolean                          │    │
│  │  - inkInstance: Instance                                │    │
│  │  - inAlternateScreen: boolean                           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                   │
│                              ↓                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  remountApp()                                            │    │
│  │  1. inkInstance.unmount()                               │    │
│  │  2. 切换屏幕缓冲区                                       │    │
│  │  3. setImmediate(() => render(<Root />))                │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                     execution.tsx                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  ExecutionProvider                                       │    │
│  │  - isThinkingExpanded: useState(persistedThinkingExpanded)│   │
│  │  - toggleThinkingExpanded: () => {                       │    │
│  │      setPersistedThinkingExpanded(!current);             │    │
│  │      remountApp();                                       │    │
│  │    }                                                     │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                     session/index.tsx                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Session 组件                                            │    │
│  │  - useInput: ctrl+o → toggleThinkingExpanded()          │    │
│  │  - 根据 isThinkingExpanded 决定 Static items 内容        │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

---

## ✅ 方案优势

| 维度 | 优势 | 说明 |
|------|------|------|
| **彻底性** | 屏幕完全干净 | 切换缓冲区 = 换新画布 |
| **兼容性** | 所有终端支持 | 备用屏幕是标准特性 |
| **状态保持** | 消息不丢失 | Zustand store 不受影响 |
| **可靠性** | 无残留问题 | 不依赖清屏序列的实现 |

---

## ⚠️ 注意事项

### 1️⃣ 模块级变量

```typescript
// ✅ 正确：使用模块级变量持久化状态
let persistedThinkingExpanded = false;

// ❌ 错误：使用 useState，remount 后会重置
const [isExpanded, setIsExpanded] = useState(false);
```

### 2️⃣ 初始化保护

```typescript
// 防止 remount 时重复初始化
let appInitialized = false;

useEffect(() => {
  if (!appInitialized) {
    appInitialized = true;
    // 只执行一次的初始化逻辑
  }
}, []);
```

### 3️⃣ 异步渲染

```typescript
// 使用 setImmediate 确保屏幕切换完成后再渲染
setImmediate(() => {
  inkInstance = render(<Root />);
});
```

---

## 🔄 与其他方案的对比

| 方案 | 清屏效果 | 状态保持 | 复杂度 | 推荐 |
|------|---------|---------|--------|------|
| 状态切换 | ❌ | ✅ | 低 | ❌ |
| 清屏序列 | ⚠️ 不彻底 | ✅ | 中 | ❌ |
| RIS 重置 | ⚠️ 副作用 | ✅ | 中 | ❌ |
| **屏幕缓冲区** | ✅ | ✅ | 中 | ✅ |

