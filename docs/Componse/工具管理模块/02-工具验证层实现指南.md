# å·¥å…·éªŒè¯å±‚å®ç°æŒ‡å—ï¼ˆè¯¦ç»†ï¼‰

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
- [æ‰¹å‡†æ¨¡å¼è®¾è®¡](#æ‰¹å‡†æ¨¡å¼è®¾è®¡)
- [allowlist æœºåˆ¶](#allowlist-æœºåˆ¶)
- [å·¥å…·å®ç°](#å·¥å…·å®ç°)
- [è°ƒåº¦å™¨å®ç°](#è°ƒåº¦å™¨å®ç°)
- [ç¡®è®¤å¯¹è¯æ¡†](#ç¡®è®¤å¯¹è¯æ¡†)
- [å®Œæ•´ä»£ç ç¤ºä¾‹](#å®Œæ•´ä»£ç ç¤ºä¾‹)

---

## æ¦‚è¿°

### ç›®æ ‡

å®ç°ä¸€å¥—**ç®€å•ã€å®ç”¨ã€é«˜æ•ˆ**çš„å·¥å…·æƒé™éªŒè¯ç³»ç»Ÿï¼Œæ»¡è¶³ 99% çš„ä½¿ç”¨åœºæ™¯ã€‚

### æ ¸å¿ƒç‰¹æ€§

```
âœ… ä¸‰ç§æ‰¹å‡†æ¨¡å¼ï¼ˆDEFAULT, AUTO_EDIT, YOLOï¼‰
âœ… ä¼šè¯çº§ allowlist æœºåˆ¶
âœ… å·¥å…·è‡ªä¸»éªŒè¯é€»è¾‘
âœ… ç›´è§‚çš„ç¡®è®¤å¯¹è¯æ¡†
âœ… å¿«æ·é”®å¿«é€Ÿåˆ‡æ¢
```

### æ¶æ„åŸåˆ™

1. **èŒè´£å•ä¸€**ï¼šå·¥å…·åªå…³å¿ƒè‡ªå·±çš„éªŒè¯é€»è¾‘
2. **è§£è€¦å½»åº•**ï¼šå·¥å…·ä¸ä¾èµ–å¤–éƒ¨ç­–ç•¥ç³»ç»Ÿ
3. **çŠ¶æ€ç®€æ´**ï¼šæ‰¹å‡†æ¨¡å¼ + allowlist è¶³å¤Ÿç”¨
4. **æ˜“äºæ‰©å±•**ï¼šæ–°å·¥å…·åªéœ€å®ç° `shouldConfirmExecute()`

---

## æ ¸å¿ƒæ¦‚å¿µ

### å·¥å…·éªŒè¯æµç¨‹

```
ç”¨æˆ·æ“ä½œ â†’ AI è°ƒç”¨å·¥å…·
    â†“
ToolScheduler.schedule(toolCalls)
    â†“
tool.shouldConfirmExecute(approvalMode)
    â†“
    â”œâ”€ è¿”å› false â†’ ç›´æ¥æ‰§è¡Œ
    â””â”€ è¿”å› ConfirmDetails â†’ æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
          â†“
       ç”¨æˆ·é€‰æ‹©
          â”œâ”€ "Allow once" â†’ æœ¬æ¬¡æ‰§è¡Œ
          â”œâ”€ "Allow always" â†’ æ·»åŠ åˆ° allowlist + æ‰§è¡Œ
          â””â”€ "Cancel" â†’ å–æ¶ˆæ‰§è¡Œ
```

### å…³é”®æ•°æ®ç»“æ„

```typescript
// æ‰¹å‡†æ¨¡å¼
enum ApprovalMode {
  DEFAULT = 'default',     // å†™å…¥å·¥å…·éœ€è¦ç¡®è®¤
  AUTO_EDIT = 'autoEdit',  // ç¼–è¾‘å·¥å…·è‡ªåŠ¨æ‰¹å‡†
  YOLO = 'yolo'           // æ‰€æœ‰å·¥å…·è‡ªåŠ¨æ‰¹å‡†
}

// ç¡®è®¤è¯¦æƒ…
interface ConfirmDetails {
  type: 'edit' | 'exec' | 'mcp' | 'info';
  title: string;
  // å·¥å…·ç‰¹å®šæ•°æ®ï¼ˆdiff, å‘½ä»¤, URL ç­‰ï¼‰
  [key: string]: any;
  // ç¡®è®¤å›è°ƒ
  onConfirm?: (outcome: 'once' | 'always') => Promise<void>;
}

// å·¥å…·è°ƒç”¨
interface ToolCall {
  name: string;
  params: Record<string, any>;
  tool: DeclarativeTool;
}
```

---

## æ‰¹å‡†æ¨¡å¼è®¾è®¡

### ä¸‰ç§æ¨¡å¼è¯¦è§£

#### 1ï¸âƒ£ DEFAULT æ¨¡å¼ï¼ˆé»˜è®¤ï¼‰

```typescript
é€‚ç”¨åœºæ™¯ï¼šæ–°æ‰‹ç”¨æˆ·ã€ä¸ç†Ÿæ‚‰çš„é¡¹ç›®

è¡Œä¸ºï¼š
â”œâ”€ è¯»å–å·¥å…·ï¼šè‡ªåŠ¨æ‰¹å‡†ï¼ˆå¯é€‰é…ç½®ï¼‰
â”œâ”€ å†™å…¥å·¥å…·ï¼šéœ€è¦ç¡®è®¤
â”‚   â”œâ”€ EditTool: æ˜¾ç¤ºæ–‡ä»¶ diff
â”‚   â”œâ”€ ShellTool: æ˜¾ç¤ºå‘½ä»¤
â”‚   â””â”€ WriteFileTool: æ˜¾ç¤ºæ–‡ä»¶è·¯å¾„
â””â”€ å±é™©å·¥å…·ï¼šéœ€è¦ç¡®è®¤

ç”¨æˆ·ä½“éªŒï¼š
â””â”€ æ¯æ¬¡å†™å…¥æ“ä½œéƒ½éœ€è¦ç¡®è®¤ï¼Œå®‰å…¨ä½†ç¨æ…¢
```

#### 2ï¸âƒ£ AUTO_EDIT æ¨¡å¼ï¼ˆè‡ªåŠ¨ç¼–è¾‘ï¼‰

```typescript
é€‚ç”¨åœºæ™¯ï¼šé¢‘ç¹ç¼–è¾‘æ–‡ä»¶ã€ä¿¡ä»» AI çš„ç¼–è¾‘æ“ä½œ

è¡Œä¸ºï¼š
â”œâ”€ ç¼–è¾‘å·¥å…·ï¼šè‡ªåŠ¨æ‰¹å‡†
â”‚   â”œâ”€ EditTool: ä¸éœ€è¦ç¡®è®¤
â”‚   â””â”€ WriteFileTool: ä¸éœ€è¦ç¡®è®¤
â”œâ”€ Shell å‘½ä»¤ï¼šä»éœ€è¦ç¡®è®¤
â””â”€ å…¶ä»–å·¥å…·ï¼šæ ¹æ®å·¥å…·è‡ªå·±çš„é€»è¾‘

è§¦å‘æ–¹å¼ï¼š
â”œâ”€ å¿«æ·é”®ï¼šShift+Tab
â””â”€ ç¡®è®¤å¯¹è¯æ¡†ï¼šé€‰æ‹© "Allow always"ï¼ˆç¼–è¾‘ç±»å·¥å…·ï¼‰

ç”¨æˆ·ä½“éªŒï¼š
â””â”€ ç¼–è¾‘æ–‡ä»¶å¿«é€Ÿæµç•…ï¼ŒShell å‘½ä»¤ä»éœ€ç¡®è®¤ä¿è¯å®‰å…¨
```

#### 3ï¸âƒ£ YOLO æ¨¡å¼ï¼ˆå®Œå…¨è‡ªåŠ¨ï¼‰

```typescript
é€‚ç”¨åœºæ™¯ï¼šå®Œå…¨ä¿¡ä»»çš„é¡¹ç›®ã€æ¼”ç¤ºã€å®éªŒ

è¡Œä¸ºï¼š
â””â”€ æ‰€æœ‰å·¥å…·ï¼šè‡ªåŠ¨æ‰¹å‡†ï¼ˆæ— éœ€ç¡®è®¤ï¼‰

è§¦å‘æ–¹å¼ï¼š
â”œâ”€ å¿«æ·é”®ï¼šCtrl+Y
â””â”€ å‘½ä»¤è¡Œå‚æ•°ï¼š--approval-mode=yolo

å®‰å…¨é™åˆ¶ï¼š
â””â”€ åªèƒ½åœ¨å¯ä¿¡æ–‡ä»¶å¤¹ä¸­å¯ç”¨

ç”¨æˆ·ä½“éªŒï¼š
â””â”€ é›¶å¹²æ‰°ï¼Œä½†éœ€è¦å®Œå…¨ä¿¡ä»» AI
```

### æ¨¡å¼åˆ‡æ¢å®ç°

```typescript
class ToolScheduler {
  private approvalMode: ApprovalMode = ApprovalMode.DEFAULT;

  // åˆ‡æ¢æ‰¹å‡†æ¨¡å¼
  setApprovalMode(mode: ApprovalMode): void {
    // å®‰å…¨æ£€æŸ¥ï¼šä¸å¯ä¿¡æ–‡ä»¶å¤¹ä¸èƒ½å¯ç”¨ç‰¹æƒæ¨¡å¼
    if (!this.isTrustedFolder() && mode !== ApprovalMode.DEFAULT) {
      throw new Error(
        'Cannot enable privileged approval modes in untrusted folder'
      );
    }
    this.approvalMode = mode;
  }

  getApprovalMode(): ApprovalMode {
    return this.approvalMode;
  }
}
```

### å¿«æ·é”®ç»‘å®š

```typescript
// UI å±‚å®ç°
function useKeyboardShortcuts(scheduler: ToolScheduler) {
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      // Ctrl+Y: åˆ‡æ¢ YOLO æ¨¡å¼
      if (event.ctrlKey && event.key === 'y') {
        const current = scheduler.getApprovalMode();
        scheduler.setApprovalMode(
          current === ApprovalMode.YOLO
            ? ApprovalMode.DEFAULT
            : ApprovalMode.YOLO
        );
      }

      // Shift+Tab: åˆ‡æ¢ AUTO_EDIT æ¨¡å¼
      if (event.shiftKey && event.key === 'Tab') {
        event.preventDefault();
        const current = scheduler.getApprovalMode();
        scheduler.setApprovalMode(
          current === ApprovalMode.AUTO_EDIT
            ? ApprovalMode.DEFAULT
            : ApprovalMode.AUTO_EDIT
        );
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [scheduler]);
}
```

---

## allowlist æœºåˆ¶

### è®¾è®¡åŸç†

```
é—®é¢˜ï¼šç”¨æˆ·æ¯æ¬¡éƒ½éœ€è¦ç¡®è®¤ç›¸åŒçš„æ“ä½œï¼Œä½“éªŒä¸å¥½

è§£å†³æ–¹æ¡ˆï¼šallowlistï¼ˆä¼šè¯çº§ç™½åå•ï¼‰
  â”œâ”€ ç”¨æˆ·é¦–æ¬¡ç¡®è®¤æ—¶ï¼Œé€‰æ‹© "Allow always"
  â”œâ”€ å·¥å…·å°†å…³é”®ä¿¡æ¯æ·»åŠ åˆ° allowlist
  â””â”€ åç»­ç›¸åŒæ“ä½œè‡ªåŠ¨æ‰¹å‡†

ç‰¹ç‚¹ï¼š
  â”œâ”€ ä¼šè¯çº§ï¼šè¿›ç¨‹ç»“æŸåå¤±æ•ˆ
  â”œâ”€ åŠ¨æ€ï¼šè¿è¡Œæ—¶æ›´æ–°
  â””â”€ å·¥å…·ç‰¹å®šï¼šæ¯ä¸ªå·¥å…·ç®¡ç†è‡ªå·±çš„ allowlist
```

### å®ç°æ–¹å¼

#### æ–¹å¼1ï¼šé™æ€å˜é‡ï¼ˆæ¨èï¼‰

```typescript
class EditToolInvocation {
  // é™æ€å˜é‡ï¼šæ‰€æœ‰å®ä¾‹å…±äº«
  private static allowlist = new Set<string>();

  async shouldConfirmExecute(approvalMode: ApprovalMode) {
    // æ£€æŸ¥ allowlist
    if (EditToolInvocation.allowlist.has(this.params.filePath)) {
      return false;  // å·²æ‰¹å‡†ï¼Œç›´æ¥æ‰§è¡Œ
    }

    // è¿”å›ç¡®è®¤è¯¦æƒ…
    return {
      type: 'edit',
      filePath: this.params.filePath,
      diff: await this.calculateDiff(),
      onConfirm: async (outcome: 'once' | 'always') => {
        if (outcome === 'always') {
          // æ·»åŠ åˆ° allowlist
          EditToolInvocation.allowlist.add(this.params.filePath);
        }
      }
    };
  }
}
```

**ä¼˜ç‚¹ï¼š**
- âœ… æ‰€æœ‰å®ä¾‹è‡ªåŠ¨å…±äº«
- âœ… ä»£ç ç®€æ´
- âœ… æ€§èƒ½å¥½ï¼ˆSet æŸ¥æ‰¾ O(1)ï¼‰

**ç¼ºç‚¹ï¼š**
- âš ï¸ ä¸èƒ½åœ¨è¿è¡Œæ—¶æ¸…ç©ºï¼ˆé™¤éé‡å¯ï¼‰
- âš ï¸ æµ‹è¯•æ—¶éœ€è¦æ¸…ç†

#### æ–¹å¼2ï¼šå®ä¾‹å˜é‡ï¼ˆé€šè¿‡ DeclarativeToolï¼‰

```typescript
class EditTool extends BaseDeclarativeTool {
  private allowlist = new Set<string>();

  protected createInvocation(params: EditParams) {
    return new EditToolInvocation(params, this.allowlist);
  }
}

class EditToolInvocation {
  constructor(
    private params: EditParams,
    private allowlist: Set<string>  // æ³¨å…¥
  ) {}

  async shouldConfirmExecute(approvalMode: ApprovalMode) {
    if (this.allowlist.has(this.params.filePath)) {
      return false;
    }
    // ...
  }
}
```

**ä¼˜ç‚¹ï¼š**
- âœ… æ˜“äºæµ‹è¯•ï¼ˆæ¯ä¸ªæµ‹è¯•ç‹¬ç«‹ï¼‰
- âœ… å¯ä»¥åœ¨è¿è¡Œæ—¶æ¸…ç©º

**ç¼ºç‚¹ï¼š**
- âš ï¸ ä»£ç ç¨å¤šï¼ˆéœ€è¦ä¼ é€’ï¼‰

### allowlist çš„ key è®¾è®¡

ä¸åŒå·¥å…·æœ‰ä¸åŒçš„ key ç­–ç•¥ï¼š

```typescript
// EditTool: ä½¿ç”¨æ–‡ä»¶è·¯å¾„
EditToolInvocation.allowlist.add(filePath);
// ç¤ºä¾‹ï¼š'/app/config.ts'

// ShellTool: ä½¿ç”¨å‘½ä»¤å‰ç¼€
ShellToolInvocation.allowlist.add('git');
// æ•ˆæœï¼šgit commit, git push, git status éƒ½æ‰¹å‡†

// MCPTool: ä½¿ç”¨æœåŠ¡å™¨åç§°
MCPToolInvocation.allowlist.add('github');
// æ•ˆæœï¼šgithub æœåŠ¡å™¨çš„æ‰€æœ‰å·¥å…·éƒ½æ‰¹å‡†

// WebFetchTool: ä½¿ç”¨åŸŸå
WebFetchToolInvocation.allowlist.add('example.com');
// æ•ˆæœï¼šexample.com çš„æ‰€æœ‰ URL éƒ½æ‰¹å‡†
```

### allowlist æ¸…ç†ç­–ç•¥

```typescript
class ToolScheduler {
  // æ¸…ç©ºæ‰€æœ‰ allowlistï¼ˆä¼šè¯é‡å¯æ—¶ï¼‰
  clearAllAllowlists(): void {
    // æ³¨æ„ï¼šé™æ€å˜é‡éœ€è¦æ‰‹åŠ¨æ¸…ç©º
    // è¿™é‡Œéœ€è¦è°ƒç”¨æ¯ä¸ªå·¥å…·çš„æ¸…ç©ºæ–¹æ³•
  }

  // æ¸…ç©ºç‰¹å®šå·¥å…·çš„ allowlist
  clearToolAllowlist(toolName: string): void {
    // æ ¹æ®å·¥å…·åç§°æ¸…ç©º
  }
}
```

---

## å·¥å…·å®ç°

### åŸºç¡€å·¥å…·ç±»

```typescript
/**
 * å·¥å…·è°ƒç”¨åŸºç¡€ç±»
 * æ‰€æœ‰å·¥å…·éƒ½ç»§æ‰¿è¿™ä¸ªç±»
 */
abstract class BaseToolInvocation<P, R> {
  constructor(protected params: P) {}

  /**
   * å·¥å…·è‡ªä¸»éªŒè¯é€»è¾‘
   * @param approvalMode å½“å‰æ‰¹å‡†æ¨¡å¼
   * @returns false: ä¸éœ€è¦ç¡®è®¤ | ConfirmDetails: éœ€è¦ç¡®è®¤
   */
  async shouldConfirmExecute(
    approvalMode: ApprovalMode
  ): Promise<ConfirmDetails | false> {
    // é»˜è®¤å®ç°ï¼šæ£€æŸ¥ YOLO æ¨¡å¼
    if (approvalMode === ApprovalMode.YOLO) {
      return false;  // YOLO æ¨¡å¼ï¼šç›´æ¥æ‰§è¡Œ
    }

    // å­ç±»å¯ä»¥è¦†ç›–è¿™ä¸ªæ–¹æ³•å®ç°è‡ªå·±çš„é€»è¾‘
    return false;
  }

  /**
   * æ‰§è¡Œå·¥å…·
   */
  abstract execute(signal: AbortSignal): Promise<R>;

  /**
   * å·¥å…·æè¿°ï¼ˆç”¨äºæ—¥å¿—ï¼‰
   */
  abstract getDescription(): string;
}
```

### ç¤ºä¾‹1ï¼šEditToolï¼ˆç¼–è¾‘æ–‡ä»¶ï¼‰

```typescript
// å‚æ•°å®šä¹‰
interface EditParams {
  filePath: string;
  oldString: string;
  newString: string;
}

// ç»“æœå®šä¹‰
interface EditResult {
  success: boolean;
  diff?: string;
}

// å·¥å…·å®ç°
class EditToolInvocation extends BaseToolInvocation<EditParams, EditResult> {
  // ä¼šè¯çº§ allowlist
  private static allowlist = new Set<string>();

  async shouldConfirmExecute(
    approvalMode: ApprovalMode
  ): Promise<ConfirmDetails | false> {
    // 1. æ£€æŸ¥ YOLO æ¨¡å¼
    if (approvalMode === ApprovalMode.YOLO) {
      return false;
    }

    // 2. æ£€æŸ¥ AUTO_EDIT æ¨¡å¼
    if (approvalMode === ApprovalMode.AUTO_EDIT) {
      return false;
    }

    // 3. æ£€æŸ¥ allowlist
    if (EditToolInvocation.allowlist.has(this.params.filePath)) {
      return false;
    }

    // 4. éœ€è¦ç¡®è®¤ï¼šè®¡ç®— diff
    const currentContent = await this.readFile(this.params.filePath);
    const diff = this.calculateDiff(
      currentContent,
      this.params.oldString,
      this.params.newString
    );

    // 5. è¿”å›ç¡®è®¤è¯¦æƒ…
    return {
      type: 'edit',
      title: `Edit: ${this.params.filePath}`,
      filePath: this.params.filePath,
      diff,
      onConfirm: async (outcome: 'once' | 'always') => {
        if (outcome === 'always') {
          EditToolInvocation.allowlist.add(this.params.filePath);
        }
      }
    };
  }

  async execute(signal: AbortSignal): Promise<EditResult> {
    const currentContent = await this.readFile(this.params.filePath);
    const newContent = currentContent.replace(
      this.params.oldString,
      this.params.newString
    );
    await this.writeFile(this.params.filePath, newContent);

    return {
      success: true,
      diff: this.calculateDiff(currentContent, this.params.oldString, this.params.newString)
    };
  }

  getDescription(): string {
    return `Edit ${this.params.filePath}`;
  }

  // è¾…åŠ©æ–¹æ³•
  private async readFile(path: string): Promise<string> {
    // è¯»å–æ–‡ä»¶å®ç°
    return '';
  }

  private async writeFile(path: string, content: string): Promise<void> {
    // å†™å…¥æ–‡ä»¶å®ç°
  }

  private calculateDiff(current: string, old: string, newStr: string): string {
    // è®¡ç®— diff å®ç°
    return '';
  }
}
```

### ç¤ºä¾‹2ï¼šShellToolï¼ˆæ‰§è¡Œå‘½ä»¤ï¼‰

```typescript
interface ShellParams {
  command: string;
}

interface ShellResult {
  stdout: string;
  stderr: string;
  exitCode: number;
}

class ShellToolInvocation extends BaseToolInvocation<ShellParams, ShellResult> {
  // ä¼šè¯çº§ allowlistï¼ˆå‘½ä»¤å‰ç¼€ï¼‰
  private static allowlist = new Set<string>();

  async shouldConfirmExecute(
    approvalMode: ApprovalMode
  ): Promise<ConfirmDetails | false> {
    // 1. æ£€æŸ¥ YOLO æ¨¡å¼
    if (approvalMode === ApprovalMode.YOLO) {
      return false;
    }

    // 2. æå–å‘½ä»¤æ ¹éƒ¨
    const rootCommands = this.extractCommandRoots(this.params.command);
    // ç¤ºä¾‹ï¼š'git commit && npm test' â†’ ['git', 'npm']

    // 3. æ£€æŸ¥ allowlist
    const commandsToConfirm = rootCommands.filter(
      cmd => !ShellToolInvocation.allowlist.has(cmd)
    );

    if (commandsToConfirm.length === 0) {
      return false;  // æ‰€æœ‰å‘½ä»¤éƒ½å·²æ‰¹å‡†
    }

    // 4. è¿”å›ç¡®è®¤è¯¦æƒ…
    return {
      type: 'exec',
      title: `Execute: ${commandsToConfirm.join(', ')}`,
      command: this.params.command,
      rootCommands: commandsToConfirm,
      onConfirm: async (outcome: 'once' | 'always') => {
        if (outcome === 'always') {
          // å°†æ‰€æœ‰å‘½ä»¤æ ¹éƒ¨æ·»åŠ åˆ° allowlist
          commandsToConfirm.forEach(cmd => {
            ShellToolInvocation.allowlist.add(cmd);
          });
        }
      }
    };
  }

  async execute(signal: AbortSignal): Promise<ShellResult> {
    // æ‰§è¡Œ shell å‘½ä»¤
    return {
      stdout: '',
      stderr: '',
      exitCode: 0
    };
  }

  getDescription(): string {
    return `Execute: ${this.params.command}`;
  }

  // æå–å‘½ä»¤æ ¹éƒ¨
  private extractCommandRoots(command: string): string[] {
    // ç®€åŒ–å®ç°ï¼šæ‹†åˆ† && å’Œ ||
    const commands = command
      .split(/&&|\|\|/)
      .map(cmd => cmd.trim())
      .map(cmd => cmd.split(' ')[0]);  // å–ç¬¬ä¸€ä¸ªè¯

    return [...new Set(commands)];  // å»é‡
  }
}
```

---

## è°ƒåº¦å™¨å®ç°

### ToolScheduler æ ¸å¿ƒé€»è¾‘

```typescript
class ToolScheduler {
  private approvalMode: ApprovalMode = ApprovalMode.DEFAULT;

  // é¢„ç•™ç­–ç•¥å¼•æ“æ¥å£ï¼ˆæœªæ¥æ‰©å±•ï¼‰
  private policyEngine?: PolicyEngine;

  /**
   * è°ƒåº¦å·¥å…·æ‰§è¡Œ
   */
  async schedule(toolCalls: ToolCall[]): Promise<void> {
    for (const call of toolCalls) {
      try {
        // ============================================
        // ç¬¬ä¸€å±‚ï¼šç­–ç•¥å¼•æ“æ£€æŸ¥ï¼ˆé¢„ç•™ï¼Œæœªå®ç°ï¼‰
        // ============================================
        // if (this.policyEngine) {
        //   const decision = this.policyEngine.check(call);
        //   if (decision === 'allow') {
        //     await this.executeDirectly(call);
        //     continue;
        //   }
        //   if (decision === 'deny') {
        //     this.rejectCall(call, 'Blocked by policy');
        //     continue;
        //   }
        //   // decision === 'ask' ç»§ç»­ä¸‹é¢çš„æµç¨‹
        // }

        // ============================================
        // ç¬¬äºŒå±‚ï¼šå·¥å…·è‡ªä¸»éªŒè¯
        // ============================================
        const invocation = call.tool.build(call.params);
        const confirmDetails = await invocation.shouldConfirmExecute(
          this.approvalMode
        );

        if (!confirmDetails) {
          // ä¸éœ€è¦ç¡®è®¤ï¼Œç›´æ¥æ‰§è¡Œ
          await this.executeDirectly(call, invocation);
        } else {
          // éœ€è¦ç”¨æˆ·ç¡®è®¤
          await this.handleConfirmation(call, invocation, confirmDetails);
        }
      } catch (error) {
        this.handleError(call, error);
      }
    }
  }

  /**
   * å¤„ç†ç¡®è®¤æµç¨‹
   */
  private async handleConfirmation(
    call: ToolCall,
    invocation: BaseToolInvocation<any, any>,
    confirmDetails: ConfirmDetails
  ): Promise<void> {
    // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
    const outcome = await this.showConfirmDialog(confirmDetails);

    if (outcome === 'cancel') {
      this.rejectCall(call, 'User cancelled');
      return;
    }

    // è°ƒç”¨ onConfirm å›è°ƒ
    if (confirmDetails.onConfirm) {
      await confirmDetails.onConfirm(
        outcome === 'proceed_always' ? 'always' : 'once'
      );
    }

    // æ‰§è¡Œå·¥å…·
    await this.executeDirectly(call, invocation);
  }

  /**
   * ç›´æ¥æ‰§è¡Œå·¥å…·
   */
  private async executeDirectly(
    call: ToolCall,
    invocation: BaseToolInvocation<any, any>
  ): Promise<void> {
    const signal = new AbortController().signal;
    const result = await invocation.execute(signal);
    this.handleResult(call, result);
  }

  /**
   * æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
   */
  private async showConfirmDialog(
    details: ConfirmDetails
  ): Promise<'proceed' | 'proceed_always' | 'cancel'> {
    // UI å®ç°
    // è¿”å›ç”¨æˆ·é€‰æ‹©
    return 'proceed';
  }

  /**
   * æ‹’ç»å·¥å…·è°ƒç”¨
   */
  private rejectCall(call: ToolCall, reason: string): void {
    console.error(`Tool ${call.name} rejected: ${reason}`);
  }

  /**
   * å¤„ç†æ‰§è¡Œç»“æœ
   */
  private handleResult(call: ToolCall, result: any): void {
    console.log(`Tool ${call.name} completed:`, result);
  }

  /**
   * å¤„ç†é”™è¯¯
   */
  private handleError(call: ToolCall, error: any): void {
    console.error(`Tool ${call.name} failed:`, error);
  }

  /**
   * è®¾ç½®æ‰¹å‡†æ¨¡å¼
   */
  setApprovalMode(mode: ApprovalMode): void {
    this.approvalMode = mode;
  }

  /**
   * è·å–æ‰¹å‡†æ¨¡å¼
   */
  getApprovalMode(): ApprovalMode {
    return this.approvalMode;
  }
}
```

---

## ç¡®è®¤å¯¹è¯æ¡†

### åŸºç¡€ UI ç»„ä»¶

```typescript
interface ConfirmDialogProps {
  details: ConfirmDetails;
  onConfirm: (outcome: 'proceed' | 'proceed_always' | 'cancel') => void;
}

function ConfirmDialog({ details, onConfirm }: ConfirmDialogProps) {
  return (
    <div className="confirm-dialog">
      <h3>{details.title}</h3>

      {/* æ ¹æ®ç±»å‹æ˜¾ç¤ºä¸åŒå†…å®¹ */}
      {details.type === 'edit' && (
        <DiffViewer diff={details.diff} />
      )}

      {details.type === 'exec' && (
        <CommandViewer command={details.command} />
      )}

      {/* æŒ‰é’® */}
      <div className="buttons">
        <button onClick={() => onConfirm('proceed')}>
          Allow once
        </button>
        <button onClick={() => onConfirm('proceed_always')}>
          Allow always
        </button>
        <button onClick={() => onConfirm('cancel')}>
          Cancel (ESC)
        </button>
      </div>
    </div>
  );
}
```

### ä¸åŒå·¥å…·çš„å±•ç¤ºç»„ä»¶

```typescript
// æ–‡ä»¶ diff å±•ç¤º
function DiffViewer({ diff }: { diff: string }) {
  return (
    <pre className="diff-viewer">
      {diff.split('\n').map((line, i) => (
        <div
          key={i}
          className={
            line.startsWith('+') ? 'added' :
            line.startsWith('-') ? 'removed' :
            'unchanged'
          }
        >
          {line}
        </div>
      ))}
    </pre>
  );
}

// Shell å‘½ä»¤å±•ç¤º
function CommandViewer({ command }: { command: string }) {
  return (
    <pre className="command-viewer">
      <code>{command}</code>
    </pre>
  );
}
```

---

## å®Œæ•´ä»£ç ç¤ºä¾‹

### ç¤ºä¾‹é¡¹ç›®ç»“æ„

```
src/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ BaseToolInvocation.ts       # åŸºç¡€å·¥å…·ç±»
â”‚   â”œâ”€â”€ ToolScheduler.ts            # è°ƒåº¦å™¨
â”‚   â””â”€â”€ types.ts                    # ç±»å‹å®šä¹‰
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ EditTool.ts                 # ç¼–è¾‘å·¥å…·
â”‚   â”œâ”€â”€ ShellTool.ts                # Shell å·¥å…·
â”‚   â””â”€â”€ WebFetchTool.ts             # ç½‘é¡µæŠ“å–å·¥å…·
â””â”€â”€ ui/
    â””â”€â”€ ConfirmDialog.tsx           # ç¡®è®¤å¯¹è¯æ¡†
```

### å®Œæ•´ç¤ºä¾‹ä»£ç 

```typescript
// ============================================
// 1. ç±»å‹å®šä¹‰
// ============================================
// types.ts
enum ApprovalMode {
  DEFAULT = 'default',
  AUTO_EDIT = 'autoEdit',
  YOLO = 'yolo'
}

interface ConfirmDetails {
  type: 'edit' | 'exec' | 'info';
  title: string;
  [key: string]: any;
  onConfirm?: (outcome: 'once' | 'always') => Promise<void>;
}

// ============================================
// 2. åŸºç¡€å·¥å…·ç±»
// ============================================
// BaseToolInvocation.ts
abstract class BaseToolInvocation<P, R> {
  constructor(protected params: P) {}

  async shouldConfirmExecute(
    approvalMode: ApprovalMode
  ): Promise<ConfirmDetails | false> {
    if (approvalMode === ApprovalMode.YOLO) {
      return false;
    }
    return false;
  }

  abstract execute(signal: AbortSignal): Promise<R>;
  abstract getDescription(): string;
}

// ============================================
// 3. ç¼–è¾‘å·¥å…·
// ============================================
// EditTool.ts
class EditToolInvocation extends BaseToolInvocation<EditParams, EditResult> {
  private static allowlist = new Set<string>();

  async shouldConfirmExecute(
    approvalMode: ApprovalMode
  ): Promise<ConfirmDetails | false> {
    if (approvalMode === ApprovalMode.YOLO) return false;
    if (approvalMode === ApprovalMode.AUTO_EDIT) return false;
    if (EditToolInvocation.allowlist.has(this.params.filePath)) {
      return false;
    }

    const diff = await this.calculateDiff();

    return {
      type: 'edit',
      title: `Edit: ${this.params.filePath}`,
      diff,
      onConfirm: async (outcome) => {
        if (outcome === 'always') {
          EditToolInvocation.allowlist.add(this.params.filePath);
        }
      }
    };
  }

  async execute(signal: AbortSignal): Promise<EditResult> {
    // æ‰§è¡Œç¼–è¾‘
    return { success: true };
  }

  getDescription(): string {
    return `Edit ${this.params.filePath}`;
  }

  private async calculateDiff(): Promise<string> {
    // è®¡ç®— diff
    return '';
  }
}

// ============================================
// 4. è°ƒåº¦å™¨
// ============================================
// ToolScheduler.ts
class ToolScheduler {
  private approvalMode = ApprovalMode.DEFAULT;

  async schedule(toolCalls: ToolCall[]): Promise<void> {
    for (const call of toolCalls) {
      const invocation = call.tool.build(call.params);
      const confirmDetails = await invocation.shouldConfirmExecute(
        this.approvalMode
      );

      if (!confirmDetails) {
        await invocation.execute(new AbortController().signal);
      } else {
        const outcome = await this.showConfirmDialog(confirmDetails);
        if (outcome !== 'cancel') {
          await confirmDetails.onConfirm?.(
            outcome === 'proceed_always' ? 'always' : 'once'
          );
          await invocation.execute(new AbortController().signal);
        }
      }
    }
  }

  setApprovalMode(mode: ApprovalMode): void {
    this.approvalMode = mode;
  }

  private async showConfirmDialog(
    details: ConfirmDetails
  ): Promise<'proceed' | 'proceed_always' | 'cancel'> {
    return 'proceed';
  }
}

// ============================================
// 5. ä½¿ç”¨ç¤ºä¾‹
// ============================================
const scheduler = new ToolScheduler();

// åˆ‡æ¢åˆ° AUTO_EDIT æ¨¡å¼
scheduler.setApprovalMode(ApprovalMode.AUTO_EDIT);

// è°ƒåº¦å·¥å…·
await scheduler.schedule([
  {
    name: 'edit',
    params: { filePath: '/app/config.ts', ... },
    tool: editTool
  }
]);
```

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. âœ… **ä¸‰ç§æ‰¹å‡†æ¨¡å¼**æ»¡è¶³æ‰€æœ‰åœºæ™¯
2. âœ… **allowlist æœºåˆ¶**æå‡ç”¨æˆ·ä½“éªŒ
3. âœ… **å·¥å…·è‡ªä¸»éªŒè¯**ç®€å•é«˜æ•ˆ
4. âœ… **é¢„ç•™æ‰©å±•æ¥å£**æ–¹ä¾¿æœªæ¥å‡çº§

### å®æ–½æ­¥éª¤

```
ç¬¬ 1 å‘¨ï¼š
  â”œâ”€ å®ç° ApprovalMode æšä¸¾
  â”œâ”€ å®ç° BaseToolInvocation
  â”œâ”€ å®ç° EditTool å’Œ ShellTool
  â””â”€ å®ç° ToolScheduler æ ¸å¿ƒé€»è¾‘

ç¬¬ 2 å‘¨ï¼š
  â”œâ”€ å®ç°ç¡®è®¤å¯¹è¯æ¡† UI
  â”œâ”€ å®ç°å¿«æ·é”®æ”¯æŒ
  â””â”€ æµ‹è¯•å’Œæ–‡æ¡£
```

### ä¸‹ä¸€æ­¥

å¼€å§‹å®ç°ä»£ç ï¼Œå‚è€ƒä¸Šé¢çš„å®Œæ•´ç¤ºä¾‹ï¼
