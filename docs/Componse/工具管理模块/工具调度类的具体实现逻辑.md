# 工具调度类的具体实现逻辑

> 文档版本：1.0
> 代码文件：`packages/core/src/core/coreToolScheduler.ts`
> 作用：管理工具调用的整个生命周期，实现状态机管理、队列调度、批量执行等核心功能

---

## 目录

- [1. 概述](#1-概述)
- [2. 状态机定义](#2-状态机定义)
- [3. 核心数据结构](#3-核心数据结构)
- [4. 调度类的外部调用关系](#4-调度类的外部调用关系)
- [5. 状态转换流程](#5-状态转换流程)
- [6. 核心方法详解](#6-核心方法详解)
- [7. 完整调用链](#7-完整调用链)
- [8. 关键设计理念](#8-关键设计理念)

---

## 1. 概述

### 1.1 职责定位

`CoreToolScheduler` 是工具执行的**协调者和状态管理器**，负责：

```
┌─────────────────────────────────────────────────────────┐
│  CoreToolScheduler - 工具调度器                          │
│                                                          │
│  ✅ 管理工具调用的状态机                                   │
│  ✅ 协调工具的执行顺序                                     │
│  ✅ 处理用户确认流程                                       │
│  ✅ 管理请求队列                                          │
│  ✅ 批量执行策略                                          │
│  ✅ 通知 UI 更新                                          │
│                                                          │
│  ❌ 不负责工具的注册和管理（由 ToolRegistry 负责）          │
│  ❌ 不执行具体的业务逻辑（由具体工具负责）                   │
└─────────────────────────────────────────────────────────┘
```

### 1.2 架构位置

```
应用层 (CLI/UI)
    ↓ 创建并使用
调度层 (CoreToolScheduler) ⭐ 本文档重点
    ↓ 查询工具
工具注册层 (ToolRegistry)
    ↓ 返回工具实例
工具实现层 (ShellTool, EditTool, etc.)
```

---

## 2. 状态机定义

### 2.1 所有状态类型

```typescript
// 定义位置：coreToolScheduler.ts 46-123行

// 非终态（过程中的状态）
ValidatingToolCall      // 验证中：检查是否需要用户确认
ScheduledToolCall       // 已调度：等待批量执行
ExecutingToolCall       // 执行中：正在异步执行
WaitingToolCall         // 等待确认：需要用户批准

// 终态（最终状态）
SuccessfulToolCall      // 成功：执行完成，有结果
ErroredToolCall         // 错误：执行失败
CancelledToolCall       // 取消：用户取消或信号中断
```

### 2.2 状态定义详解

#### 2.2.1 ValidatingToolCall（验证中）

```typescript
export type ValidatingToolCall = {
  status: 'validating';
  request: ToolCallRequestInfo;      // 工具调用请求
  tool: AnyDeclarativeTool;          // 工具定义
  invocation: AnyToolInvocation;     // 工具执行实例
  startTime?: number;                // 开始时间戳
  outcome?: ToolConfirmationOutcome; // 确认结果
};
```

**职责**：
- 刚进入调度器时的初始状态
- 检查工具是否需要用户确认
- 调用 `invocation.shouldConfirmExecute()` 判断确认需求

#### 2.2.2 ScheduledToolCall（已调度）

```typescript
export type ScheduledToolCall = {
  status: 'scheduled';
  request: ToolCallRequestInfo;
  tool: AnyDeclarativeTool;
  invocation: AnyToolInvocation;
  startTime?: number;
  outcome?: ToolConfirmationOutcome;
};
```

**职责**：
- 已通过验证，等待执行
- 批量执行的关键状态：只有当所有工具都达到 `scheduled` 或终态时，才会批量执行

#### 2.2.3 ExecutingToolCall（执行中）

```typescript
export type ExecutingToolCall = {
  status: 'executing';
  request: ToolCallRequestInfo;
  tool: AnyDeclarativeTool;
  invocation: AnyToolInvocation;
  liveOutput?: string | AnsiOutput;  // 实时输出（如 shell 命令）
  startTime?: number;
  outcome?: ToolConfirmationOutcome;
  pid?: number;                      // 进程 ID（仅 ShellTool）
};
```

**职责**：
- 正在异步执行工具
- 可以实时更新 `liveOutput`（通过 `outputUpdateHandler`）
- 支持进程 ID 追踪（Shell 命令）

#### 2.2.4 WaitingToolCall（等待确认）

```typescript
export type WaitingToolCall = {
  status: 'awaiting_approval';
  request: ToolCallRequestInfo;
  tool: AnyDeclarativeTool;
  invocation: AnyToolInvocation;
  confirmationDetails: ToolCallConfirmationDetails;  // 确认详情
  startTime?: number;
  outcome?: ToolConfirmationOutcome;
};
```

**职责**：
- 需要用户确认才能继续
- 包含确认详情（如要执行的命令、要编辑的文件等）
- 等待用户响应（Proceed/Cancel/Modify）

#### 2.2.5 SuccessfulToolCall（成功）

```typescript
export type SuccessfulToolCall = {
  status: 'success';
  request: ToolCallRequestInfo;
  tool: AnyDeclarativeTool;
  response: ToolCallResponseInfo;    // 执行结果
  invocation: AnyToolInvocation;
  durationMs?: number;               // 执行时长
  outcome?: ToolConfirmationOutcome;
};
```

**终态特征**：
- 执行成功，有返回结果
- 包含执行时长统计

#### 2.2.6 ErroredToolCall（错误）

```typescript
export type ErroredToolCall = {
  status: 'error';
  request: ToolCallRequestInfo;
  response: ToolCallResponseInfo;    // 错误信息
  tool?: AnyDeclarativeTool;         // 可能工具未找到
  durationMs?: number;
  outcome?: ToolConfirmationOutcome;
};
```

**终态特征**：
- 执行失败或发生异常
- `response.error` 包含错误详情

#### 2.2.7 CancelledToolCall（取消）

```typescript
export type CancelledToolCall = {
  status: 'cancelled';
  request: ToolCallRequestInfo;
  response: ToolCallResponseInfo;    // 取消原因
  tool: AnyDeclarativeTool;
  invocation: AnyToolInvocation;
  durationMs?: number;
  outcome?: ToolConfirmationOutcome;
};
```

**终态特征**：
- 用户主动取消或信号中断
- 保留部分状态信息（如 Edit 工具的 diff）

---

## 3. 核心数据结构

### 3.1 类的核心属性

```typescript
export class CoreToolScheduler {
  // 工具注册表：提供工具查找服务
  private toolRegistry: ToolRegistry;

  // 工具调用列表：存储所有工具调用及其状态
  private toolCalls: ToolCall[] = [];

  // 请求队列：当有工具正在执行时，新请求进入队列
  private requestQueue: Array<{
    request: ToolCallRequestInfo | ToolCallRequestInfo[];
    signal: AbortSignal;
    resolve: () => void;
    reject: (reason?: Error) => void;
  }> = [];

  // 标志位
  private isFinalizingToolCalls = false;  // 正在最终化工具调用
  private isScheduling = false;           // 正在调度中

  // 回调函数
  private outputUpdateHandler?: OutputUpdateHandler;           // 输出更新
  private onAllToolCallsComplete?: AllToolCallsCompleteHandler; // 全部完成
  private onToolCallsUpdate?: ToolCallsUpdateHandler;          // 状态更新
}
```

### 3.2 关键数据流

```
请求进入 → toolCalls[] 数组 → 状态流转 → 通知回调 → UI 更新
              ↓
        状态是不可变的，每次更新创建新对象
```

---

## 4. 调度类的外部调用关系

### 4.1 调用工具管理类（ToolRegistry）的方法

调度器通过 `toolRegistry` 属性与工具管理类交互：

```typescript
export class CoreToolScheduler {
  private toolRegistry: ToolRegistry;  // 持有工具注册器引用

  constructor(options: CoreToolSchedulerOptions) {
    this.toolRegistry = options.config.getToolRegistry();
  }
}
```

#### 4.1.1 getTool(name) - 查找工具定义

**调用位置**：`_schedule()` 方法 669行

```typescript
const toolInstance = this.toolRegistry.getTool(reqInfo.name);
if (!toolInstance) {
  // 工具未找到，返回错误
  const suggestion = this.getToolSuggestion(reqInfo.name);
  const errorMessage = `Tool "${reqInfo.name}" not found in registry...${suggestion}`;
  return { status: 'error', ... };
}
```

**作用**：
- 根据工具名称（如 "ShellTool"）查找工具定义
- 返回 `AnyDeclarativeTool` 实例或 `undefined`
- 用于在调度前验证工具是否存在

**时机**：每次收到工具调用请求时

#### 4.1.2 getAllToolNames() - 获取所有工具名称

**调用位置**：`getToolSuggestion()` 方法 592行

```typescript
private getToolSuggestion(unknownToolName: string, topN = 3): string {
  const allToolNames = this.toolRegistry.getAllToolNames();

  // 使用编辑距离算法找到最相似的工具名
  const matches = allToolNames.map((toolName) => ({
    name: toolName,
    distance: levenshtein.get(unknownToolName, toolName),
  }));

  // 返回建议：" Did you mean 'ShellTool'?"
  return ` Did you mean ${suggestedNames}?`;
}
```

**作用**：
- 当工具未找到时，提供智能建议
- 使用 Levenshtein 距离算法找到相似的工具名
- 改善用户体验（如 "ShellTol" → "Did you mean 'ShellTool'?"）

**时机**：工具查找失败时

### 4.2 调用工具类（Tool）的方法和属性

调度器获取到工具实例后，会访问以下属性和方法：

#### 4.2.1 tool.build(params) - 创建工具执行实例

**调用位置**：`_schedule()` 方法 685-688行，`buildInvocation()` 方法 570-582行

```typescript
const invocationOrError = this.buildInvocation(toolInstance, reqInfo.args);

private buildInvocation(
  tool: AnyDeclarativeTool,
  args: object,
): AnyToolInvocation | Error {
  try {
    return tool.build(args);  // 调用工具的 build 方法
  } catch (e) {
    return e instanceof Error ? e : new Error(String(e));
  }
}
```

**作用**：
- 根据参数创建可执行的工具实例（`ToolInvocation`）
- 工具内部会验证参数的合法性
- 返回 `ToolInvocation` 或抛出验证错误

**时机**：验证工具调用参数时

**示例流程**：
```typescript
// 输入
tool.build({ command: "ls -la" })

// 工具内部
class ShellTool extends DeclarativeTool {
  build(params) {
    // 1. 验证参数
    const validated = this.validateParams(params);
    // 2. 创建执行实例
    return new ShellToolInvocation(this.config, validated, this.allowlist);
  }
}

// 输出
ShellToolInvocation { params: { command: "ls -la" }, ... }
```

#### 4.2.2 tool.displayName - 获取工具显示名称

**调用位置**：错误处理时（代码中虽未直接调用，但 UI 层会使用）

**作用**：
- 提供用户友好的工具名称
- 如 "ShellTool" → 显示为 "Bash"

#### 4.2.3 tool.canUpdateOutput - 检查是否支持实时输出

**调用位置**：`attemptExecutionOfScheduledCalls()` 方法 966行

```typescript
const liveOutputCallback =
  scheduledCall.tool.canUpdateOutput && this.outputUpdateHandler
    ? (outputChunk: string | AnsiOutput) => {
        if (this.outputUpdateHandler) {
          this.outputUpdateHandler(callId, outputChunk);
        }
        // 更新 liveOutput
        this.toolCalls = this.toolCalls.map((tc) =>
          tc.request.callId === callId && tc.status === 'executing'
            ? { ...tc, liveOutput: outputChunk }
            : tc,
        );
      }
    : undefined;
```

**作用**：
- 判断工具是否支持流式输出（如 Shell 命令）
- 如果支持，传递 `liveOutputCallback` 给工具
- 用于实时显示命令输出（如 `npm install` 的进度）

**示例**：
- `ShellTool.canUpdateOutput = true` → 实时显示命令输出
- `ReadFileTool.canUpdateOutput = false` → 执行完成后一次性返回

#### 4.2.4 tool.isOutputMarkdown - 检查输出格式

**作用**：告诉 UI 是否需要渲染 Markdown（代码中调度器未直接使用，UI 层使用）

#### 4.2.5 tool.schema - 获取工具 Schema

**作用**：获取工具的 FunctionDeclaration（用于发送给 LLM）

**时机**：虽然调度器不直接使用，但 ToolRegistry 会收集所有工具的 schema

### 4.3 调用工具实例（ToolInvocation）的方法

调度器通过 `invocation` 对象调用工具的执行逻辑：

#### 4.3.1 invocation.shouldConfirmExecute(signal) - 检查是否需要确认

**调用位置**：`_schedule()` 方法 733-734行

```typescript
const confirmationDetails =
  await invocation.shouldConfirmExecute(signal);

if (!confirmationDetails) {
  // 不需要确认 → 直接调度
  this.setStatusInternal(reqInfo.callId, 'scheduled');
} else {
  // 需要确认 → 等待用户批准
  this.setStatusInternal(reqInfo.callId, 'awaiting_approval', confirmationDetails);
}
```

**返回值**：
- `false`：不需要确认，可以直接执行
- `ToolCallConfirmationDetails`：需要确认，包含确认信息

**确认详情示例**（Shell 工具）：
```typescript
{
  type: 'exec',
  title: 'Confirm Shell Command',
  command: 'rm -rf node_modules',  // 要执行的命令
  rootCommand: 'rm',                // 根命令
  onConfirm: async (outcome) => {   // 确认回调
    if (outcome === ToolConfirmationOutcome.ProceedAlways) {
      // 将 'rm' 添加到白名单
      this.allowlist.add('rm');
    }
  },
}
```

**工具内部逻辑**（ShellToolInvocation 为例）：
```typescript
async shouldConfirmExecute(signal: AbortSignal) {
  const command = stripShellWrapper(this.params.command);
  const rootCommands = getCommandRoots(command);  // 提取 'rm' 等

  // 检查命令是否在白名单中
  const commandsToConfirm = rootCommands.filter(
    (cmd) => !this.allowlist.has(cmd)
  );

  if (commandsToConfirm.length === 0) {
    return false;  // 已在白名单，不需要确认
  }

  // 需要确认
  return {
    type: 'exec',
    command: this.params.command,
    rootCommand: commandsToConfirm.join(', '),
    onConfirm: async (outcome) => { ... },
  };
}
```

**时机**：`validating` 状态时调用

#### 4.3.2 invocation.execute(signal, updateOutput, shellConfig) - 执行工具

**调用位置**：`attemptExecutionOfScheduledCalls()` 方法 986-1007行

```typescript
// Shell 工具特殊处理（需要 setPidCallback）
if (invocation instanceof ShellToolInvocation) {
  const setPidCallback = (pid: number) => {
    this.toolCalls = this.toolCalls.map((tc) =>
      tc.request.callId === callId && tc.status === 'executing'
        ? { ...tc, pid }
        : tc,
    );
  };
  promise = invocation.execute(
    signal,                   // AbortSignal：用于取消
    liveOutputCallback,       // 实时输出回调
    shellExecutionConfig,     // Shell 执行配置
    setPidCallback,           // 进程 ID 回调
  );
} else {
  // 其他工具
  promise = invocation.execute(
    signal,
    liveOutputCallback,
    shellExecutionConfig,
  );
}
```

**参数说明**：
1. **signal**: `AbortSignal` - 用于取消执行
2. **updateOutput**: `(output: string | AnsiOutput) => void` - 实时输出回调（可选）
3. **shellExecutionConfig**: `ShellExecutionConfig` - Shell 执行配置（可选）
4. **setPidCallback**: `(pid: number) => void` - 进程 ID 回调（仅 ShellTool）

**返回值**：`Promise<ToolResult>`

```typescript
interface ToolResult {
  llmContent: PartListUnion;           // 发送给 LLM 的内容
  returnDisplay?: ToolResultDisplay;   // UI 显示内容
  error?: {                            // 错误信息（如果有）
    message: string;
    type: ToolErrorType;
  };
}
```

**工具内部执行示例**（ShellToolInvocation）：
```typescript
async execute(
  signal: AbortSignal,
  updateOutput?: (output: string) => void,
  shellConfig?: ShellExecutionConfig,
  setPidCallback?: (pid: number) => void,
): Promise<ToolResult> {
  // 1. 执行命令
  const result = await ShellExecutionService.execute(
    this.params.command,
    signal,
    updateOutput,     // 实时输出
    setPidCallback,   // 进程 ID
  );

  // 2. 返回结果
  if (result.exitCode === 0) {
    return {
      llmContent: result.stdout,
      returnDisplay: result.stdout,
    };
  } else {
    return {
      llmContent: result.stderr,
      error: {
        message: `Command failed with exit code ${result.exitCode}`,
        type: ToolErrorType.SHELL_COMMAND_FAILED,
      },
    };
  }
}
```

**时机**：`executing` 状态时调用

#### 4.3.3 invocation.getDescription() - 获取执行描述

**调用位置**：UI 层使用（调度器不直接调用）

**作用**：
- 提供人类可读的执行描述
- 如 `"ls -la [in /home/user] (list files)"`

**示例**：
```typescript
class ShellToolInvocation {
  getDescription(): string {
    let desc = this.params.command;
    if (this.params.directory) {
      desc += ` [in ${this.params.directory}]`;
    }
    if (this.params.description) {
      desc += ` (${this.params.description})`;
    }
    return desc;
  }
}
```

### 4.4 调用关系总结图

```
┌─────────────────────────────────────────────────────────────┐
│  CoreToolScheduler（调度器）                                  │
└─────────────┬───────────────────────────────────────────────┘
              │
              ├─→ ToolRegistry（工具管理类）
              │   ├─ getTool(name)           [查找工具定义]
              │   └─ getAllToolNames()       [获取所有工具名]
              │
              ├─→ Tool（工具定义类）
              │   ├─ build(params)           [创建执行实例]
              │   ├─ canUpdateOutput         [是否支持实时输出]
              │   ├─ displayName             [显示名称]
              │   ├─ isOutputMarkdown        [输出格式]
              │   └─ schema                  [工具 Schema]
              │
              └─→ ToolInvocation（工具执行实例）
                  ├─ shouldConfirmExecute()  [检查是否需要确认]
                  ├─ execute()               [执行工具逻辑]
                  └─ getDescription()        [获取执行描述]
```

### 4.5 调用时机对照表

| 方法 | 调用时机 | 调用位置 | 目的 |
|------|---------|---------|------|
| `toolRegistry.getTool(name)` | 收到工具调用请求时 | `_schedule()` 669行 | 查找工具定义 |
| `toolRegistry.getAllToolNames()` | 工具未找到时 | `getToolSuggestion()` 592行 | 提供智能建议 |
| `tool.build(params)` | 验证工具参数时 | `buildInvocation()` 575行 | 创建执行实例 |
| `tool.canUpdateOutput` | 准备执行时 | `attemptExecution...()` 966行 | 判断是否需要实时输出 |
| `invocation.shouldConfirmExecute()` | `validating` 状态 | `_schedule()` 733行 | 检查是否需要用户确认 |
| `invocation.execute()` | `executing` 状态 | `attemptExecution...()` 996行 | 执行工具业务逻辑 |

### 4.6 关键代码片段

#### 完整的工具调用流程

```typescript
// 第1步：从注册器获取工具
const tool = this.toolRegistry.getTool(reqInfo.name);
if (!tool) {
  const suggestion = this.getToolSuggestion(reqInfo.name);
  return { status: 'error', ... };
}

// 第2步：创建工具实例
const invocation = tool.build(reqInfo.args);
if (invocation instanceof Error) {
  return { status: 'error', ... };
}

// 第3步：检查是否需要确认
const confirmationDetails = await invocation.shouldConfirmExecute(signal);

if (!confirmationDetails) {
  // 不需要确认，直接调度
  this.setStatusInternal(callId, 'scheduled');
} else {
  // 需要确认，等待用户响应
  this.setStatusInternal(callId, 'awaiting_approval', confirmationDetails);
}

// 第4步：用户确认后，执行工具
this.setStatusInternal(callId, 'executing');

const liveOutputCallback = tool.canUpdateOutput ? (...) => { ... } : undefined;
const promise = invocation.execute(signal, liveOutputCallback, shellConfig);

// 第5步：处理结果
promise.then((result) => {
  this.setStatusInternal(callId, 'success', result);
});
```

---

## 5. 状态转换流程

### 5.1 完整状态转换图

```
                    ┌──────────────┐
                    │   schedule   │  入口方法
                    └──────┬───────┘
                           ↓
                    ┌─────────────┐
                ┌───│ validating  │  验证阶段
                │   └──────┬──────┘
                │          ↓
                │   shouldConfirmExecute()
                │          ↓
                │   ┌─────────────────────┐
                │   │ 检查确认需求         │
                │   └─────┬───────┬───────┘
                │         ↓       ↓
                │    需要确认  不需要确认
                │         ↓       ↓
                │   ┌──────────┐  │
                ├───│awaiting_ │  │  等待用户决策
                │   │approval  │  │
                │   └────┬─────┘  │
                │        ↓        │
                │   用户响应      │
                │    ↓  ↓  ↓      │
                │  确认 取消 修改  │
                │    ↓   ↓   ↓    ↓
                │   ┌────────────┐
                └───│ scheduled  │  已调度，等待批量执行
                    └──────┬─────┘
                           ↓
              ┌────────────┴────────────┐
              │ 所有工具都是 scheduled   │  批量执行条件
              │ 或终态？                │
              └────────────┬────────────┘
                           ↓ 是
                    ┌──────────┐
                    │executing │  异步执行
                    └────┬─────┘
                         ↓
                   Promise 结果
                         ↓
            ┌────────────┼────────────┐
            ↓            ↓            ↓
       ┌────────┐  ┌─────────┐  ┌──────────┐
       │success │  │  error  │  │cancelled │  终态
       └────────┘  └─────────┘  └──────────┘
            ↓            ↓            ↓
         通知完成 → onAllToolCallsComplete
            ↓
         清空 toolCalls[]
            ↓
         处理队列中的下一批请求
```

### 5.2 状态转换路径详解

#### 路径 1: validating → scheduled (不需要确认)

```typescript
// 代码位置：736-742行
if (!confirmationDetails) {
  this.setToolCallOutcome(
    reqInfo.callId,
    ToolConfirmationOutcome.ProceedAlways,
  );
  this.setStatusInternal(reqInfo.callId, 'scheduled');
  continue;
}
```

**触发条件**：
- `invocation.shouldConfirmExecute()` 返回 `false`
- 工具不需要用户确认（如读取文件）

#### 路径 2: validating → scheduled (YOLO 模式或白名单)

```typescript
// 代码位置：745-754行
if (
  this.config.getApprovalMode() === ApprovalMode.YOLO ||
  doesToolInvocationMatch(toolCall.tool, invocation, allowedTools)
) {
  this.setToolCallOutcome(
    reqInfo.callId,
    ToolConfirmationOutcome.ProceedAlways,
  );
  this.setStatusInternal(reqInfo.callId, 'scheduled');
}
```

**触发条件**：
- 配置为 YOLO 模式（自动批准所有工具）
- 工具在白名单中（`--allowed-tools`）

#### 路径 3: validating → awaiting_approval (需要确认)

```typescript
// 代码位置：795-799行
this.setStatusInternal(
  reqInfo.callId,
  'awaiting_approval',
  wrappedConfirmationDetails,
);
```

**触发条件**：
- 工具需要确认且不在白名单中
- 如危险的 shell 命令、文件编辑等

#### 路径 4: awaiting_approval → scheduled (用户确认)

```typescript
// 代码位置：895行 (handleConfirmationResponse 方法中)
this.setStatusInternal(callId, 'scheduled');
this.attemptExecutionOfScheduledCalls(signal);
```

**触发条件**：
- 用户点击"Proceed Once"或"Proceed Always"
- IDE 自动确认（ideConfirmation）

#### 路径 5: awaiting_approval → cancelled (用户取消)

```typescript
// 代码位置：850-855行
if (outcome === ToolConfirmationOutcome.Cancel || signal.aborted) {
  this.setStatusInternal(
    callId,
    'cancelled',
    'User did not allow tool call',
  );
}
```

**触发条件**：
- 用户点击"Cancel"
- 信号被中止（AbortSignal）

#### 路径 6: scheduled → executing (批量执行)

```typescript
// 代码位置：943-963行
private attemptExecutionOfScheduledCalls(signal: AbortSignal): void {
  // 检查是否所有工具都ready
  const allCallsFinalOrScheduled = this.toolCalls.every(
    (call) =>
      call.status === 'scheduled' ||
      call.status === 'cancelled' ||
      call.status === 'success' ||
      call.status === 'error',
  );

  if (allCallsFinalOrScheduled) {
    const callsToExecute = this.toolCalls.filter(
      (call) => call.status === 'scheduled'
    );

    callsToExecute.forEach((toolCall) => {
      this.setStatusInternal(callId, 'executing');
      const promise = invocation.execute(signal, liveOutputCallback);
      // ... Promise 处理
    });
  }
}
```

**触发条件**（关键设计）：
- 所有工具调用都处于 `scheduled` 或终态
- 确保批量执行前所有工具都已准备好

#### 路径 7: executing → success/error/cancelled (执行结果)

```typescript
// 代码位置：1010-1109行
promise
  .then(async (toolResult: ToolResult) => {
    if (signal.aborted) {
      this.setStatusInternal(callId, 'cancelled', '...');
      return;
    }

    if (toolResult.error === undefined) {
      // 成功路径
      this.setStatusInternal(callId, 'success', successResponse);
    } else {
      // 工具返回错误
      this.setStatusInternal(callId, 'error', errorResponse);
    }
  })
  .catch((executionError: Error) => {
    if (signal.aborted) {
      this.setStatusInternal(callId, 'cancelled', '...');
    } else {
      // 未处理的异常
      this.setStatusInternal(callId, 'error', errorResponse);
    }
  });
```

**触发条件**：
- 成功：`toolResult.error === undefined`
- 错误：工具返回错误或抛出异常
- 取消：信号被中止

---

## 6. 核心方法详解

### 5.1 schedule() - 入口方法

```typescript
// 代码位置：618-652行
schedule(
  request: ToolCallRequestInfo | ToolCallRequestInfo[],
  signal: AbortSignal,
): Promise<void> {
  // 关键逻辑：队列管理
  if (this.isRunning() || this.isScheduling) {
    // 如果有工具正在执行，进入队列等待
    return new Promise((resolve, reject) => {
      this.requestQueue.push({
        request,
        signal,
        resolve,
        reject,
      });
    });
  }
  return this._schedule(request, signal);
}
```

**职责**：
1. 检查是否有工具正在执行
2. 如果忙碌，将请求加入队列
3. 否则，立即调度

**队列设计目的**：
- 串行处理批次，避免状态混乱
- 确保一批工具执行完成后再处理下一批

### 5.2 _schedule() - 核心调度逻辑

```typescript
// 代码位置：654-827行
private async _schedule(
  request: ToolCallRequestInfo | ToolCallRequestInfo[],
  signal: AbortSignal,
): Promise<void> {
  this.isScheduling = true;
  try {
    // 1. 验证没有工具正在执行
    if (this.isRunning()) {
      throw new Error('Cannot schedule...');
    }

    const requestsToProcess = Array.isArray(request) ? request : [request];

    // 2. 创建工具调用对象（初始状态：validating）
    const newToolCalls: ToolCall[] = requestsToProcess.map((reqInfo) => {
      const toolInstance = this.toolRegistry.getTool(reqInfo.name);
      if (!toolInstance) {
        // 工具未找到，立即返回错误状态
        return { status: 'error', ... };
      }

      const invocation = this.buildInvocation(toolInstance, reqInfo.args);
      if (invocation instanceof Error) {
        // 参数验证失败，立即返回错误状态
        return { status: 'error', ... };
      }

      // 创建 validating 状态的工具调用
      return {
        status: 'validating',
        request: reqInfo,
        tool: toolInstance,
        invocation: invocation,
        startTime: Date.now(),
      };
    });

    // 3. 添加到 toolCalls 数组并通知 UI
    this.toolCalls = this.toolCalls.concat(newToolCalls);
    this.notifyToolCallsUpdate();

    // 4. 处理每个工具调用的验证
    for (const toolCall of newToolCalls) {
      if (toolCall.status !== 'validating') {
        continue;  // 跳过已经是错误状态的
      }

      const { request: reqInfo, invocation } = toolCall;

      try {
        // 检查是否需要确认
        const confirmationDetails =
          await invocation.shouldConfirmExecute(signal);

        if (!confirmationDetails) {
          // 不需要确认 → scheduled
          this.setToolCallOutcome(reqInfo.callId, ProceedAlways);
          this.setStatusInternal(reqInfo.callId, 'scheduled');
        } else if (isAutoApproved) {
          // YOLO 模式或白名单 → scheduled
          this.setToolCallOutcome(reqInfo.callId, ProceedAlways);
          this.setStatusInternal(reqInfo.callId, 'scheduled');
        } else {
          // 需要确认 → awaiting_approval
          this.setStatusInternal(
            reqInfo.callId,
            'awaiting_approval',
            wrappedConfirmationDetails,
          );
        }
      } catch (error) {
        // 验证过程出错 → error
        this.setStatusInternal(reqInfo.callId, 'error', ...);
      }
    }

    // 5. 尝试批量执行所有 scheduled 的工具
    this.attemptExecutionOfScheduledCalls(signal);

    // 6. 检查是否全部完成
    void this.checkAndNotifyCompletion();
  } finally {
    this.isScheduling = false;
  }
}
```

**关键设计点**：
1. **并发控制**：`isScheduling` 标志防止重入
2. **错误快速返回**：工具未找到或参数错误立即返回错误状态
3. **批量创建**：一次性创建所有工具调用对象
4. **异步验证**：逐个检查是否需要确认
5. **自动执行**：验证完成后尝试批量执行

### 5.3 setStatusInternal() - 状态转换核心

```typescript
// 代码位置：357-524行
private setStatusInternal(
  targetCallId: string,
  newStatus: Status,
  auxiliaryData?: unknown,
): void {
  // 不可变更新模式：map 创建新数组
  this.toolCalls = this.toolCalls.map((currentCall) => {
    // 过滤条件：只更新目标 ID 且非终态的调用
    if (
      currentCall.request.callId !== targetCallId ||
      currentCall.status === 'success' ||
      currentCall.status === 'error' ||
      currentCall.status === 'cancelled'
    ) {
      return currentCall;  // 保持不变
    }

    // 保留现有信息
    const existingStartTime = currentCall.startTime;
    const toolInstance = currentCall.tool;
    const invocation = currentCall.invocation;
    const outcome = currentCall.outcome;

    // 根据新状态创建新对象
    switch (newStatus) {
      case 'success': {
        const durationMs = existingStartTime
          ? Date.now() - existingStartTime
          : undefined;
        return {
          request: currentCall.request,
          tool: toolInstance,
          invocation,
          status: 'success',
          response: auxiliaryData as ToolCallResponseInfo,
          durationMs,
          outcome,
        } as SuccessfulToolCall;
      }
      case 'error': { ... }
      case 'awaiting_approval': { ... }
      case 'scheduled': { ... }
      case 'cancelled': { ... }
      case 'validating': { ... }
      case 'executing': { ... }
    }
  });

  // 通知状态变化
  this.notifyToolCallsUpdate();

  // 检查是否全部完成
  this.checkAndNotifyCompletion();
}
```

**关键设计点**：
1. **不可变更新**：每次状态变化创建新对象（React 风格）
2. **终态保护**：终态不允许再次转换
3. **时长统计**：自动计算 `durationMs`
4. **状态保留**：保留 `tool`、`invocation`、`outcome` 等信息
5. **自动通知**：每次状态变化都通知 UI

### 5.4 attemptExecutionOfScheduledCalls() - 批量执行

```typescript
// 代码位置：943-1112行
private attemptExecutionOfScheduledCalls(signal: AbortSignal): void {
  // 关键检查：所有工具都ready了吗？
  const allCallsFinalOrScheduled = this.toolCalls.every(
    (call) =>
      call.status === 'scheduled' ||
      call.status === 'cancelled' ||
      call.status === 'success' ||
      call.status === 'error',
  );

  if (!allCallsFinalOrScheduled) {
    return;  // 还有工具在 validating 或 awaiting_approval，不执行
  }

  // 筛选出所有 scheduled 的工具
  const callsToExecute = this.toolCalls.filter(
    (call) => call.status === 'scheduled'
  );

  // 批量并行执行
  callsToExecute.forEach((toolCall) => {
    if (toolCall.status !== 'scheduled') return;

    const scheduledCall = toolCall;
    const { callId, name: toolName } = scheduledCall.request;
    const invocation = scheduledCall.invocation;

    // 1. 更新状态为 executing
    this.setStatusInternal(callId, 'executing');

    // 2. 准备实时输出回调
    const liveOutputCallback =
      scheduledCall.tool.canUpdateOutput && this.outputUpdateHandler
        ? (outputChunk: string | AnsiOutput) => {
            if (this.outputUpdateHandler) {
              this.outputUpdateHandler(callId, outputChunk);
            }
            // 更新 liveOutput
            this.toolCalls = this.toolCalls.map((tc) =>
              tc.request.callId === callId && tc.status === 'executing'
                ? { ...tc, liveOutput: outputChunk }
                : tc,
            );
            this.notifyToolCallsUpdate();
          }
        : undefined;

    // 3. 调用工具执行（异步）
    const promise = invocation.execute(
      signal,
      liveOutputCallback,
      shellExecutionConfig,
    );

    // 4. 处理执行结果
    promise
      .then(async (toolResult: ToolResult) => {
        if (signal.aborted) {
          this.setStatusInternal(callId, 'cancelled', '...');
          return;
        }

        if (toolResult.error === undefined) {
          // 成功：可能需要截断大输出
          let content = toolResult.llmContent;
          if (typeof content === 'string' && needTruncate) {
            const truncated = await truncateAndSaveToFile(...);
            content = truncated.content;
          }

          const response = convertToFunctionResponse(toolName, callId, content);
          this.setStatusInternal(callId, 'success', successResponse);
        } else {
          // 失败
          this.setStatusInternal(callId, 'error', errorResponse);
        }
      })
      .catch((executionError: Error) => {
        if (signal.aborted) {
          this.setStatusInternal(callId, 'cancelled', '...');
        } else {
          this.setStatusInternal(callId, 'error', errorResponse);
        }
      });
  });
}
```

**关键设计点**：
1. **批量执行条件**：所有工具都是 `scheduled` 或终态
2. **并行执行**：`forEach` 同时启动多个 Promise（非阻塞）
3. **实时输出**：通过回调实时更新 `liveOutput`
4. **输出截断**：大输出自动保存到文件
5. **错误处理**：Promise 的 then/catch 处理所有情况

### 5.5 checkAndNotifyCompletion() - 完成检查

```typescript
// 代码位置：1114-1144行
private async checkAndNotifyCompletion(): Promise<void> {
  // 检查是否所有工具都是终态
  const allCallsAreTerminal = this.toolCalls.every(
    (call) =>
      call.status === 'success' ||
      call.status === 'error' ||
      call.status === 'cancelled',
  );

  if (this.toolCalls.length > 0 && allCallsAreTerminal) {
    // 1. 保存完成的工具调用
    const completedCalls = [...this.toolCalls] as CompletedToolCall[];

    // 2. 清空当前批次
    this.toolCalls = [];

    // 3. 记录日志
    for (const call of completedCalls) {
      logToolCall(this.config, new ToolCallEvent(call));
    }

    // 4. 通知完成回调
    if (this.onAllToolCallsComplete) {
      this.isFinalizingToolCalls = true;
      await this.onAllToolCallsComplete(completedCalls);
      this.isFinalizingToolCalls = false;
    }

    // 5. 通知 UI 更新
    this.notifyToolCallsUpdate();

    // 6. 处理队列中的下一批请求
    if (this.requestQueue.length > 0) {
      const next = this.requestQueue.shift()!;
      this._schedule(next.request, next.signal)
        .then(next.resolve)
        .catch(next.reject);
    }
  }
}
```

**关键设计点**：
1. **终态检查**：确保所有工具都执行完成
2. **批次清空**：清空 `toolCalls[]` 为下一批做准备
3. **回调通知**：将结果传递给 UI 层
4. **队列处理**：自动处理队列中的下一批请求
5. **串行保证**：一批完成后才处理下一批

### 5.6 handleConfirmationResponse() - 确认处理

```typescript
// 代码位置：829-898行
async handleConfirmationResponse(
  callId: string,
  originalOnConfirm: (outcome: ToolConfirmationOutcome) => Promise<void>,
  outcome: ToolConfirmationOutcome,
  signal: AbortSignal,
  payload?: ToolConfirmationPayload,
): Promise<void> {
  const toolCall = this.toolCalls.find(
    (c) => c.request.callId === callId && c.status === 'awaiting_approval',
  );

  // 1. 调用工具的确认回调
  if (toolCall && toolCall.status === 'awaiting_approval') {
    await originalOnConfirm(outcome);
  }

  // 2. 自动批准其他兼容的工具（如果选择 ProceedAlways）
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    await this.autoApproveCompatiblePendingTools(signal, callId);
  }

  // 3. 记录确认结果
  this.setToolCallOutcome(callId, outcome);

  // 4. 根据结果更新状态
  if (outcome === ToolConfirmationOutcome.Cancel || signal.aborted) {
    // 取消
    this.setStatusInternal(callId, 'cancelled', '...');
  } else if (outcome === ToolConfirmationOutcome.ModifyWithEditor) {
    // 使用编辑器修改（仅 Edit 工具）
    const { updatedParams, updatedDiff } = await modifyWithEditor(...);
    this.setArgsInternal(callId, updatedParams);
    this.setStatusInternal(callId, 'awaiting_approval', updatedDetails);
  } else {
    // 确认执行
    if (payload?.newContent && toolCall) {
      // 应用内联修改
      await this._applyInlineModify(toolCall, payload, signal);
    }
    this.setStatusInternal(callId, 'scheduled');
  }

  // 5. 尝试执行
  this.attemptExecutionOfScheduledCalls(signal);
}
```

**关键设计点**：
1. **回调执行**：先执行工具自己的确认逻辑（如添加到白名单）
2. **自动批准**：`ProceedAlways` 会自动批准相同类型的其他工具
3. **编辑器集成**：支持在确认阶段使用编辑器修改参数
4. **内联修改**：支持 UI 直接修改内容
5. **自动执行**：确认后立即尝试执行

---

## 7. 完整调用链

### 6.1 场景：执行一个 Shell 命令

```
用户输入：执行 "ls -la"

第1步：UI 调用调度器
  scheduler.schedule({
    name: "ShellTool",
    callId: "call_123",
    args: { command: "ls -la" }
  }, signal)

第2步：schedule() 检查队列
  if (this.isRunning() || this.isScheduling) {
    // 如果有工具在执行，加入队列
    this.requestQueue.push(...)
  } else {
    // 否则，立即调度
    this._schedule(...)
  }

第3步：_schedule() 创建工具调用
  const tool = this.toolRegistry.getTool("ShellTool")
  const invocation = tool.build({ command: "ls -la" })

  this.toolCalls.push({
    status: 'validating',
    request: reqInfo,
    tool: tool,
    invocation: invocation,
    startTime: Date.now(),
  })

  this.notifyToolCallsUpdate()  // → UI 显示 "验证中"

第4步：检查是否需要确认
  const confirmationDetails =
    await invocation.shouldConfirmExecute(signal)

  if (!confirmationDetails) {
    // 不需要确认 → scheduled
    this.setStatusInternal(callId, 'scheduled')
  } else {
    // 需要确认 → awaiting_approval
    this.setStatusInternal(callId, 'awaiting_approval', details)
    // → UI 显示确认对话框
  }

第5步：用户确认
  // UI 调用
  confirmationDetails.onConfirm(ToolConfirmationOutcome.ProceedOnce)

  // 进入 handleConfirmationResponse()
  this.setStatusInternal(callId, 'scheduled')
  this.attemptExecutionOfScheduledCalls(signal)

第6步：批量执行检查
  const allReady = this.toolCalls.every(
    call => call.status === 'scheduled' || isTerminal(call)
  )

  if (allReady) {
    // 所有工具都ready，开始执行
    this.setStatusInternal(callId, 'executing')
    const promise = invocation.execute(signal, liveOutputCallback)

    // → UI 显示 "执行中"
  }

第7步：工具执行
  // ShellToolInvocation.execute() 内部
  const output = await executeShellCommand("ls -la")
  return {
    llmContent: output,
    returnDisplay: output,
  }

第8步：处理结果
  promise.then((toolResult) => {
    if (toolResult.error === undefined) {
      this.setStatusInternal(callId, 'success', {
        callId,
        responseParts: [...],
        resultDisplay: toolResult.returnDisplay,
      })
      // → UI 显示成功结果
    }
  })

第9步：检查完成
  const allTerminal = this.toolCalls.every(
    call => call.status === 'success' ||
            call.status === 'error' ||
            call.status === 'cancelled'
  )

  if (allTerminal) {
    const completedCalls = [...this.toolCalls]
    this.toolCalls = []  // 清空

    await this.onAllToolCallsComplete(completedCalls)
    // → UI 将结果发送给 LLM

    // 处理队列中的下一批
    if (this.requestQueue.length > 0) {
      const next = this.requestQueue.shift()
      this._schedule(next.request, next.signal)
    }
  }
```

### 6.2 场景：批量执行多个工具

```
LLM 返回：同时调用 3 个工具
  - ReadFile("config.json")
  - ReadFile("package.json")
  - ShellTool("npm test")

第1步：批量调度
  scheduler.schedule([request1, request2, request3], signal)

第2步：批量创建（全部 validating）
  this.toolCalls = [
    { status: 'validating', callId: 'call_1', ... },
    { status: 'validating', callId: 'call_2', ... },
    { status: 'validating', callId: 'call_3', ... },
  ]

第3步：逐个验证
  for (const toolCall of newToolCalls) {
    const confirmationDetails = await invocation.shouldConfirmExecute(signal)

    // ReadFile 不需要确认
    if (!confirmationDetails) {
      this.setStatusInternal(callId, 'scheduled')
    }
    // ShellTool 需要确认
    else {
      this.setStatusInternal(callId, 'awaiting_approval', details)
    }
  }

  // 此时状态：
  // call_1: scheduled
  // call_2: scheduled
  // call_3: awaiting_approval

第4步：尝试执行
  attemptExecutionOfScheduledCalls(signal)

  const allReady = this.toolCalls.every(...)
  // false！因为 call_3 还在 awaiting_approval
  // → 不执行，等待用户确认

第5步：用户确认
  // UI 调用
  confirmationDetails.onConfirm(ProceedOnce)

  this.setStatusInternal('call_3', 'scheduled')

  // 此时状态：
  // call_1: scheduled
  // call_2: scheduled
  // call_3: scheduled

第6步：批量执行
  attemptExecutionOfScheduledCalls(signal)

  const allReady = this.toolCalls.every(...)
  // true！所有工具都是 scheduled

  // 同时执行 3 个工具（并行）
  callsToExecute.forEach((toolCall) => {
    this.setStatusInternal(callId, 'executing')
    invocation.execute(...)
  })

  // 此时状态：
  // call_1: executing
  // call_2: executing
  // call_3: executing

第7步：结果返回（异步）
  // 假设 call_1 先完成
  promise1.then(() => {
    this.setStatusInternal('call_1', 'success', ...)
  })

  // call_2 完成
  promise2.then(() => {
    this.setStatusInternal('call_2', 'success', ...)
  })

  // call_3 完成
  promise3.then(() => {
    this.setStatusInternal('call_3', 'success', ...)
  })

第8步：全部完成
  checkAndNotifyCompletion()

  const allTerminal = this.toolCalls.every(...)
  // true！所有工具都是终态

  await this.onAllToolCallsComplete([call_1, call_2, call_3])
  // → UI 将所有结果一起发送给 LLM
```

---

## 8. 关键设计理念

### 7.1 批量执行策略

**为什么要等所有工具都 ready 才执行？**

```typescript
const allCallsFinalOrScheduled = this.toolCalls.every(
  (call) =>
    call.status === 'scheduled' ||
    call.status === 'cancelled' ||
    call.status === 'success' ||
    call.status === 'error',
);
```

**优势**：
1. **统一确认**：用户可以一次性审批所有需要确认的工具
2. **避免混乱**：不会出现"部分执行中，部分等待确认"的混乱状态
3. **提高效率**：确认完成后批量并行执行
4. **简化 UI**：UI 可以清晰地展示"确认阶段"和"执行阶段"

**劣势**（trade-off）**：
- 即使有些工具不需要确认，也要等待其他工具确认完成

### 7.2 不可变状态更新

```typescript
this.toolCalls = this.toolCalls.map((currentCall) => {
  if (currentCall.request.callId !== targetCallId) {
    return currentCall;  // 保持不变
  }
  return { ...currentCall, status: newStatus };  // 创建新对象
});
```

**优势**：
1. **函数式编程**：状态变化可追踪
2. **React 友好**：便于检测变化并触发重渲染
3. **时间旅行调试**：可以记录每次状态变化
4. **并发安全**：避免直接修改导致的竞态条件

### 7.3 队列串行处理

```typescript
if (this.isRunning() || this.isScheduling) {
  return new Promise((resolve, reject) => {
    this.requestQueue.push({ request, signal, resolve, reject });
  });
}
```

**优势**：
1. **状态隔离**：每批工具调用的状态互不干扰
2. **简化逻辑**：不需要处理多批次混合的复杂情况
3. **可靠性**：确保每批工具都正确完成后再处理下一批

**劣势（trade-off）**：
- 无法并发处理多批请求（但实际场景中很少需要）

### 7.4 观察者模式

```typescript
private notifyToolCallsUpdate(): void {
  if (this.onToolCallsUpdate) {
    this.onToolCallsUpdate([...this.toolCalls]);
  }
}
```

**优势**：
1. **解耦**：调度器不关心 UI 如何渲染
2. **灵活**：可以有多个观察者（日志、UI、测试等）
3. **实时性**：每次状态变化立即通知

### 7.5 Promise 异步管理

```typescript
const promise = invocation.execute(signal, liveOutputCallback);

promise
  .then((result) => { /* 处理成功 */ })
  .catch((error) => { /* 处理错误 */ });
```

**优势**：
1. **非阻塞**：多个工具并行执行
2. **统一错误处理**：所有异常都进入 catch
3. **取消支持**：通过 AbortSignal 中途取消

### 7.6 输出截断机制

```typescript
if (
  typeof content === 'string' &&
  toolName === ShellTool.Name &&
  content.length > threshold
) {
  const { content: truncated, outputFile } = await truncateAndSaveToFile(...);
  content = truncated;
}
```

**优势**：
1. **防止上下文爆炸**：大输出不会占用 LLM 上下文
2. **保留完整内容**：保存到文件供后续读取
3. **智能截断**：保留开头和结尾，删除中间部分

---

## 9. 总结

### 8.1 核心特性

1. **状态机管理**：清晰的状态定义和转换规则
2. **批量执行**：等所有工具 ready 后并行执行
3. **队列调度**：串行处理多批请求
4. **用户确认**：灵活的确认流程（Proceed/Cancel/Modify）
5. **实时反馈**：通过回调实时更新 UI
6. **错误处理**：完善的异常处理和状态保护
7. **输出管理**：自动截断大输出

### 8.2 设计模式

- **状态机模式**：管理工具调用生命周期
- **观察者模式**：通知 UI 更新
- **命令队列模式**：串行处理请求
- **不可变数据模式**：函数式状态更新
- **策略模式**：不同的确认和执行策略

### 8.3 关键文件位置

| 功能 | 代码位置 | 说明 |
|-----|---------|------|
| 入口方法 | `schedule()` 618-652行 | 接收工具调用请求 |
| 核心调度 | `_schedule()` 654-827行 | 创建工具调用并验证 |
| 状态转换 | `setStatusInternal()` 357-524行 | 统一的状态更新入口 |
| 批量执行 | `attemptExecutionOfScheduledCalls()` 943-1112行 | 检查并批量执行 |
| 确认处理 | `handleConfirmationResponse()` 829-898行 | 处理用户确认 |
| 完成检查 | `checkAndNotifyCompletion()` 1114-1144行 | 检查并通知完成 |

---

**文档结束**

如需更多细节，请参考源代码 `packages/core/src/core/coreToolScheduler.ts`
