# è¿ç§»æŒ‡å—

## ğŸ“– æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ä»ä¸€ç§é€šä¿¡æ–¹å¼è¿ç§»åˆ°å¦ä¸€ç§çš„è¯¦ç»†æ­¥éª¤ï¼Œç¡®ä¿å¹³æ»‘è¿‡æ¸¡ã€‚

## ğŸ¯ è¿ç§»è·¯çº¿å›¾

```
Phase 1: CLI ç›´æ¥è°ƒç”¨ (å½“å‰)
    â†“ æ·»åŠ æŠ½è±¡å±‚
Phase 2: å¼•å…¥ ITransport æ¥å£
    â†“ å®ç° HTTP
Phase 3: æ”¯æŒ HTTP + SSE
    â†“ å®ç° WebSocket
Phase 4: æ”¯æŒ WebSocket
    â†“ å¤šåè®®å…±å­˜
Phase 5: æ··åˆæ¨¡å¼ï¼ˆCLI + Webï¼‰
```

## ğŸ“‹ è¿ç§»æ£€æŸ¥æ¸…å•

### å‰ç½®æ¡ä»¶

- [ ] ç†è§£å½“å‰æ¶æ„ï¼ˆé˜…è¯» [01-å½“å‰æ–¹æ¡ˆ](./01-å½“å‰æ–¹æ¡ˆ-CLIç›´æ¥è°ƒç”¨.md)ï¼‰
- [ ] ç†è§£ç›®æ ‡æ¶æ„ï¼ˆé˜…è¯»å¯¹åº”æ–¹æ¡ˆæ–‡æ¡£ï¼‰
- [ ] ç†è§£æŠ½è±¡è®¾è®¡ï¼ˆé˜…è¯» [04-æ¶æ„è®¾è®¡](./04-æ¶æ„è®¾è®¡-é€šä¿¡å±‚æŠ½è±¡.md)ï¼‰
- [ ] å¤‡ä»½å½“å‰ä»£ç 
- [ ] å‡†å¤‡æµ‹è¯•ç¯å¢ƒ

---

## ğŸ”„ è¿ç§» 1ï¼šå¼•å…¥æŠ½è±¡å±‚ï¼ˆå¿…éœ€æ­¥éª¤ï¼‰

> **ç›®æ ‡**ï¼šåœ¨ä¸æ”¹å˜åŠŸèƒ½çš„å‰æä¸‹ï¼Œå¼•å…¥ ITransport æ¥å£ã€‚

### Step 1: å®šä¹‰æ¥å£

```typescript
// src/transport/interface.ts (æ–°å»º)
export interface ITransport {
  send(message: Message): Promise<void>
  receive(): AsyncIterable<Event>
  close(): Promise<void>
  readonly status: TransportStatus
}

export interface Message {
  sessionID: string
  parts: Part[]
  agent?: string
  model?: Model
}

export interface Event {
  type: string
  properties: Record<string, any>
}

export type TransportStatus =
  | "connecting"
  | "connected"
  | "disconnected"
  | "error"
```

### Step 2: å®ç° DirectTransport

```typescript
// src/transport/direct.ts (æ–°å»º)
import { ITransport, Message, Event, TransportStatus } from "./interface"
import { Bus } from "../bus"
import { SessionPrompt } from "../session/prompt"

export class DirectTransport implements ITransport {
  status: TransportStatus = "connected"
  private abort = new AbortController()

  async send(message: Message): Promise<void> {
    await SessionPrompt.prompt({
      sessionID: message.sessionID,
      parts: message.parts,
      agent: message.agent,
      model: message.model
    })
  }

  async *receive(): AsyncIterable<Event> {
    const queue: Event[] = []
    let resolve: ((value: Event) => void) | null = null

    const unsub = Bus.subscribeAll((event) => {
      if (resolve) {
        resolve(event)
        resolve = null
      } else {
        queue.push(event)
      }
    })

    try {
      while (!this.abort.signal.aborted) {
        if (queue.length > 0) {
          yield queue.shift()!
        } else {
          yield await new Promise<Event>((r) => { resolve = r })
        }
      }
    } finally {
      unsub()
    }
  }

  async close(): Promise<void> {
    this.abort.abort()
    this.status = "disconnected"
  }
}
```

### Step 3: æ”¹é€  CLI å…¥å£

```typescript
// src/cli/main.ts (ä¿®æ”¹)
import { DirectTransport } from "../transport/direct"

async function cli(prompt: string) {
  // åˆ›å»ºä¼ è¾“å±‚
  const transport = new DirectTransport()

  // å‘é€æ¶ˆæ¯
  await transport.send({
    sessionID: "temp",
    parts: [{ type: "text", text: prompt }]
  })

  // æ¥æ”¶äº‹ä»¶
  for await (const event of transport.receive()) {
    if (event.type === "message.part.updated") {
      const { part, delta } = event.properties
      if (part.type === "text" && delta) {
        process.stdout.write(delta)
      }
    }

    if (event.type === "session.idle") {
      break
    }
  }

  await transport.close()
}
```

### Step 4: æµ‹è¯•

```bash
# ç¡®ä¿åŠŸèƒ½ä¸ä¹‹å‰ä¸€è‡´
npm test

# æ‰‹åŠ¨æµ‹è¯•
npm run cli "fix the bug"
```

### éªŒè¯æ ‡å‡†

- âœ… åŠŸèƒ½ä¸ä¹‹å‰å®Œå…¨ä¸€è‡´
- âœ… æ€§èƒ½æ— æ˜æ˜¾ä¸‹é™
- âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡

---

## ğŸŒ è¿ç§» 2ï¼šæ·»åŠ  HTTP + SSE æ”¯æŒ

> **ç›®æ ‡**ï¼šæ”¯æŒ Web ç«¯å’Œå¤šå®¢æˆ·ç«¯ã€‚

### Step 1: å®‰è£…ä¾èµ–

```bash
npm install hono
npm install eventsource  # Node.js ç¯å¢ƒ
```

### Step 2: å®ç° HTTPTransport

```typescript
// src/transport/http.ts (æ–°å»º)
import { ITransport, Message, Event, TransportStatus } from "./interface"

export class HTTPTransport implements ITransport {
  status: TransportStatus = "disconnected"
  private baseUrl: string
  private eventSource?: EventSource

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }

  async send(message: Message): Promise<void> {
    await fetch(`${this.baseUrl}/session/${message.sessionID}/message`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        parts: message.parts,
        agent: message.agent,
        model: message.model
      })
    })
  }

  async *receive(): AsyncIterable<Event> {
    this.eventSource = new EventSource(`${this.baseUrl}/event`)
    this.status = "connected"

    const queue: Event[] = []
    let resolve: ((value: Event) => void) | null = null

    this.eventSource.onmessage = (evt) => {
      const event = JSON.parse(evt.data) as Event
      if (resolve) {
        resolve(event)
        resolve = null
      } else {
        queue.push(event)
      }
    }

    while (this.status !== "disconnected") {
      if (queue.length > 0) {
        yield queue.shift()!
      } else {
        yield await new Promise<Event>((r) => { resolve = r })
      }
    }
  }

  async close(): Promise<void> {
    this.eventSource?.close()
    this.status = "disconnected"
  }
}
```

### Step 3: å®ç° HTTP Server

```typescript
// src/server/server.ts (æ–°å»º)
import { Hono } from "hono"
import { streamSSE } from "hono/streaming"
import { Bus, GlobalBus } from "../bus"
import { SessionPrompt } from "../session/prompt"

const app = new Hono()

// POST /session/:sessionID/message
app.post("/session/:sessionID/message", async (c) => {
  const sessionID = c.req.param("sessionID")
  const body = await c.req.json()

  const message = await SessionPrompt.prompt({
    sessionID,
    parts: body.parts,
    agent: body.agent,
    model: body.model
  })

  return c.json(message)
})

// GET /event
app.get("/event", (c) => {
  return streamSSE(c, async (stream) => {
    await stream.writeSSE({
      data: JSON.stringify({ type: "server.connected", properties: {} })
    })

    const unsub = GlobalBus.on("event", async (evt) => {
      await stream.writeSSE({ data: JSON.stringify(evt.payload) })
    })

    const heartbeat = setInterval(() => {
      stream.writeSSE({
        data: JSON.stringify({ type: "server.heartbeat", properties: {} })
      })
    }, 30000)

    stream.onAbort(() => {
      clearInterval(heartbeat)
      unsub()
    })
  })
})

export const server = Bun.serve({
  port: 4096,
  fetch: app.fetch
})

console.log(`Server running at http://localhost:4096`)
```

### Step 4: æ¡¥æ¥ Bus åˆ° GlobalBus

```typescript
// src/bus/global.ts (æ–°å»º)
import { EventEmitter } from "events"
import { Bus } from "./index"

export const GlobalBus = new EventEmitter()

// æ¡¥æ¥æœ¬åœ°äº‹ä»¶åˆ°å…¨å±€
Bus.subscribeAll((event) => {
  GlobalBus.emit("event", { payload: event })
})
```

### Step 5: æ·»åŠ å·¥å‚æ¨¡å¼

```typescript
// src/transport/factory.ts (æ–°å»º)
import { ITransport } from "./interface"
import { DirectTransport } from "./direct"
import { HTTPTransport } from "./http"

export type TransportConfig =
  | { mode: "direct" }
  | { mode: "http"; baseUrl: string }

export class TransportFactory {
  static create(config: TransportConfig): ITransport {
    switch (config.mode) {
      case "direct":
        return new DirectTransport()
      case "http":
        return new HTTPTransport(config.baseUrl)
      default:
        throw new Error(`Unknown transport mode`)
    }
  }
}
```

### Step 6: æ›´æ–° CLI å…¥å£

```typescript
// src/cli/main.ts (ä¿®æ”¹)
import { TransportFactory } from "../transport/factory"

async function cli(prompt: string, config: Config) {
  const transport = TransportFactory.create(config.transport)

  await transport.send({
    sessionID: "temp",
    parts: [{ type: "text", text: prompt }]
  })

  for await (const event of transport.receive()) {
    // å¤„ç†äº‹ä»¶
  }

  await transport.close()
}
```

### Step 7: æ·»åŠ é…ç½®æ–‡ä»¶

```typescript
// config.json (æ–°å»º)
{
  "transport": {
    "mode": "http",
    "baseUrl": "http://localhost:4096"
  }
}

// config.ts (æ–°å»º)
import fs from "fs"

export function loadConfig(): Config {
  return JSON.parse(fs.readFileSync("./config.json", "utf-8"))
}
```

### Step 8: æµ‹è¯•

```bash
# å¯åŠ¨æœåŠ¡å™¨
npm run server

# æ–°ç»ˆç«¯æµ‹è¯• CLIï¼ˆHTTP æ¨¡å¼ï¼‰
npm run cli "fix the bug"

# æµ‹è¯•æµè§ˆå™¨
open http://localhost:4096
```

### éªŒè¯æ ‡å‡†

- âœ… CLI é€šè¿‡ HTTP è°ƒç”¨æ­£å¸¸å·¥ä½œ
- âœ… Web ç«¯å¯ä»¥è¿æ¥å¹¶æ¥æ”¶äº‹ä»¶
- âœ… å¤šå®¢æˆ·ç«¯å¯ä»¥åŒæ—¶è¿æ¥
- âœ… SSE è‡ªåŠ¨é‡è¿æ­£å¸¸

---

## ğŸ”Œ è¿ç§» 3ï¼šæ·»åŠ  WebSocket æ”¯æŒ

> **ç›®æ ‡**ï¼šæ”¯æŒåŒå‘å®æ—¶é€šä¿¡ã€‚

### Step 1: å®ç° WebSocketTransport

```typescript
// src/transport/websocket.ts (æ–°å»º)
import { ITransport, Message, Event, TransportStatus } from "./interface"
import { WebSocket } from "ws"

export class WebSocketTransport implements ITransport {
  status: TransportStatus = "connecting"
  private ws: WebSocket

  constructor(url: string, sessionID: string) {
    this.ws = new WebSocket(`${url}?sessionID=${sessionID}`)

    this.ws.on("open", () => {
      this.status = "connected"
    })

    this.ws.on("error", () => {
      this.status = "error"
    })

    this.ws.on("close", () => {
      this.status = "disconnected"
    })
  }

  async send(message: Message): Promise<void> {
    this.ws.send(JSON.stringify({ type: "prompt", data: message }))
  }

  async *receive(): AsyncIterable<Event> {
    const queue: Event[] = []
    let resolve: ((value: Event) => void) | null = null

    this.ws.on("message", (data) => {
      const event = JSON.parse(data.toString()) as Event
      if (resolve) {
        resolve(event)
        resolve = null
      } else {
        queue.push(event)
      }
    })

    while (this.status !== "disconnected") {
      if (queue.length > 0) {
        yield queue.shift()!
      } else {
        yield await new Promise<Event>((r) => { resolve = r })
      }
    }
  }

  async close(): Promise<void> {
    this.ws.close()
  }
}
```

### Step 2: å®ç° WebSocket Server

```typescript
// src/server/websocket.ts (æ–°å»º)
import { ServerWebSocket } from "bun"
import { Bus } from "../bus"
import { SessionPrompt } from "../session/prompt"

const connections = new Map<string, ServerWebSocket>()

export const websocketServer = {
  open(ws: ServerWebSocket) {
    connections.set(ws.data.clientID, ws)

    const unsub = Bus.subscribeAll((event) => {
      ws.send(JSON.stringify(event))
    })

    ws.data.unsub = unsub
  },

  async message(ws: ServerWebSocket, message: string) {
    const msg = JSON.parse(message)

    if (msg.type === "prompt") {
      await SessionPrompt.prompt(msg.data)
    }
  },

  close(ws: ServerWebSocket) {
    connections.delete(ws.data.clientID)
    ws.data.unsub?.()
  }
}

Bun.serve({
  port: 4096,
  websocket: websocketServer,
  fetch(req, server) {
    const url = new URL(req.url)
    if (url.pathname === "/ws") {
      const sessionID = url.searchParams.get("sessionID")
      server.upgrade(req, {
        data: { sessionID, clientID: crypto.randomUUID() }
      })
    }
    return new Response("WebSocket server")
  }
})
```

### Step 3: æ›´æ–°å·¥å‚

```typescript
// src/transport/factory.ts (ä¿®æ”¹)
import { WebSocketTransport } from "./websocket"

export type TransportConfig =
  | { mode: "direct" }
  | { mode: "http"; baseUrl: string }
  | { mode: "websocket"; url: string; sessionID: string }

export class TransportFactory {
  static create(config: TransportConfig): ITransport {
    switch (config.mode) {
      case "direct":
        return new DirectTransport()
      case "http":
        return new HTTPTransport(config.baseUrl)
      case "websocket":
        return new WebSocketTransport(config.url, config.sessionID)
    }
  }
}
```

### Step 4: æµ‹è¯•

```bash
# å¯åŠ¨ WebSocket æœåŠ¡å™¨
npm run ws-server

# æµ‹è¯• CLIï¼ˆWebSocket æ¨¡å¼ï¼‰
npm run cli "fix the bug"
```

---

## ğŸ¯ è¿ç§» 4ï¼šå¤šåè®®å…±å­˜

> **ç›®æ ‡**ï¼šåŒæ—¶æ”¯æŒ CLIã€HTTPã€WebSocketã€‚

### é…ç½®ç¤ºä¾‹

```json
// config.json
{
  "transport": {
    "modes": ["direct", "http", "websocket"],
    "default": "direct",
    "http": {
      "port": 4096,
      "hostname": "0.0.0.0"
    },
    "websocket": {
      "port": 4097,
      "hostname": "0.0.0.0"
    }
  }
}
```

### å¯åŠ¨è„šæœ¬

```typescript
// src/server/index.ts
import { loadConfig } from "../config"
import { startHTTPServer } from "./server"
import { startWebSocketServer } from "./websocket"

const config = loadConfig()

if (config.transport.modes.includes("http")) {
  startHTTPServer(config.transport.http)
}

if (config.transport.modes.includes("websocket")) {
  startWebSocketServer(config.transport.websocket)
}

console.log("All servers started")
```

---

## ğŸ“Š è¿ç§»å¯¹æ¯”è¡¨

| é˜¶æ®µ | åŠŸèƒ½ | æ”¹åŠ¨æ–‡ä»¶æ•° | æµ‹è¯•éš¾åº¦ | é£é™© |
|------|------|-----------|---------|------|
| **é˜¶æ®µ 1** | å¼•å…¥æŠ½è±¡å±‚ | 3 ä¸ª | ä½ | ä½ |
| **é˜¶æ®µ 2** | HTTP + SSE | 5 ä¸ª | ä¸­ | ä¸­ |
| **é˜¶æ®µ 3** | WebSocket | 3 ä¸ª | ä¸­ | ä¸­ |
| **é˜¶æ®µ 4** | å¤šåè®®å…±å­˜ | 2 ä¸ª | é«˜ | ä½ |

## âš ï¸ å¸¸è§é—®é¢˜

### Q1: è¿ç§»åæ€§èƒ½ä¸‹é™æ€ä¹ˆåŠï¼Ÿ

**A**: æ£€æŸ¥ä»¥ä¸‹å‡ ç‚¹ï¼š
- HTTP æ¨¡å¼ï¼šæ£€æŸ¥ç½‘ç»œå»¶è¿Ÿ
- åºåˆ—åŒ–å¼€é”€ï¼šä½¿ç”¨äºŒè¿›åˆ¶åè®®ï¼ˆMessagePackï¼‰
- è¿æ¥æ± ï¼šå¤ç”¨è¿æ¥

### Q2: å¦‚ä½•ä¿è¯å‘åå…¼å®¹ï¼Ÿ

**A**: ä½¿ç”¨é…ç½®åˆ‡æ¢ï¼š
```typescript
if (config.transport.mode === "direct") {
  // æ—§ä»£ç è·¯å¾„
} else {
  // æ–°ä»£ç è·¯å¾„
}
```

### Q3: å¦‚ä½•å›æ»šï¼Ÿ

**A**: ä¿®æ”¹é…ç½®æ–‡ä»¶å³å¯ï¼š
```json
{
  "transport": { "mode": "direct" }
}
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

```typescript
// src/transport/__tests__/direct.test.ts
import { DirectTransport } from "../direct"

test("DirectTransport sends and receives", async () => {
  const transport = new DirectTransport()

  await transport.send({
    sessionID: "test",
    parts: [{ type: "text", text: "hello" }]
  })

  const events = []
  for await (const event of transport.receive()) {
    events.push(event)
    if (event.type === "session.idle") break
  }

  expect(events.length).toBeGreaterThan(0)
})
```

### é›†æˆæµ‹è¯•

```typescript
// src/__tests__/integration.test.ts
import { TransportFactory } from "../transport/factory"

test("CLI works with all transports", async () => {
  const configs = [
    { mode: "direct" },
    { mode: "http", baseUrl: "http://localhost:4096" },
    { mode: "websocket", url: "ws://localhost:4097/ws", sessionID: "test" }
  ]

  for (const config of configs) {
    const transport = TransportFactory.create(config)
    await testPrompt(transport)
  }
})
```

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [å½“å‰æ–¹æ¡ˆï¼šCLI ç›´æ¥è°ƒç”¨](./01-å½“å‰æ–¹æ¡ˆ-CLIç›´æ¥è°ƒç”¨.md)
- [HTTP + SSE æ–¹æ¡ˆ](./02-æœªæ¥æ‰©å±•-HTTP+SSEæ–¹æ¡ˆ.md)
- [WebSocket æ–¹æ¡ˆ](./03-æœªæ¥æ‰©å±•-WebSocketæ–¹æ¡ˆ.md)
- [æ¶æ„è®¾è®¡ï¼šé€šä¿¡å±‚æŠ½è±¡](./04-æ¶æ„è®¾è®¡-é€šä¿¡å±‚æŠ½è±¡.md)

---

**è¿ç§»åŸåˆ™**ï¼šæ¸è¿›å¼ã€å¯å›æ»šã€ä¿æŒå…¼å®¹ã€‚
