# 问题分析

## 问题背景

### 错误日志

```
[2026-01-09 23:39:24.148] [ERROR] DeepSeek API 调用失败 (1/3): 400 An assistant message with 'tool_calls' must be followed by tool messages responding to each 'tool_call_id'. (insufficient tool messages following tool_calls message)
```

### 触发场景

当执行流程被中断时（用户输入新消息、超时、网络错误等），可能出现以下情况：

```
消息序列（不完整）:
1. [user] "请列出文件"
2. [assistant] { tool_calls: [{ id: "call_1", function: "ListFiles" }] }
3. ← 缺少 tool 消息！执行被中断
```

当下次调用 LLM 时，这个不完整的消息序列会导致 API 报错。

## 根因分析

### 消息添加时序

```
┌─────────────────────────────────────────────────────────────────┐
│                    正常执行流程                                   │
├─────────────────────────────────────────────────────────────────┤
│  1. LLM 返回 tool_calls                                          │
│  2. 添加 assistant 消息到 currentTurn  ← 此时已添加              │
│  3. 执行工具                                                     │
│  4. 添加 tool 消息到 currentTurn       ← 可能被中断              │
│  5. 继续下一轮 LLM 调用                                          │
└─────────────────────────────────────────────────────────────────┘
```

如果在步骤 3 和 4 之间发生中断，`assistant` 消息已经添加，但 `tool` 消息还没有。

### API 要求

DeepSeek/OpenAI API 要求：

> 每个带有 `tool_calls` 的 `assistant` 消息后面必须紧跟对应的 `tool` 消息。

这是因为 LLM 需要知道工具调用的结果才能继续推理。

## 解决方案概述

### 方案一：发送前验证（采用）

在调用 LLM 之前，验证消息序列的完整性，自动清理不完整的消息。

**优点**：
- 防御性编程，无论什么原因导致的不完整都能处理
- 不影响正常流程的性能

**实现位置**：`ContextManager.buildMessages()`

### 方案二：ESC 中断时清理（采用）

当用户按 ESC 中断时，主动清理当前轮次中不完整的消息，保留已完成的部分。

**优点**：
- 用户体验好，可以随时中断
- 保留已完成的工作，不会全部丢失

**实现位置**：`ToolLoopExecutor.buildCancelledResult()`

## 消息完整性规则

### 规则 1：tool_calls 必须有对应的 tool 响应

```typescript
// 有效
{ role: 'assistant', tool_calls: [{ id: 'call_1', ... }] }
{ role: 'tool', tool_call_id: 'call_1', content: '...' }

// 无效 - 缺少 tool 响应
{ role: 'assistant', tool_calls: [{ id: 'call_1', ... }] }
// 没有 tool 消息
```

### 规则 2：tool 消息必须有对应的 tool_call_id

```typescript
// 有效
{ role: 'assistant', tool_calls: [{ id: 'call_1', ... }] }
{ role: 'tool', tool_call_id: 'call_1', content: '...' }

// 无效 - 孤立的 tool 消息
{ role: 'tool', tool_call_id: 'orphan_id', content: '...' }
// 前面没有对应的 assistant.tool_calls
```

### 规则 3：多个 tool_calls 必须全部有响应

```typescript
// 有效
{ role: 'assistant', tool_calls: [
    { id: 'call_1', ... },
    { id: 'call_2', ... }
  ]
}
{ role: 'tool', tool_call_id: 'call_1', content: '...' }
{ role: 'tool', tool_call_id: 'call_2', content: '...' }

// 无效 - 部分响应
{ role: 'assistant', tool_calls: [
    { id: 'call_1', ... },
    { id: 'call_2', ... }
  ]
}
{ role: 'tool', tool_call_id: 'call_1', content: '...' }
// 缺少 call_2 的响应
```

