# 历史记录验证系统与 ESC 中断功能

## 概述

本次实现解决了两个核心问题：

1. **历史记录不完整导致 API 报错**：当执行流程被中断时，`assistant` 消息可能已包含 `tool_calls`，但对应的 `tool` 消息尚未添加，导致 DeepSeek API 报错。

2. **缺少用户主动中断机制**：用户无法在执行过程中按 ESC 中断当前操作。

## 文档目录

- [01-问题分析.md](./01-问题分析.md) - 问题背景和根因分析
- [02-消息验证工具实现.md](./02-消息验证工具实现.md) - `messageSanitizer.ts` 的设计与实现
- [03-ESC中断机制实现.md](./03-ESC中断机制实现.md) - 从 CLI 到 Core 的完整中断链路
- [04-修改文件清单.md](./04-修改文件清单.md) - 所有修改文件的汇总

## 核心架构

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLI 层                                   │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────┐  │
│  │   Session   │    │  InputArea  │    │     useAgent        │  │
│  │             │    │  ESC 监听   │───▶│  abort() 方法       │  │
│  └─────────────┘    └─────────────┘    └─────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Core 层                                   │
│  ┌─────────────┐    ┌─────────────────┐    ┌─────────────────┐  │
│  │    Agent    │    │ToolLoopExecutor │    │ContextManager   │  │
│  │ abort()     │───▶│ 中断检测        │───▶│ sanitize()      │  │
│  │ AbortCtrl   │    │ signal.aborted  │    │ 消息清理        │  │
│  └─────────────┘    └─────────────────┘    └─────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

## 快速理解

### 消息验证规则

1. **tool_calls 完整性**：每个带 `tool_calls` 的 `assistant` 消息后面必须有对应的 `tool` 消息
2. **tool 消息归属**：每个 `tool` 消息的 `tool_call_id` 必须在前面的 `assistant.tool_calls` 中存在

### ESC 中断流程

1. 用户按 ESC → `InputArea` 捕获
2. 调用 `useAgent.abort()` → `Agent.abort()`
3. `AbortController.abort()` 触发信号
4. `ToolLoopExecutor` 检测到中断
5. 调用 `sanitize()` 清理不完整消息
6. 返回 `cancelled: true` 结果

### 中断后的状态

- ✅ 保留：已完成的 assistant + tool 消息对
- ❌ 移除：不完整的 assistant 消息（有 tool_calls 但缺少 tool 响应）
- ❌ 移除：孤立的 tool 消息

