# 04 - 核心实现逻辑

> TODO 工具的核心设计思路与实现逻辑深度分析

---

## 📋 目录

1. [为什么这个设计优雅](#为什么这个设计优雅)
2. [核心设计决策](#核心设计决策)
3. [架构模式分析](#架构模式分析)
4. [数据流程详解](#数据流程详解)
5. [关键技术细节](#关键技术细节)

---

## 一、为什么这个设计优雅？

### 1.1 优雅的核心体现

| 维度 | 体现 |
|------|------|
| **职责分离** | 读写分离（CQRS）、分层架构 |
| **用户体验** | 写操作可见、读操作透明 |
| **实时性** | 事件驱动、无需轮询 |
| **类型安全** | 全程 TypeScript + Zod 验证 |
| **可扩展性** | 事件订阅、抽象接口 |
| **提示词工程** | 多层次强化、Few-Shot Learning |

### 1.2 优雅点 1：读写分离（CQRS）

```typescript
// Command（命令）- 修改状态
TodoWriteTool → Todo.update() → Storage.write() + Bus.publish()
    ↓
 UI 显示：[✓] 任务 1  [ ] 任务 2  [ ] 任务 3

// Query（查询）- 只读状态
TodoReadTool → Todo.get() → Storage.read()
    ↓
 UI 隐藏：不显示，避免噪音
```

**为什么优雅？**

1. **语义清晰**：写和读的意图明确
2. **UI 控制精准**：写操作展示，读操作隐藏
3. **副作用隔离**：读操作无副作用
4. **独立演化**：两个工具可以独立优化

**对比普通设计**：

```typescript
// ❌ 普通设计：一个工具同时支持读写
TodoTool({
  action: "read" | "write",
  todos?: Todo[]
})

// 问题：
// 1. 语义模糊：action 参数增加复杂度
// 2. UI 难控制：如何区分是否显示？
// 3. 工具描述混乱：需要同时解释两种模式
```

### 1.3 优雅点 2：事件驱动架构

```typescript
// 写入流程
Tool.execute() → Todo.update() → {
  Storage.write()      // 先持久化
  Bus.publish()        // 再发布事件
}

// 订阅流程
TUI 启动 → Bus.subscribe("todo.updated") → {
  setStore("todo", sessionID, todos)  // 更新 UI
}
```

**为什么优雅？**

1. **解耦**：工具不知道谁在监听
2. **可扩展**：轻松添加新订阅者（日志、分析等）
3. **实时性**：事件立即触发
4. **单向数据流**：数据流向清晰

**对比普通设计**：

```typescript
// ❌ 普通设计：直接调用 UI 更新
Tool.execute() → {
  Storage.write()
  UI.updateTodoList()  // 紧耦合
}

// 问题：
// 1. 紧耦合：工具依赖 UI 实现
// 2. 难扩展：添加新功能需要修改工具
// 3. 测试困难：需要 mock UI
```

### 1.4 优雅点 3：提示词工程

#### 3.4.1 多层次强化

```
层次 1: 工具描述（167 行）
├── 何时使用（7 个场景）
├── 何时不使用（4 个场景）
├── 正面示例（4 个）
├── 反面示例（4 个）
└── 状态管理规则

层次 2: 系统提示词（45 行）
├── Task Management 专门章节
├── Doing Tasks 流程提及
└── Tool Usage Policy 重点强调

层次 3: 示例展示（2 个）
├── 动态调整示例
└── 系统规划示例
```

**为什么优雅？**

- 工具描述告诉"如何用"
- 系统提示词告诉"何时用"
- 示例展示"实际用"

#### 3.4.2 Few-Shot Learning

```
正面示例 4 个：
1. 添加暗黑模式（多步骤功能）
2. 重命名函数（跨文件修改）
3. 实现电商功能（复杂系统）
4. 优化 React 应用（性能调优）

反面示例 4 个：
1. 打印 Hello World（单步操作）
2. 解释 git status（信息查询）
3. 添加注释（单一修改）
4. 运行 npm install（单一命令）
```

**为什么优雅？**

- 对比学习：让 LLM 理解边界
- 覆盖场景广：涵盖各种任务类型
- 推理标签：展示思考过程

---

## 二、核心设计决策

### 2.1 决策 1：为什么分成两个工具？

#### 原因 A：UI 可见性控制

```typescript
// UI 层过滤
export function AssistantMessageDisplay(props) {
  const filteredParts = createMemo(() => {
    return props.parts?.filter((x) => {
      return x.type !== "tool" || x.tool !== "todoread"  // 隐藏
    })
  })
}
```

**用户视角**：
- ✅ 看到：AI 规划了什么任务（TodoWrite）
- ❌ 看不到：AI 查询了任务状态（TodoRead）

#### 原因 B：工具语义清晰

```
TodoWriteTool: "我要告诉用户我的计划"
TodoReadTool:  "我要检查自己的进度"
```

#### 原因 C：提示词分离

- TodoWrite 描述：167 行（详尽指导）
- TodoRead 描述：15 行（简短说明）

### 2.2 决策 2：为什么使用事件驱动？

#### 需求分析

```
场景 1: CLI 前端需要实时显示 TODO
场景 2: 未来可能需要 Web 前端
场景 3: 可能需要日志记录
场景 4: 可能需要数据分析
```

#### 解决方案

```typescript
// 发布-订阅模式
Bus.publish(Todo.Event.Updated, { sessionID, todos })

// 任何订阅者都可以监听
TUI.subscribe(Todo.Event.Updated, (event) => { ... })
Web.subscribe(Todo.Event.Updated, (event) => { ... })
Logger.subscribe(Todo.Event.Updated, (event) => { ... })
Analytics.subscribe(Todo.Event.Updated, (event) => { ... })
```

#### 优势

1. **解耦**：发布者不知道订阅者
2. **扩展性**：轻松添加新功能
3. **实时性**：事件立即触发
4. **灵活性**：订阅者可以选择性监听

### 2.3 决策 3：为什么使用 JSON 文件存储？

#### 对比其他方案

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **JSON 文件** | 简单、便于调试、无需数据库 | 性能有限、并发控制复杂 | ✅ 单用户 CLI 工具 |
| SQLite | 性能好、事务支持 | 需要额外依赖、调试困难 | 多用户、高并发 |
| PostgreSQL | 功能强大、高性能 | 重量级、部署复杂 | 企业级应用 |
| In-Memory | 极快 | 重启丢失 | 临时数据 |

#### OpenCode 的选择

```typescript
// 使用 JSON 文件的理由
Storage.write(["todo", sessionID], todos)

// 存储路径
~/.opencode/storage/todo/{sessionID}.json
```

**为什么选择 JSON？**

1. ✅ **简单**：无需数据库配置
2. ✅ **便于调试**：直接查看文件内容
3. ✅ **便于迁移**：复制文件即可
4. ✅ **符合场景**：单用户 CLI 工具
5. ✅ **Bun 原生支持**：`Bun.file().json()`

### 2.4 决策 4：为什么使用文件锁？

#### 问题场景

```typescript
// 并发写入导致数据损坏
Time 1: Tool Call A 读取 [todo1, todo2]
Time 2: Tool Call B 读取 [todo1, todo2]
Time 3: A 添加 todo3，写入 [todo1, todo2, todo3]
Time 4: B 添加 todo4，写入 [todo1, todo2, todo4]  ← 丢失 todo3！
```

#### 解决方案

```typescript
export async function write<T>(key: string[], content: T) {
  using _ = await Lock.write(target)  // 获取写锁
  await Bun.write(target, JSON.stringify(content, null, 2))
  // 自动释放锁
}
```

**锁机制**：
- 读锁：允许多个读取，阻止写入
- 写锁：独占访问，阻止读取和写入

### 2.5 决策 5：为什么不用 enum 约束 status？

#### 对比方案

```typescript
// ❌ 方案 A：严格 enum
status: z.enum(["pending", "in_progress", "completed", "cancelled"])

// ✅ 方案 B：宽松 string + describe
status: z.string().describe("pending, in_progress, completed, cancelled")
```

#### 为什么选择方案 B？

**原因**：LLM 可能生成非枚举值

```json
// LLM 可能生成：
{ "status": "done" }        // 语义等同 completed
{ "status": "working" }     // 语义等同 in_progress
{ "status": "finished" }    // 语义等同 completed
```

**设计哲学**：
- 宽容的验证：提供指导而非强制
- 减少失败：避免工具调用失败
- 语义优先：关注意图而非格式

---

## 三、架构模式分析

### 3.1 分层架构

```
┌─────────────────────────────────────┐
│  Presentation Layer (UI)            │  ← CLI UI (SolidJS)
│  - 渲染 TODO 列表                    │
│  - 订阅事件更新                      │
└──────────────┬──────────────────────┘
               │ 事件订阅
               ▼
┌─────────────────────────────────────┐
│  Application Layer (Tool)           │  ← TodoWriteTool / TodoReadTool
│  - 参数验证                          │
│  - 调用业务逻辑                      │
└──────────────┬──────────────────────┘
               │ 方法调用
               ▼
┌─────────────────────────────────────┐
│  Domain Layer (Business Logic)     │  ← Todo.update() / Todo.get()
│  - 业务规则                          │
│  - 事件发布                          │
└──────────────┬──────────────────────┘
               │ 数据访问
        ┌──────┴──────┐
        ▼              ▼
┌────────────┐  ┌────────────┐
│Infrastructure│  │Infrastructure│  ← Storage / Bus
│ (Storage)  │  │  (Event Bus)│
└────────────┘  └────────────┘
```

**每层职责**：

1. **UI 层**：展示和交互
2. **Tool 层**：接口和验证
3. **Business 层**：业务逻辑和规则
4. **Infrastructure 层**：技术实现

### 3.2 CQRS 模式

```
Command Side (写入):
TodoWriteTool → Todo.update() → {
  Storage.write()
  Bus.publish()
}

Query Side (读取):
TodoReadTool → Todo.get() → Storage.read()
```

**CQRS 优势**：

1. **读写分离**：优化各自性能
2. **职责清晰**：命令修改状态，查询读取状态
3. **可扩展**：读写可以独立扩展
4. **事件驱动**：命令触发事件，查询不触发

### 3.3 Repository 模式

```typescript
// Storage 作为抽象数据访问层
export namespace Storage {
  export function read<T>(key: string[]): Promise<T>
  export function write<T>(key: string[], content: T): Promise<void>
  export function update<T>(key: string[], fn: (draft: T) => void): Promise<T>
}
```

**优势**：

1. **抽象存储**：可以从 JSON 切换到数据库
2. **统一接口**：所有数据访问都通过 Storage
3. **便于测试**：可以 mock Storage

### 3.4 Event Sourcing（部分）

```typescript
// 事件驱动的状态更新
Todo.update() → Bus.publish(Todo.Event.Updated) → UI.update()
```

虽然不是完整的 Event Sourcing（没有事件存储），但使用了：

1. **事件发布**：状态变更通过事件传播
2. **事件订阅**：UI 监听事件更新
3. **解耦**：发布者和订阅者解耦

---

## 四、数据流程详解

### 4.1 完整数据流程

```
┌──────────────────────────────────────────────────────────────┐
│ 1. LLM 决定使用 TodoWriteTool                                 │
│    - 基于系统提示词的指导                                      │
│    - 基于工具描述的场景匹配                                    │
└────────────────────┬─────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────┐
│ 2. 工具调用                                                   │
│    TodoWriteTool.execute({                                   │
│      todos: [                                                │
│        { id: "1", content: "...", status: "pending", ... },  │
│        { id: "2", content: "...", status: "in_progress", ...}│
│      ]                                                       │
│    }, { sessionID: "session-abc123" })                       │
└────────────────────┬─────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────┐
│ 3. 参数验证                                                   │
│    z.array(z.object(Todo.Info.shape)).parse(params.todos)   │
└────────────────────┬─────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────┐
│ 4. 调用业务逻辑                                               │
│    await Todo.update({                                       │
│      sessionID: "session-abc123",                            │
│      todos: [...]                                            │
│    })                                                        │
└────────────────────┬─────────────────────────────────────────┘
                     │
              ┌──────┴──────┐
              ▼              ▼
┌──────────────────┐  ┌──────────────────┐
│ 5a. 持久化存储    │  │ 5b. 发布事件      │
│ Storage.write(   │  │ Bus.publish(     │
│   ["todo", sid], │  │   Event.Updated, │
│   todos          │  │   { sid, todos } │
│ )                │  │ )                │
└──────────────────┘  └────────┬─────────┘
                               │
                               ▼
┌──────────────────────────────────────────────────────────────┐
│ 6. 事件传播                                                   │
│    GlobalBus.emit("event", {                                 │
│      type: "todo.updated",                                   │
│      properties: { sessionID, todos }                        │
│    })                                                        │
└────────────────────┬─────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────┐
│ 7. TUI 订阅处理                                               │
│    case "todo.updated":                                      │
│      setStore("todo", sessionID, todos)                      │
└────────────────────┬─────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────┐
│ 8. UI 响应式更新                                              │
│    SolidJS 检测到 Store 变化 → 触发组件重渲染                 │
└────────────────────┬─────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────┐
│ 9. 渲染到终端                                                 │
│    opentui 生成 ANSI 转义序列 → 输出到 stdout                 │
│                                                              │
│    显示结果:                                                  │
│    [✓] 分析现有代码结构                                       │
│    [ ] 设计新功能架构                                         │
│    [ ] 实现核心功能                                           │
└──────────────────────────────────────────────────────────────┘
```

### 4.2 关键时序

```
Time 0ms:   LLM 调用 TodoWriteTool
Time 1ms:   Zod 验证参数
Time 2ms:   调用 Todo.update()
Time 3ms:   获取文件写锁
Time 5ms:   写入 JSON 文件
Time 6ms:   释放文件写锁
Time 7ms:   Bus.publish() 发布事件
Time 8ms:   GlobalBus.emit() 传播事件
Time 9ms:   TUI 订阅者收到事件
Time 10ms:  setStore() 更新 Store
Time 11ms:  SolidJS 响应式系统触发
Time 15ms:  opentui 计算 Diff
Time 20ms:  生成 ANSI 转义序列
Time 25ms:  输出到终端显示
```

**总耗时**：~25ms（实时更新）

---

## 五、关键技术细节

### 5.1 Zod Schema 的妙用

#### 双重身份

```typescript
export const Info = z.object({
  content: z.string(),
  status: z.string(),
  priority: z.string(),
  id: z.string(),
})

// 用法 1: 作为类型
type TodoInfo = z.infer<typeof Info>

// 用法 2: 作为验证器
const validated = Info.parse(input)

// 用法 3: 在工具参数中使用
z.array(z.object(Todo.Info.shape))
```

#### 优势

1. **DRY 原则**：一次定义，多处使用
2. **类型安全**：TypeScript 编译时检查
3. **运行时验证**：Zod 运行时校验
4. **文档生成**：describe() 提供描述

### 5.2 文件锁的实现

```typescript
// 使用 using 声明（自动释放资源）
export async function write<T>(key: string[], content: T) {
  using _ = await Lock.write(target)  // 获取锁
  await Bun.write(target, JSON.stringify(content, null, 2))
  // 离开作用域时自动释放锁
}
```

**using 声明的优势**：

1. **自动释放**：无需手动 `finally`
2. **异常安全**：即使抛出异常也会释放
3. **代码简洁**：减少样板代码

### 5.3 事件总线的类型安全

```typescript
// 事件定义
export const Event = {
  Updated: BusEvent.define(
    "todo.updated",
    z.object({
      sessionID: z.string(),
      todos: z.array(Info),
    }),
  ),
}

// 发布（类型检查）
Bus.publish(Todo.Event.Updated, {
  sessionID: "abc",
  todos: [...]
})

// 订阅（类型推导）
Bus.subscribe(Todo.Event.Updated, (event) => {
  // event.properties 的类型已推导
  const { sessionID, todos } = event.properties
})
```

**优势**：

1. **编译时检查**：TypeScript 保证类型正确
2. **智能提示**：IDE 自动补全
3. **重构安全**：修改类型会触发错误

### 5.4 SolidJS 的细粒度响应式

```typescript
// 创建响应式数据
const [store, setStore] = createStore({
  todo: {
    [sessionID]: Todo[]
  }
})

// 创建派生状态
const todo = createMemo(() => store.todo[sessionID] ?? [])

// 只有 todo 变化时才重渲染
<For each={todo()}>
  {(item) => <TodoItem todo={item} />}
</For>
```

**优势**：

1. **细粒度更新**：只更新变化的部分
2. **性能优越**：避免不必要的重渲染
3. **自动追踪**：无需手动声明依赖

---

## 六、总结

### 6.1 核心设计原则

1. **单一职责**：每个模块只做一件事
2. **开闭原则**：对扩展开放，对修改封闭
3. **依赖倒置**：依赖抽象而非具体实现
4. **接口隔离**：最小化接口，只暴露必要方法
5. **里氏替换**：子类型可以替换父类型

### 6.2 关键实现技巧

1. **读写分离**：CQRS 模式
2. **事件驱动**：发布-订阅模式
3. **分层架构**：清晰的职责划分
4. **类型安全**：TypeScript + Zod
5. **提示词工程**：多层次强化 + Few-Shot Learning

### 6.3 优雅的本质

这个设计之所以优雅，是因为它：

1. **简单但不简陋**：每个部分都恰到好处
2. **灵活但不复杂**：可扩展但不过度设计
3. **严谨但不僵化**：类型安全但允许宽容
4. **强大但不笨重**：功能完整但轻量级
5. **教育意义**：代码本身就是最好的文档

---

**这是一个教科书级别的工具设计案例！** 🏆
