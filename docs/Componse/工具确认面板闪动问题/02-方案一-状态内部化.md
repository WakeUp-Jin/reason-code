# 方案一：将 `pendingConfirm` 状态移到 `InputArea` 内部

## 核心思路

让 `InputArea` 组件自己管理确认状态，而不是从 `useAgent()` 获取。这样状态变化只会影响 `InputArea`，不会影响 `Session`。

## 实现步骤

### Step 1: 修改 `useAgent` Hook

移除 `pendingConfirm` 和 `handleConfirm` 的返回，改为在 `sendMessage` 中接受确认回调参数。

```typescript
// packages/cli/src/hooks/useAgent.ts

// 修改返回类型
interface UseAgentReturn {
  isReady: boolean;
  isLoading: boolean;
  error: string | null;
  sendMessage: (
    message: string,
    options?: SendMessageOptions
  ) => Promise<string | null>;
  switchModel: (provider: string, model: string) => Promise<void>;
  currentModel: { provider: string; model: string } | null;
  // 移除: pendingConfirm
  // 移除: handleConfirm
}

// 新增选项类型
interface SendMessageOptions {
  /** 确认回调 - 由调用方提供 */
  onConfirmRequired?: (
    callId: string,
    toolName: string,
    details: ConfirmDetails
  ) => Promise<ConfirmOutcome>;
}

export function useAgent(): UseAgentReturn {
  const agentRef = useRef<Agent | null>(null);
  const [isReady, setIsReady] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentModel, setCurrentModel] = useState<{
    provider: string;
    model: string;
  } | null>(null);
  // 移除: const [pendingConfirm, setPendingConfirm] = useState(...)
  const { bindManager } = useExecution();

  const approvalMode = useAppStore((state) => state.config.approvalMode);

  // 初始化 Agent（保持不变）
  useEffect(() => {
    // ... 初始化逻辑不变
  }, [bindManager]);

  // 移除: onConfirmRequired useCallback
  // 移除: handleConfirm useCallback

  // 修改 sendMessage，接受 options 参数
  const sendMessage = useCallback(
    async (
      message: string,
      options?: SendMessageOptions
    ): Promise<string | null> => {
      if (!agentRef.current || !isReady) {
        logger.warn('Agent not ready');
        return null;
      }

      try {
        setIsLoading(true);

        // 获取历史消息
        const { currentSessionId, messages } = useAppStore.getState();
        const historyMessages = currentSessionId
          ? messages[currentSessionId] || []
          : [];

        const coreHistory = convertToCoreMsgs(historyMessages);
        agentRef.current.loadHistory(coreHistory, {
          clearExisting: true,
          skipSystemPrompt: true,
        });

        const modelLimit = currentModel
          ? getModelTokenLimit(currentModel.model)
          : undefined;

        let coreApprovalMode: ApprovalMode;
        if (approvalMode === 'default') {
          coreApprovalMode = 'default' as ApprovalMode;
        } else if (approvalMode === 'auto_edit') {
          coreApprovalMode = 'autoEdit' as ApprovalMode;
        } else {
          coreApprovalMode = 'yolo' as ApprovalMode;
        }

        // 使用传入的 onConfirmRequired 回调
        const result = await agentRef.current.run(message, {
          modelLimit,
          onConfirmRequired: options?.onConfirmRequired,
          approvalMode: coreApprovalMode,
        });

        if (result.success) {
          return result.finalResponse;
        } else {
          setError(result.error || 'Unknown error');
          return null;
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        setError(errorMessage);
        logger.error('Failed to send message', { error: err });
        return null;
      } finally {
        setIsLoading(false);
      }
    },
    [isReady, approvalMode, currentModel]
  );

  // 切换模型（保持不变）
  const switchModel = useCallback(
    async (provider: string, model: string): Promise<void> => {
      // ... 保持不变
    },
    []
  );

  return {
    isReady,
    isLoading,
    error,
    sendMessage,
    switchModel,
    currentModel,
    // 移除: pendingConfirm
    // 移除: handleConfirm
  };
}
```

### Step 2: 修改 `InputArea` 组件

在组件内部管理确认状态，类似 `commandPanelState` 的方式。

```typescript
// packages/cli/src/routes/session/inputArea.tsx

import React, { useState, useEffect, useCallback, type ReactNode } from 'react';
import { Box } from 'ink';
import { Prompt } from '../../component/prompt';
import { useStore, useAppStore } from '../../context/store';
import { useCurrentSession } from '../../context/store';
import { commandRegistry, CommandPanel } from '../../component/command/index.js';
import { PanelToolConfirm } from '../../component/panel/panel-tool-confirm.js';
import { logger } from '../../util/logger.js';
import { usePersistence } from '../../hooks/usePersistence.js';
import { useAgent } from '../../hooks/useAgent.js';
import type { ConfirmDetails, ConfirmOutcome } from '@reason-cli/core';

export interface InputAreaProps {
  onCommandPanelChange?: (isVisible: boolean) => void;
}

/** 工具确认请求 */
interface ToolConfirmRequest {
  callId: string;
  toolName: string;
  details: ConfirmDetails;
  resolve: (outcome: ConfirmOutcome) => void;
}

export function InputArea({ onCommandPanelChange }: InputAreaProps) {
  const addMessage = useStore((state) => state.addMessage);
  const updateMessage = useStore((state) => state.updateMessage);
  const session = useCurrentSession();
  const currentModel = useAppStore((state) => state.currentModel);
  const { saveCurrentSession } = usePersistence();

  // Agent Hook - 不再返回 pendingConfirm 和 handleConfirm
  const { isLoading, error, sendMessage } = useAgent();

  // 命令面板状态（保持不变）
  const [commandPanelState, setCommandPanelState] = useState<{
    command: string;
    panel: ReactNode;
  } | null>(null);

  // ⭐ 确认状态 - 现在在 InputArea 内部管理
  const [pendingConfirm, setPendingConfirm] = useState<ToolConfirmRequest | null>(
    null
  );

  // 当命令面板状态变化时，通知父组件
  useEffect(() => {
    onCommandPanelChange?.(commandPanelState !== null);
  }, [commandPanelState, onCommandPanelChange]);

  // ⭐ 处理用户确认
  const handleConfirm = useCallback(
    (outcome: ConfirmOutcome) => {
      if (pendingConfirm) {
        pendingConfirm.resolve(outcome); // 调用 resolve，Promise 完成
        setPendingConfirm(null); // 关闭确认面板
        logger.info(`Tool confirm: ${outcome}`, {
          callId: pendingConfirm.callId,
          toolName: pendingConfirm.toolName,
        });
      }
    },
    [pendingConfirm]
  );

  // 处理普通消息提交
  const handleSubmit = async (value: string) => {
    if (!session) return;

    // 添加用户消息
    addMessage(session.id, {
      role: 'user',
      content: value,
    });

    saveCurrentSession();

    // 添加 AI 响应占位消息
    const assistantMessage = addMessage(session.id, {
      role: 'assistant',
      content: '',
      isStreaming: true,
    });

    // ⭐ 调用 sendMessage，传入确认回调
    const response = await sendMessage(value, {
      onConfirmRequired: async (callId, toolName, details) => {
        return new Promise<ConfirmOutcome>((resolve) => {
          // 设置确认状态 - 这只会触发 InputArea 重新渲染，不会影响 Session
          setPendingConfirm({
            callId,
            toolName,
            details,
            resolve,
          });
        });
      },
    });

    // 更新 AI 响应
    if (response) {
      updateMessage(session.id, assistantMessage.id, {
        content: response,
        isStreaming: false,
      });
    } else {
      updateMessage(session.id, assistantMessage.id, {
        content: error || 'Failed to get response from AI.',
        isStreaming: false,
      });
    }

    saveCurrentSession();
  };

  // 处理命令执行（保持不变）
  const handleCommandExecute = (commandName: string) => {
    const command = commandRegistry.get(commandName);
    if (!command) {
      logger.warn(`Command "${commandName}" not found`);
      return;
    }

    if (command.type === 'instant') {
      command.action?.();
    } else if (command.type === 'panel') {
      const panel = command.panelFactory
        ? command.panelFactory(handleCloseCommandPanel)
        : command.panel || null;

      setCommandPanelState({
        command: commandName,
        panel: panel,
      });
    }
  };

  // 关闭命令面板（保持不变）
  const handleCloseCommandPanel = () => {
    setCommandPanelState(null);
  };

  return (
    <Box flexDirection="column" flexShrink={0}>
      {/* 工具确认面板优先级最高 */}
      {pendingConfirm ? (
        <PanelToolConfirm
          toolName={pendingConfirm.toolName}
          details={pendingConfirm.details}
          onConfirm={handleConfirm}
        />
      ) : commandPanelState ? (
        <CommandPanel
          command={commandPanelState.command}
          panel={commandPanelState.panel}
          onClose={handleCloseCommandPanel}
        />
      ) : (
        <Prompt
          onSubmit={handleSubmit}
          onCommandExecute={handleCommandExecute}
          placeholder="Type your message..."
        />
      )}
    </Box>
  );
}
```

## 状态流程对比

### 修改前

```
Agent 需要确认
    ↓
useAgent 中 setPendingConfirm()
    ↓
useAgent 返回值变化
    ↓
InputArea 重新渲染
    ↓
同时 ExecutionContext 也更新
    ↓
Session 重新渲染（因为订阅了 ExecutionContext）
    ↓
Static 重新打印
    ↓
❌ 闪动
```

### 修改后

```
Agent 需要确认
    ↓
调用 options.onConfirmRequired 回调
    ↓
InputArea 中 setPendingConfirm()
    ↓
只有 InputArea 重新渲染
    ↓
Session 不重新渲染
    ↓
Static 不重新打印
    ↓
✅ 不闪动
```

## 优点

1. **简单直接**：和 `/model` 的模式一致
2. **状态隔离**：确认状态只影响 `InputArea`
3. **可靠性高**：不依赖 React 的渲染优化机制
4. **易于理解**：状态在需要它的组件内部管理

## 缺点

1. **接口变化**：需要修改 `useAgent` 的接口
2. **调用方式变化**：`sendMessage` 需要传入回调参数

## 注意事项

1. 确保 `onConfirmRequired` 回调正确处理 Promise
2. 确保在确认完成后正确清理 `pendingConfirm` 状态
3. 考虑错误处理：如果用户在确认过程中发生错误，需要正确处理

