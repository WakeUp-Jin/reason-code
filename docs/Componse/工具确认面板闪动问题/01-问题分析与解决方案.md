# 工具确认面板闪动问题分析与解决方案

## 问题描述

当 `PanelToolConfirm` 组件显示时，终端会出现闪动现象，在确认面板和 REASON logo 之间来回切换。而使用 `/model` 命令显示的 `PanelModel` 面板则不会出现此问题。

## 问题根因分析

### 关键对比：`/model` vs `PanelToolConfirm`

| 特性 | `/model` 命令 | `PanelToolConfirm` |
|-----|--------------|-------------------|
| 状态来源 | `InputArea` 内部的 `useState` | `useAgent()` hook |
| 状态变化影响范围 | 只影响 `InputArea` 组件 | 影响整个 `Session` 组件 |
| 是否触发 `Static` 重新打印 | ❌ 不会 | ✅ 会 |

### 闪动的根本原因

Ink 框架的 `Static` 组件有一个特性：**当父组件重新渲染时，`Static` 会重新打印其内容**。

#### `/model` 命令的触发流程（不闪动）

```
用户输入 /model
    ↓
handleCommandExecute() 被调用
    ↓
setCommandPanelState({ command: 'model', panel: <PanelModel /> })
    ↓
只有 InputArea 组件重新渲染
    ↓
Session 组件不重新渲染
    ↓
Static 组件不重新打印
    ↓
✅ 不闪动
```

#### `PanelToolConfirm` 的触发流程（闪动）

```
Agent 执行工具，需要确认
    ↓
ToolScheduler.execute() 检测到需要确认
    ↓
executionStream.awaitingApproval() 被调用
    ↓
ExecutionStreamManager 设置 snapshot.state = WaitingConfirm
    ↓
触发 emitStateChange()
    ↓
ExecutionProvider 中的 setSnapshot() 被调用
    ↓
ExecutionContext 的 value 变化
    ↓
Session 组件使用了 useExecution()，所以整个 Session 重新渲染
    ↓
Static 组件重新打印 REASON logo
    ↓
❌ 闪动！
```

### 状态更新链路图

```
┌─────────────────────────────────────────────────────────────────┐
│                        Core 层                                   │
│  ┌─────────────┐    ┌──────────────────┐    ┌────────────────┐  │
│  │ToolScheduler│───>│ExecutionStream   │───>│awaitingApproval│  │
│  │  .execute() │    │    Manager       │    │     ()         │  │
│  └─────────────┘    └──────────────────┘    └───────┬────────┘  │
└─────────────────────────────────────────────────────┼───────────┘
                                                      │
                                                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                        CLI 层                                    │
│                                                                  │
│  ┌────────────────┐    ┌─────────────┐    ┌──────────────────┐  │
│  │ExecutionProvider│───>│setSnapshot()│───>│Context value变化 │  │
│  │   .on(event)   │    │             │    │                  │  │
│  └────────────────┘    └─────────────┘    └────────┬─────────┘  │
│                                                     │            │
│                                                     ▼            │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                    Session 组件                              ││
│  │  const { isExecuting } = useExecution(); // 订阅了 Context  ││
│  │                          ↓                                   ││
│  │                    组件重新渲染                               ││
│  │                          ↓                                   ││
│  │  ┌─────────────────────────────────────────────────────────┐││
│  │  │              Static 组件                                 │││
│  │  │  <Static items={staticItems}>                           │││
│  │  │      <Header />  ← 重新打印 REASON logo                  │││
│  │  │      ...messages                                        │││
│  │  │  </Static>                                              │││
│  │  └─────────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

### 为什么 `/model` 不会触发这个链路？

因为 `/model` 的状态 `commandPanelState` 是 `InputArea` 组件内部的 `useState`：

```typescript
// InputArea 组件内部
const [commandPanelState, setCommandPanelState] = useState<{
  command: string;
  panel: ReactNode;
} | null>(null);
```

当 `setCommandPanelState` 被调用时：
- 只有 `InputArea` 组件重新渲染
- `Session` 组件不会重新渲染（因为 `commandPanelState` 不是它的 props 或 context）
- `Static` 组件不会重新打印

## 解决方案

### 方案 1：将 `pendingConfirm` 状态移到 `InputArea` 内部（推荐）

**核心思路**：让 `InputArea` 组件自己管理确认状态，而不是从 `useAgent()` 获取。这样状态变化只会影响 `InputArea`，不会影响 `Session`。

详见：[02-方案一-状态内部化.md](./02-方案一-状态内部化.md)

### 方案 2：将 `Static` 区域隔离为独立组件

**核心思路**：使用 React 的渲染优化技术（`memo`），确保 `Static` 区域只在 `completedMessages` 真正变化时才重新渲染。

详见：[03-方案二-Static组件隔离.md](./03-方案二-Static组件隔离.md)

## 方案对比

| 对比项 | 方案 1：状态内部化 | 方案 2：Static 隔离 |
|-------|------------------|-------------------|
| 实现复杂度 | 简单 | 中等 |
| 代码改动量 | 中等 | 较大 |
| 与现有模式一致性 | ✅ 和 `/model` 一致 | 需要新模式 |
| 可靠性 | ✅ 高 | 依赖 memo 机制 |
| 推荐程度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

## 推荐方案

**推荐使用方案 1**，原因：
1. 更简单直接
2. 和现有的 `/model` 模式一致
3. 不依赖 React 的渲染优化机制（这些机制有时候会有意外行为）
4. 状态管理更清晰 - 确认状态就应该在需要它的组件内部

## 相关文件

- `packages/cli/src/routes/session/inputArea.tsx` - 输入区域组件
- `packages/cli/src/routes/session/index.tsx` - Session 主组件
- `packages/cli/src/hooks/useAgent.ts` - Agent Hook
- `packages/cli/src/context/execution.tsx` - 执行流 Context
- `packages/cli/src/component/panel/panel-tool-confirm.tsx` - 工具确认面板
- `packages/core/src/core/execution/ExecutionStreamManager.ts` - 执行流管理器

