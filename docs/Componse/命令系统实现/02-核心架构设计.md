# 核心架构设计

## 命令注册系统

### CommandDef 接口

命令定义接口，描述一个命令的所有属性：

```typescript
export interface CommandDef {
  id: string;              // 唯一标识符
  name: string;            // 命令名（不含 /）
  label: string;           // 显示名称
  description: string;     // 描述文本
  category: string;        // 分类（Model, Session, Appearance, System）

  // 命令类型
  type: 'instant' | 'panel';

  // Instant 命令的处理函数
  action?: () => void;

  // Panel 命令的面板组件
  panel?: ReactNode;
}
```

### CommandRegistry 类

命令注册表，负责管理所有命令的注册、查询和执行。

#### 核心方法

**1. 注册命令**
```typescript
register(command: CommandDef): void {
  if (this.commands.has(command.name)) {
    console.warn(`Command "${command.name}" already registered, overwriting...`);
  }
  this.commands.set(command.name, command);
}
```

**2. 获取命令**
```typescript
get(name: string): CommandDef | undefined {
  return this.commands.get(name);
}
```

**3. 模糊搜索**
```typescript
search(query: string): CommandDef[] {
  const allCommands = this.getAll();

  // 空查询返回所有命令
  if (!query.trim()) {
    return allCommands;
  }

  // 使用 fuzzysort 进行模糊搜索
  const results = fuzzysort.go(query, allCommands, {
    keys: ['name', 'label', 'description', 'category'],
    threshold: -10000,
  });

  return results.map((r) => r.obj);
}
```

**4. 执行命令**
```typescript
execute(name: string): boolean {
  const command = this.get(name);
  if (!command) {
    console.warn(`Command "${name}" not found`);
    return false;
  }

  if (command.type === 'instant' && command.action) {
    command.action();
    return true;
  }

  return false;
}
```

### 单例模式

```typescript
export const commandRegistry = new CommandRegistry();
```

全局唯一的命令注册表实例，确保所有命令在同一个注册表中管理。

## 数据流设计

### 命令补全流程

```
用户输入 "/"
    ↓
Prompt 检测到命令模式
    ↓
设置 commandMode = 'autocomplete'
    ↓
调用 commandRegistry.search("")
    ↓
返回所有命令列表
    ↓
渲染 CommandComplete 组件
    ↓
用户继续输入 "m"
    ↓
调用 commandRegistry.search("m")
    ↓
返回匹配 "m" 的命令
    ↓
更新 CommandComplete 显示
    ↓
用户按 Tab/Enter
    ↓
补全命令到输入框 "/model "
```

### 命令执行流程

```
用户输入 "/model" 并按 Enter
    ↓
Prompt.handleSubmit 检测到命令
    ↓
提取命令名 "model"
    ↓
调用 onCommandExecute("model")
    ↓
InputArea.handleCommandExecute
    ↓
调用 commandRegistry.get("model")
    ↓
检查命令类型
    ├─ Instant: 直接执行 command.action()
    └─ Panel: setCommandPanelState({
                command: "model",
                panel: <DialogModel />
              })
    ↓
渲染 CommandPanel（隐藏输入框）
    ↓
用户在面板中选择
    ↓
Dialog 内部调用 pop()
    ↓
CommandPanel 监听到 isOpen = false
    ↓
调用 onClose()
    ↓
setCommandPanelState(null)
    ↓
恢复输入框显示
```

## 组件架构

### CommandComplete 组件

**职责**：显示命令补全列表

**关键特性**：
- 按分类分组显示
- 支持滚动（超过可见高度）
- 键盘导航
- 高亮当前选中项

**Props**：
```typescript
interface CommandCompleteProps {
  query: string;              // 搜索关键词
  commands: CommandDef[];     // 命令列表
  selectedIndex: number;      // 当前选中索引
  onSelect: (cmd: CommandDef) => void;  // 选择回调
  onCancel: () => void;       // 取消回调
}
```

**渲染逻辑**：
```typescript
// 按分类分组
const categories = commands.reduce((acc, cmd) => {
  if (!acc[cmd.category]) {
    acc[cmd.category] = [];
  }
  acc[cmd.category].push(cmd);
  return acc;
}, {} as Record<string, CommandDef[]>);

// 渲染分类
Object.entries(categories).map(([category, cmds]) => (
  <Box key={category}>
    <Text bold>{category}</Text>
    {cmds.map((cmd) => (
      <CommandItem
        key={cmd.id}
        command={cmd}
        selected={...}
      />
    ))}
  </Box>
))
```

### CommandPanel 组件

**职责**：功能面板容器，替换输入框位置显示

**关键特性**：
- 显示面板内容
- 底部显示当前命令
- 监听 Esc 键关闭
- 自动监听 Dialog 关闭

**Props**：
```typescript
interface CommandPanelProps {
  command: string;      // 命令名（如 "model"）
  panel: ReactNode;     // 面板组件
  onClose: () => void;  // 关闭回调
}
```

**智能关闭逻辑**：
```typescript
const { isOpen } = useDialog();

// 监听 Dialog 关闭
useEffect(() => {
  if (!isOpen) {
    onClose();
  }
}, [isOpen, onClose]);

// 监听 Esc 键
useInput((input, key) => {
  if (key.escape) {
    onClose();
  }
});
```

### Prompt 组件改造

**新增状态**：
```typescript
const [commandMode, setCommandMode] = useState<'autocomplete' | null>(null);
const [selectedCommandIndex, setSelectedCommandIndex] = useState(0);
```

**命令检测**：
```typescript
const isCommand = value.startsWith('/');
const commandQuery = isCommand ? value.slice(1) : '';

useEffect(() => {
  if (isCommand) {
    setCommandMode('autocomplete');
  } else {
    setCommandMode(null);
  }
}, [isCommand]);
```

**提交处理**：
```typescript
const handleSubmit = () => {
  const trimmedValue = value.trim();

  // 检查是否是命令
  if (trimmedValue.startsWith('/')) {
    const commandName = trimmedValue.slice(1).split(' ')[0];
    if (onCommandExecute) {
      onCommandExecute(commandName);
    }
    setValue('');
    return;
  }

  // 普通消息
  onSubmit(trimmedValue);
  setValue('');
};
```

### InputArea 组件改造

**新增状态**：
```typescript
const [commandPanelState, setCommandPanelState] = useState<{
  command: string;
  panel: ReactNode;
} | null>(null);
```

**命令执行**：
```typescript
const handleCommandExecute = (commandName: string) => {
  const command = commandRegistry.get(commandName);
  if (!command) return;

  if (command.type === 'instant') {
    // 立即执行
    command.action?.();
  } else if (command.type === 'panel') {
    // 显示面板
    setCommandPanelState({
      command: commandName,
      panel: command.panel || null,
    });
  }
};
```

**条件渲染**：
```typescript
return (
  <Box flexDirection="column" flexShrink={0}>
    {commandPanelState ? (
      <CommandPanel
        command={commandPanelState.command}
        panel={commandPanelState.panel}
        onClose={() => setCommandPanelState(null)}
      />
    ) : (
      <Prompt
        onSubmit={handleSubmit}
        onCommandExecute={handleCommandExecute}
        placeholder="Type your message..."
      />
    )}
  </Box>
);
```

## 键盘交互设计

### 命令补全模式

| 按键 | 操作 |
|------|------|
| 上箭头 | 向上导航命令列表 |
| 下箭头 | 向下导航命令列表 |
| Tab | 补全当前选中命令 |
| Enter | 补全并执行命令 |
| Esc | 取消命令模式 |
| 其他字符 | 继续输入，更新搜索 |

### 功能面板模式

| 按键 | 操作 |
|------|------|
| Esc | 关闭面板，返回输入模式 |
| 其他 | 由面板内部组件处理 |

### 键盘冲突处理

**问题**：上下键在命令模式和历史记录模式下都需要使用。

**解决方案**：
```typescript
useInput((input, key) => {
  // 命令补全模式优先
  if (commandMode === 'autocomplete' && filteredCommands.length > 0) {
    if (key.upArrow) {
      setSelectedCommandIndex((prev) => Math.max(0, prev - 1));
      return; // 不继续执行
    }
    if (key.downArrow) {
      setSelectedCommandIndex((prev) =>
        Math.min(filteredCommands.length - 1, prev + 1)
      );
      return; // 不继续执行
    }
  }

  // 历史记录模式
  if (key.upArrow && !isCommand) {
    handleHistoryUp();
  }
  if (key.downArrow && !isCommand) {
    handleHistoryDown();
  }
});
```

## 类型安全

### 命令定义类型检查

TypeScript 确保每个命令都符合 `CommandDef` 接口：

```typescript
commandRegistry.register({
  id: 'model',
  name: 'model',
  label: 'Select Model',
  description: 'Change AI model',
  category: 'Model',
  type: 'panel',
  panel: <DialogModel />,  // ✅ panel 类型必须提供 panel
});

commandRegistry.register({
  id: 'clear',
  name: 'clear',
  label: 'Clear Screen',
  description: 'Clear terminal screen',
  category: 'System',
  type: 'instant',
  action: () => { ... },   // ✅ instant 类型必须提供 action
});
```

### 组件 Props 类型检查

所有组件都有明确的 Props 接口：

```typescript
export interface CommandPanelProps {
  command: string;
  panel: ReactNode;
  onClose: () => void;
}

export function CommandPanel({ command, panel, onClose }: CommandPanelProps) {
  // TypeScript 确保 props 类型正确
}
```

## 扩展性设计

### 添加新命令

只需在 `commands.tsx` 中注册：

```typescript
commandRegistry.register({
  id: 'export',
  name: 'export',
  label: 'Export Chat',
  description: 'Export current conversation',
  category: 'System',
  type: 'instant',
  action: () => {
    // 导出逻辑
  },
});
```

### 添加新命令类型

可以扩展 `CommandDef` 接口：

```typescript
export interface CommandDef {
  // 现有字段...
  type: 'instant' | 'panel' | 'wizard';  // 新增 wizard 类型

  // 新增字段
  steps?: WizardStep[];
}
```

### 自定义分类

分类只是一个字符串，可以随意定义：

```typescript
category: 'Advanced'      // 新分类
category: 'Experimental'  // 实验性功能
category: 'Plugin'        // 插件命令
```

## 性能考虑

1. **搜索优化**：使用 fuzzysort 库，性能优异
2. **缓存结果**：使用 useMemo 缓存搜索结果
3. **按需渲染**：只在需要时渲染补全面板
4. **懒加载**：面板组件可以使用 React.lazy 懒加载

## 总结

命令系统的核心架构设计遵循以下原则：

- **单一职责**：每个组件专注一个功能
- **类型安全**：充分利用 TypeScript 类型系统
- **易于扩展**：模块化设计，易于添加新命令
- **良好的用户体验**：键盘交互流畅，反馈及时
- **性能优化**：合理使用缓存和按需渲染
