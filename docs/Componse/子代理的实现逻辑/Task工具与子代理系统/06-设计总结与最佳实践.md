# 设计总结与最佳实践

## 一、系统架构总览

### 核心组件

```
┌───────────────────────────────────────────────────────────────┐
│                        用户界面层                              │
│  (CLI / TUI / Web Interface)                                  │
└──────────────────────┬────────────────────────────────────────┘
                       │
                       ▼
┌───────────────────────────────────────────────────────────────┐
│                     命令处理层                                 │
│  - SessionPrompt.command()                                    │
│  - 命令解析                                                    │
│  - SubtaskPart 创建                                            │
└──────────────────────┬────────────────────────────────────────┘
                       │
                       ▼
┌───────────────────────────────────────────────────────────────┐
│                    会话管理层                                  │
│  - SessionPrompt.loop()                                       │
│  - 消息队列管理                                                │
│  - SubtaskPart 检测与执行                                      │
└──────────────────────┬────────────────────────────────────────┘
                       │
          ┌────────────┴────────────┐
          │                         │
          ▼                         ▼
┌──────────────────┐      ┌──────────────────────┐
│   正常 LLM 处理  │      │  SubtaskPart 处理    │
│  - LLM 推理      │      │  - 直接执行 Task     │
│  - 工具调用      │      │  - 无需 LLM 决策     │
└────────┬─────────┘      └──────────┬───────────┘
         │                           │
         │    ┌──────────────────────┘
         │    │
         ▼    ▼
┌───────────────────────────────────────────────────────────────┐
│                     Task 工具层                                │
│  - TaskTool.execute()                                         │
│  - 子会话创建                                                  │
│  - 事件订阅                                                    │
│  - 工具权限控制                                                │
└──────────────────────┬────────────────────────────────────────┘
                       │
                       ▼
┌───────────────────────────────────────────────────────────────┐
│                     代理执行层                                 │
│  ┌─────────────────────────────────────────────────┐          │
│  │  父会话 (主代理)                                 │          │
│  │  - Agent: build / plan                          │          │
│  │  - 完整工具访问                                  │          │
│  │  - 用户交互                                      │          │
│  └────────────┬────────────────────────────────────┘          │
│               │                                                │
│               │ parentID                                       │
│               │                                                │
│     ┌─────────┴──────────┬──────────────┐                     │
│     │                    │              │                     │
│     ▼                    ▼              ▼                     │
│  ┌─────────┐        ┌─────────┐    ┌─────────┐               │
│  │子会话 1  │        │子会话 2  │    │子会话 3  │               │
│  │explore  │        │general  │    │explore  │               │
│  │受限工具  │        │受限工具  │    │受限工具  │               │
│  └─────────┘        └─────────┘    └─────────┘               │
└───────────────────────────────────────────────────────────────┘
```

### 数据流

```
用户输入
  ↓
命令/文本解析
  ↓
创建消息 Part (TextPart / SubtaskPart / AgentPart)
  ↓
SessionPrompt.loop() 主循环
  ↓
  ├→ SubtaskPart? → 直接执行 Task → 创建子会话 → 子代理执行
  └→ 普通 Part? → LLM 处理 → 可能调用 Task → 创建子会话 → 子代理执行
                              ↓
                          结果返回父会话
                              ↓
                          LLM 继续处理 / 添加合成消息
                              ↓
                          任务完成
```

## 二、设计原则

### 1. 单一职责原则

每个组件有明确的职责：

| 组件 | 职责 |
|------|------|
| **Agent** | 定义代理的模式、权限、工具配置 |
| **Task Tool** | 创建子会话、执行子代理、返回结果 |
| **Session** | 管理会话生命周期、消息队列 |
| **SessionPrompt** | 处理消息流、执行主循环 |
| **SubtaskPart** | 声明式子代理调用 |

### 2. 开放封闭原则

**对扩展开放**:
- 用户可以定义自定义代理（mode: "all"）
- 用户可以定义自定义命令
- 支持插件系统（Plugin.trigger）

**对修改封闭**:
- 内置代理的核心逻辑不变
- Task 工具的执行流程稳定
- 子会话创建机制固定

### 3. 依赖倒置原则

高层模块（SessionPrompt）不依赖低层模块（具体代理），都依赖抽象（Agent.Info）：

```typescript
// 高层模块
const agent = await Agent.get(agentName)  // 依赖抽象
const result = await SessionPrompt.prompt({
  agent: agent.name,  // 使用抽象接口
  tools: agent.tools,
  ...
})
```

### 4. 最小权限原则

子代理默认受限：

```typescript
tools: {
  todowrite: false,  // 禁用
  todoread: false,
  task: false,       // 防止递归
  ...agent.tools,    // 显式允许的工具
}
```

## 三、关键设计决策

### 决策 1: 为什么需要 SubtaskPart？

**问题**: 命令如何触发子代理？

**选项**:
1. 命令直接调用 Task 工具
2. 命令创建普通消息，LLM 决策
3. 命令创建 SubtaskPart，loop 检测并执行

**选择**: 选项 3 (SubtaskPart)

**原因**:
- **性能**: 无需 LLM 推理，直接执行
- **确定性**: 用户明确知道会发生什么
- **成本**: 节省 token 消耗
- **一致性**: 与 LLM 调用共享相同的执行路径

### 决策 2: 为什么子会话不能嵌套调用 Task？

**问题**: 子代理是否应该能调用其他子代理？

**选项**:
1. 允许嵌套调用（子代理 → Task → 孙代理）
2. 禁止嵌套调用

**选择**: 选项 2 (禁止)

**原因**:
- **防止无限递归**: `general → task → general → task → ...`
- **控制复杂度**: 限制调用深度，避免难以追踪
- **性能考虑**: 嵌套调用会指数级增加开销
- **简化设计**: 单层调用更容易理解和维护

**实现**:
```typescript
// task.ts:100-106
tools: {
  task: false,  // 强制禁用
  ...
}
```

### 决策 3: 为什么需要合成用户消息？

**问题**: SubtaskPart 执行后，如何继续？

**选项**:
1. 直接进入下一轮 LLM 处理
2. 添加合成用户消息

**选择**: 选项 2 (合成消息)

**原因**:
- **模型兼容性**: 某些模型（如 Gemini）要求严格的 user/assistant 交替
- **明确指示**: 告诉 LLM 总结 Task 输出并继续
- **上下文连贯**: 提供自然的对话流

**示例问题场景**:
```
User: /explore find tests
Assistant: (Task 执行结果)
Assistant: (接下来的响应)  ❌ 两个连续的 assistant
```

**解决方案**:
```
User: /explore find tests
Assistant: (Task 执行结果)
User: (合成) "Summarize the task tool output..."  ← 插入
Assistant: (接下来的响应)  ✅ 符合要求
```

### 决策 4: 为什么父会话不能看到子会话的消息？

**问题**: 父会话是否应该能访问子会话的消息？

**选项**:
1. 父会话可以查询子会话的消息
2. 完全隔离，通过 Task 返回值传递

**选择**: 选项 2 (完全隔离)

**原因**:
- **上下文管理**: 避免父会话上下文过长
- **权限隔离**: 子会话可能包含敏感操作
- **清晰的接口**: 通过返回值明确传递信息
- **并行执行**: 隔离避免并发访问冲突

### 决策 5: 为什么需要三种代理模式？

**问题**: 如何区分不同类型的代理？

**选项**:
1. 只有一种代理类型，通过配置区分
2. 定义多种模式（primary/subagent/all）

**选择**: 选项 2 (三种模式)

**原因**:
- **明确语义**: mode 明确表达代理的用途
- **工具过滤**: Task 可以轻松过滤 primary 代理
- **UI 展示**: 不同模式在 UI 中有不同表现
- **权限控制**: mode 作为权限配置的依据

## 四、最佳实践

### 1. 自定义子代理

**场景**: 创建专门的代码审查子代理。

**配置示例**:

```markdown
<!-- .opencode/agent/code-reviewer.md -->
---
description: Code review specialist
mode: subagent
model: anthropic/claude-sonnet-4
temperature: 0.2
tools:
  write: false
  edit: false
  bash:
    "*": deny
permission:
  edit: deny
  bash:
    "*": deny
---

You are an expert code reviewer. Your task is to:
1. Analyze code for bugs, security issues, and best practices
2. Provide specific, actionable feedback
3. Suggest improvements with code examples

Focus on:
- Code quality and maintainability
- Security vulnerabilities
- Performance issues
- Best practices and design patterns

Format your review as:
## Summary
[Brief overview]

## Issues Found
[List of issues with severity]

## Recommendations
[Specific suggestions]
```

**使用**:
```bash
/review path/to/file.ts
```

或：
```typescript
// LLM 会自动调用
{
  "tool": "task",
  "arguments": {
    "subagent_type": "code-reviewer",
    "prompt": "Review the authentication code",
    "description": "Code review"
  }
}
```

### 2. 会话复用实现多轮对话

**场景**: 与子代理进行多轮交互。

**实现**:

```typescript
// 第一轮：查找文件
const result1 = await TaskTool.execute({
  description: "Find test files",
  prompt: "Find all test files in src/",
  subagent_type: "explore"
}, ctx)

const sessionId = result1.metadata.sessionId

// 第二轮：分析文件（复用会话）
const result2 = await TaskTool.execute({
  description: "Analyze tests",
  prompt: "For the test files you found, summarize what each tests",
  subagent_type: "explore",
  session_id: sessionId  // 复用会话
}, ctx)

// 第三轮：继续分析
const result3 = await TaskTool.execute({
  description: "Find gaps",
  prompt: "Identify any gaps in test coverage",
  subagent_type: "explore",
  session_id: sessionId  // 继续复用
}, ctx)
```

**好处**:
- 子代理保持上下文
- 避免重复工作
- 更自然的对话流

### 3. 并行执行多个子代理

**场景**: 同时执行多个独立的子任务。

**实现**:

```typescript
// 并行执行多个子代理
const [testsResult, docsResult, typesResult] = await Promise.all([
  TaskTool.execute({
    description: "Find tests",
    prompt: "Find all test files",
    subagent_type: "explore"
  }, ctx),

  TaskTool.execute({
    description: "Search docs",
    prompt: "Find documentation files",
    subagent_type: "explore"
  }, ctx),

  TaskTool.execute({
    description: "Check types",
    prompt: "Find TypeScript type definition files",
    subagent_type: "explore"
  }, ctx),
])

// 聚合结果
const summary = {
  tests: testsResult.output,
  docs: docsResult.output,
  types: typesResult.output,
}
```

**注意事项**:
- 确保任务之间没有依赖关系
- 监控并发数量，避免过载
- 处理部分失败的情况

### 4. 自定义命令触发子代理

**场景**: 创建便捷的命令来触发子代理。

**配置示例**:

```json
// .opencode/command/analyze.json
{
  "agent": "general",
  "description": "Analyze code complexity",
  "subtask": true,
  "template": "Analyze the code complexity of $1. Focus on:\n- Cyclomatic complexity\n- Code duplication\n- Maintainability index\n\nProvide specific recommendations for improvement."
}
```

**使用**:
```bash
/analyze src/app.ts
```

**效果**:
- 自动创建 SubtaskPart
- 直接执行 general 子代理
- 无需 LLM 推理

### 5. 监控子代理执行

**场景**: 实时监控子代理的工具调用。

**实现**:

```typescript
// 在 Task 工具中
const parts: Record<string, {...}> = {}

Bus.subscribe(MessageV2.Event.PartUpdated, async (evt) => {
  if (evt.properties.part.sessionID !== session.id) return
  if (evt.properties.part.type !== "tool") return

  const part = evt.properties.part
  console.log(`Tool executed: ${part.tool}`)
  console.log(`Status: ${part.state.status}`)

  if (part.state.status === "completed") {
    console.log(`Title: ${part.state.title}`)
  }

  // 更新 UI 或日志
  parts[part.id] = {
    id: part.id,
    tool: part.tool,
    state: part.state,
  }
})
```

### 6. 错误处理

**场景**: 子代理执行失败的处理。

**实现**:

```typescript
// 在 SessionPrompt.loop() 中
let executionError: Error | undefined
const result = await taskTool
  .execute(taskArgs, ctx)
  .catch((error) => {
    executionError = error
    log.error("subtask execution failed", {
      error,
      agent: task.agent,
      description: task.description
    })
    return undefined
  })

// 失败处理
if (!result) {
  await Session.updatePart({
    ...part,
    state: {
      status: "error",
      error: executionError
        ? `Tool execution failed: ${executionError.message}`
        : "Tool execution failed",
      time: {
        start: part.state.time.start,
        end: Date.now(),
      },
    },
  })

  // 可选：通知用户
  Bus.publish(Session.Event.Error, {
    sessionID,
    error: {
      message: `Subagent ${task.agent} failed: ${executionError?.message}`,
    },
  })
}

// 继续执行，不中断主循环
continue
```

### 7. 工具权限最小化

**场景**: 创建只读的分析子代理。

**配置**:

```typescript
// .opencode/agent/analyzer.json
{
  "mode": "subagent",
  "description": "Read-only code analyzer",
  "tools": {
    "read": true,
    "glob": true,
    "grep": true,
    "write": false,
    "edit": false,
    "bash": false,
    "webfetch": false
  },
  "permission": {
    "edit": "deny",
    "bash": {
      "*": "deny"
    }
  }
}
```

**好处**:
- 防止意外修改
- 提高安全性
- 明确代理能力边界

### 8. 调试子会话

**场景**: 调试子代理执行过程。

**技巧**:

1. **查看子会话 ID**:
```typescript
const result = await TaskTool.execute({...}, ctx)
console.log(`Subagent session: ${result.metadata.sessionId}`)
```

2. **读取子会话消息**:
```typescript
const messages = await Session.messages({
  sessionID: result.metadata.sessionId
})
console.log(JSON.stringify(messages, null, 2))
```

3. **查看工具调用摘要**:
```typescript
console.log("Tools called:", result.metadata.summary)
// [
//   { id: "...", tool: "glob", state: { status: "completed" } },
//   { id: "...", tool: "read", state: { status: "completed" } }
// ]
```

4. **在 UI 中导航**:
```
<Leader> + Right  # 进入子会话
<Leader> + Left   # 返回父会话
```

## 五、性能优化建议

### 1. 避免不必要的子代理调用

**问题**: 过度使用子代理导致性能下降。

**建议**:
- 简单任务直接在主代理中完成
- 只有复杂、多步骤的任务才使用子代理
- 考虑子代理的创建开销（新会话、新上下文）

### 2. 使用更小的模型

**场景**: 子代理执行简单任务。

**配置**:
```typescript
{
  "mode": "subagent",
  "model": "anthropic/claude-haiku-3.5",  // 使用 Haiku
  "description": "Fast file searcher"
}
```

**好处**:
- 更快的响应时间
- 更低的成本
- 适合简单任务

### 3. 批量操作

**场景**: 需要处理多个相似任务。

**不好的做法**:
```typescript
for (const file of files) {
  await TaskTool.execute({
    prompt: `Analyze ${file}`,
    subagent_type: "general"
  }, ctx)  // 串行执行
}
```

**好的做法**:
```typescript
// 并行执行
await Promise.all(
  files.map(file =>
    TaskTool.execute({
      prompt: `Analyze ${file}`,
      subagent_type: "general"
    }, ctx)
  )
)

// 或者在一次调用中处理所有文件
await TaskTool.execute({
  prompt: `Analyze the following files:\n${files.join('\n')}`,
  subagent_type: "general"
}, ctx)
```

### 4. 缓存子会话结果

**场景**: 相同的子任务重复执行。

**实现**:
```typescript
const cache = new Map<string, TaskResult>()

async function cachedTaskExecute(params, ctx) {
  const key = JSON.stringify(params)

  if (cache.has(key)) {
    return cache.get(key)
  }

  const result = await TaskTool.execute(params, ctx)
  cache.set(key, result)

  return result
}
```

### 5. 限制并发数

**场景**: 防止同时创建过多子会话。

**实现**:
```typescript
// 使用 p-limit 库
import pLimit from 'p-limit'

const limit = pLimit(3)  // 最多 3 个并发

const results = await Promise.all(
  tasks.map(task =>
    limit(() =>
      TaskTool.execute(task, ctx)
    )
  )
)
```

## 六、常见陷阱与解决方案

### 陷阱 1: 循环依赖

**问题**: 子代理试图调用 Task 工具。

**表现**:
```
general 子代理 → 调用 task 工具 → 创建 explore 子代理 → ...
```

**解决**:
```typescript
// task.ts 中强制禁用
tools: {
  task: false,  // 子代理无法调用
  ...
}
```

### 陷阱 2: 上下文污染

**问题**: 子会话影响父会话的上下文。

**解决**:
- 使用独立的子会话（`parentID` 机制）
- 通过返回值传递信息，不直接修改父会话

### 陷阱 3: 权限泄漏

**问题**: 子代理获得了不应有的权限。

**解决**:
```typescript
// 明确禁用危险工具
tools: {
  write: false,
  edit: false,
  bash: false,
  ...agent.tools,  // 最后合并，不会覆盖禁用
}
```

### 陷阱 4: 忘记取消订阅

**问题**: 事件订阅未清理，导致内存泄漏。

**解决**:
```typescript
const unsub = Bus.subscribe(...)

try {
  const result = await SessionPrompt.prompt(...)
  return result
} finally {
  unsub()  // 确保清理
}
```

### 陷阱 5: 子会话过深

**问题**: 通过 @提及 等方式间接创建多层嵌套。

**预防**:
- 限制调用深度
- 监控会话树深度
- 在配置中明确禁用某些代理的嵌套能力

## 七、总结

OpenCode 的子代理系统是一个精心设计的多代理协作架构，核心优势包括：

### 设计优势

1. **灵活的调用方式**: 命令触发、LLM 调用、@提及，满足不同场景
2. **严格的隔离机制**: 通过子会话实现上下文和权限隔离
3. **统一的执行路径**: 所有调用方式共享 TaskTool，确保一致性
4. **可扩展性**: 支持用户自定义代理和命令
5. **安全性**: 最小权限原则，防止递归和权限泄漏

### 关键特性

1. **会话树**: 通过 `parentID` 建立父子关系
2. **工具权限控制**: 细粒度的工具访问控制
3. **实时元数据更新**: 通过事件总线同步子会话进度
4. **会话复用**: 支持多轮对话
5. **并行执行**: 多个子会话可以同时运行

### 适用场景

- ✅ 复杂的多步骤任务
- ✅ 需要专门能力的任务（探索、审查等）
- ✅ 需要隔离上下文的任务
- ✅ 需要并行执行的任务
- ❌ 简单的单步操作
- ❌ 需要频繁交互的任务

### 未来改进方向

1. **动态权限**: 运行时调整子代理权限
2. **会话合并**: 将多个子会话的结果合并到父会话
3. **智能调度**: 根据负载自动调整并发数
4. **成本优化**: 自动选择最合适的模型
5. **可视化**: 更好的会话树可视化和调试工具

这个系统为构建复杂的 AI 代理应用提供了坚实的基础，值得深入学习和实践。
