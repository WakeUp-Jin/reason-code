# 会话隔离与子会话机制

## 概述

会话隔离是 OpenCode 子代理系统的核心设计之一。通过创建独立的子会话，系统实现了上下文隔离、权限控制和任务追溯等功能。

## 一、会话（Session）基础

### Session 数据结构

```typescript
// packages/opencode/src/session/index.ts
export interface Session {
  id: string           // 会话唯一标识
  parentID?: string    // 父会话 ID（关键字段）
  title: string        // 会话标题
  time: {
    created: number    // 创建时间
    updated: number    // 更新时间
  }
  revert?: {           // 回滚信息
    // ...
  }
}
```

### 核心字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | `string` | 会话的唯一标识，使用 Identifier 生成 |
| `parentID` | `string?` | 父会话 ID，**子会话的关键** |
| `title` | `string` | 会话标题，子会话标题包含代理名称 |
| `time` | `object` | 时间信息 |

## 二、子会话的创建

### Task 工具中的创建逻辑

```typescript
// packages/opencode/src/tool/task.ts:34-44
const session = await iife(async () => {
  // 尝试复用现有会话
  if (params.session_id) {
    const found = await Session.get(params.session_id).catch(() => {})
    if (found) return found
  }

  // 创建新的子会话
  return await Session.create({
    parentID: ctx.sessionID,  // 关键：指向父会话
    title: params.description + ` (@${agent.name} subagent)`,
  })
})
```

### 关键点

1. **parentID 设置**: `parentID: ctx.sessionID`
   - `ctx.sessionID` 是当前（父）会话的 ID
   - 通过 `parentID` 建立父子关系

2. **标题格式**: `description + " (@agent_name subagent)"`
   - 示例：`"Explore codebase (@explore subagent)"`
   - 便于在 UI 中识别子会话

3. **会话复用**: 支持通过 `session_id` 参数复用现有子会话
   - 实现多轮对话
   - 保持子代理的上下文连续性

### Session.create() 实现

```typescript
// packages/opencode/src/session/index.ts
export async function create(input: {
  parentID?: string
  title?: string
}): Promise<Session> {
  const session: Session = {
    id: Identifier.ascending("session"),
    parentID: input.parentID,
    title: input.title ?? defaultTitle(),
    time: {
      created: Date.now(),
      updated: Date.now(),
    },
  }

  await db.insert(session)
  Bus.publish(Session.Event.Created, { session })

  return session
}
```

## 三、会话树结构

### 层级关系

```
┌─────────────────────────────────────┐
│ ParentSession (主会话)               │
│ id: "session_01HXJ..."              │
│ parentID: undefined                 │
│ agent: "build"                      │
│ title: "Implement user auth"        │
├─────────────────────────────────────┤
│ Messages:                           │
│   - User: "Implement user auth"     │
│   - Assistant: (调用 Task 工具)      │
│   - User: (合成消息)                 │
│   - Assistant: (继续处理)            │
└─────────────────┬───────────────────┘
                  │
                  │ parentID
                  │
        ┌─────────┴──────────┬─────────────────────┐
        │                    │                     │
        ▼                    ▼                     ▼
┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
│ ChildSession 1   │  │ ChildSession 2   │  │ ChildSession 3   │
│ id: "session_... "│  │ id: "session_..."│  │ id: "session_..."│
│ parentID: ↑      │  │ parentID: ↑      │  │ parentID: ↑      │
│ agent: "explore" │  │ agent: "general" │  │ agent: "explore" │
│ title: "Find..." │  │ title: "Review.."│  │ title: "Search.."│
├──────────────────┤  ├──────────────────┤  ├──────────────────┤
│ Messages:        │  │ Messages:        │  │ Messages:        │
│   - User: ...    │  │   - User: ...    │  │   - User: ...    │
│   - Assistant:.. │  │   - Assistant:.. │  │   - Assistant:.. │
└──────────────────┘  └──────────────────┘  └──────────────────┘
```

### 特征

1. **独立的消息队列**: 每个子会话有独立的消息列表
2. **隔离的上下文**: 子会话不会污染父会话的上下文
3. **可追溯**: 通过 `parentID` 可以追溯到父会话
4. **并行执行**: 多个子会话可以同时存在和执行

## 四、上下文隔离

### 消息隔离

每个会话维护独立的消息列表：

```typescript
// packages/opencode/src/session/index.ts
export async function messages(input: {
  sessionID: string
}): Promise<MessageV2.WithParts[]> {
  // 只查询当前 sessionID 的消息
  const msgs = await db
    .select()
    .from(messageTable)
    .where(eq(messageTable.sessionID, input.sessionID))
    .orderBy(asc(messageTable.id))

  // 获取每条消息的 parts
  const parts = await db
    .select()
    .from(partTable)
    .where(eq(partTable.sessionID, input.sessionID))

  return msgs.map((msg) => ({
    info: msg,
    parts: parts.filter((p) => p.messageID === msg.id),
  }))
}
```

**结果**: 子会话只能看到自己的消息，无法访问父会话或兄弟会话的消息。

### 工具权限隔离

子会话在执行时使用受限的工具集：

```typescript
// packages/opencode/src/tool/task.ts:100-106
tools: {
  todowrite: false,  // 禁用
  todoread: false,   // 禁用
  task: false,       // 禁用（防止递归）
  ...Object.fromEntries(
    (config.experimental?.primary_tools ?? []).map((t) => [t, false])
  ),
  ...agent.tools,    // 子代理的工具配置
}
```

**效果**:
- 子会话不能修改主会话的 TodoList
- 子会话不能嵌套调用 Task 工具
- 子会话只能使用被允许的工具

### 代理状态隔离

每个会话有独立的代理状态：

```typescript
// packages/opencode/src/session/prompt.ts:482-510
const processor = SessionProcessor.create({
  assistantMessage: (await Session.updateMessage({
    id: Identifier.ascending("message"),
    role: "assistant",
    mode: agent.name,
    agent: agent.name,  // 子会话使用子代理
    sessionID: sessionID,  // 子会话 ID
    ...
  })) as MessageV2.Assistant,
  sessionID: sessionID,
  model,
  abort,
})
```

父会话和子会话可以使用不同的代理，互不影响。

## 五、会话的生命周期

### 创建

```typescript
// Task 工具调用时
const session = await Session.create({
  parentID: ctx.sessionID,
  title: params.description + ` (@${agent.name} subagent)`,
})

// 发布事件
Bus.publish(Session.Event.Created, { session })
```

### 执行

```typescript
// 在子会话中执行子代理
const result = await SessionPrompt.prompt({
  sessionID: session.id,  // 子会话 ID
  agent: agent.name,      // 子代理名称
  tools,                  // 受限的工具集
  parts: promptParts,
})
```

### 完成

子会话执行完成后，会话对象仍然保留在数据库中，可以：
- 通过 `session_id` 参数复用
- 在 UI 中查看历史
- 通过 `parentID` 追溯父会话

### 清理

会话不会自动删除，需要手动清理或通过配置设置过期策略。

## 六、会话间通信

### 父会话 → 子会话

**通过 Task 工具参数传递**:

```typescript
// 父会话调用 Task
{
  "tool": "task",
  "arguments": {
    "prompt": "Find all test files in src/",  // 传递给子会话
    "subagent_type": "explore"
  }
}
```

子会话收到的消息：
```typescript
// 子会话的第一条消息
{
  info: {
    role: "user",
    sessionID: "session_child...",
    agent: "explore"
  },
  parts: [
    {
      type: "text",
      text: "Find all test files in src/"  // 来自父会话的 prompt
    }
  ]
}
```

### 子会话 → 父会话

**通过 Task 工具返回值传递**:

```typescript
// 子会话执行完成后返回
{
  title: "Find test files",
  metadata: {
    summary: [...],  // 子会话的工具调用摘要
    sessionId: "session_child..."
  },
  output: "I found 15 test files..."  // 子会话的输出
}
```

父会话收到的 Tool Part：
```typescript
{
  type: "tool",
  tool: "task",
  state: {
    status: "completed",
    output: "I found 15 test files...",
    metadata: {
      summary: [...],
      sessionId: "session_child..."
    }
  }
}
```

### 实时状态更新

通过事件总线（Bus）实现实时通信：

```typescript
// packages/opencode/src/tool/task.ts:57-77
Bus.subscribe(MessageV2.Event.PartUpdated, async (evt) => {
  // 过滤子会话的事件
  if (evt.properties.part.sessionID !== session.id) return

  // 收集工具调用信息
  parts[part.id] = { ... }

  // 更新到父会话的元数据
  ctx.metadata({
    title: params.description,
    metadata: {
      summary: Object.values(parts),
      sessionId: session.id,
    },
  })
})
```

**流程**:
```
子会话执行工具 → 发布 PartUpdated 事件
    ↓
Task 工具订阅事件 → 过滤子会话的事件
    ↓
收集工具信息 → 调用 ctx.metadata()
    ↓
更新父会话的 Tool Part 元数据
    ↓
UI 实时显示子会话进度
```

## 七、会话导航

### UI 导航

在 TUI 中，用户可以在会话树中导航：

- `<Leader> + Right`: 进入子会话
- `<Leader> + Left`: 返回父会话
- 会话列表显示父子关系

### 代码实现

```typescript
// packages/opencode/src/cli/cmd/tui/routes/session/session.tsx
// 获取当前会话的子会话列表
const childSessions = sessions.filter(
  (s) => s.parentID === currentSession.id
)

// 获取父会话
const parentSession = currentSession.parentID
  ? sessions.find((s) => s.id === currentSession.parentID)
  : undefined
```

## 八、会话复用

### 为什么需要会话复用

实现子代理的**多轮对话**：

```typescript
// 第一轮：查找文件
const result1 = await task({
  description: "Find tests",
  prompt: "Find all test files",
  subagent_type: "explore"
})
// result1.metadata.sessionId = "session_child_001"

// 第二轮：分析文件（复用会话）
const result2 = await task({
  description: "Analyze tests",
  prompt: "Analyze the test files you found earlier",
  subagent_type: "explore",
  session_id: result1.metadata.sessionId  // 复用会话
})
```

### 复用逻辑

```typescript
// packages/opencode/src/tool/task.ts:34-44
const session = await iife(async () => {
  // 如果提供了 session_id，尝试复用
  if (params.session_id) {
    const found = await Session.get(params.session_id).catch(() => {})
    if (found) return found  // 复用现有会话
  }

  // 否则创建新会话
  return await Session.create({
    parentID: ctx.sessionID,
    title: params.description + ` (@${agent.name} subagent)`,
  })
})
```

### 复用的效果

复用会话后，子代理可以看到之前的对话历史：

```typescript
// 第一轮执行后，子会话的消息
[
  { role: "user", text: "Find all test files" },
  { role: "assistant", text: "I found 15 test files..." }
]

// 第二轮复用会话，子会话的消息
[
  { role: "user", text: "Find all test files" },
  { role: "assistant", text: "I found 15 test files..." },
  { role: "user", text: "Analyze the test files you found earlier" },  // 新增
  { role: "assistant", text: "..." }  // 新增
]
```

## 九、会话隔离的好处

### 1. 上下文管理

**问题**: 主会话的上下文可能非常长，包含大量不相关的信息。

**解决**: 子会话从空白开始，只包含任务相关的上下文。

**效果**:
- 减少 token 消耗
- 提高响应速度
- 避免上下文混淆

### 2. 权限控制

**问题**: 子代理可能需要受限的权限。

**解决**: 子会话可以配置独立的工具集和权限。

**效果**:
- 防止子代理越权操作
- 防止无限递归（禁用 Task 工具）
- 保护主会话状态（禁用 TodoList 工具）

### 3. 并行执行

**问题**: 需要同时执行多个子任务。

**解决**: 创建多个独立的子会话。

**效果**:
```typescript
// 并行执行多个子代理
await Promise.all([
  task({ prompt: "Find tests", subagent_type: "explore" }),
  task({ prompt: "Review code", subagent_type: "general" }),
  task({ prompt: "Search docs", subagent_type: "explore" }),
])
```

### 4. 任务追溯

**问题**: 需要查看子任务的执行历史。

**解决**: 通过 `parentID` 追溯父会话，通过 `sessionId` 查看子会话。

**效果**:
- 调试时可以查看完整的执行路径
- UI 可以显示会话树
- 日志可以关联父子会话

### 5. 失败隔离

**问题**: 子任务失败可能影响主任务。

**解决**: 子会话失败不会中断父会话。

**效果**:
```typescript
// 子会话执行失败
.catch((error) => {
  executionError = error
  return undefined  // 返回 undefined，不抛出异常
})

// 父会话继续执行
if (!result) {
  await Session.updatePart({
    state: {
      status: "error",
      error: "Tool execution failed",
      ...
    },
  })
}
// 继续主循环
```

## 十、会话元数据

### Tool Part 的元数据

Task 工具执行期间，父会话的 Tool Part 会实时更新元数据：

```typescript
{
  type: "tool",
  tool: "task",
  state: {
    status: "running",
    metadata: {
      summary: [
        {
          id: "part_01HXK...",
          tool: "glob",
          state: { status: "completed", title: "Find files" }
        },
        {
          id: "part_01HXL...",
          tool: "read",
          state: { status: "running" }
        }
      ],
      sessionId: "session_child_001"
    }
  }
}
```

### 元数据的用途

1. **UI 显示**: 显示子代理正在执行的工具
2. **进度追踪**: 实时了解子任务进度
3. **调试**: 分析子会话的工具调用链
4. **会话复用**: 获取 `sessionId` 用于后续调用

## 十一、会话隔离的限制

### 1. 不能直接访问父会话数据

子会话无法直接读取父会话的消息或状态。

**解决方案**: 通过 Task 工具的 `prompt` 参数传递必要信息。

### 2. 不能修改父会话状态

子会话不能修改父会话的 TodoList、消息等。

**解决方案**: 通过返回值传递信息，由父会话处理。

### 3. 事件订阅的开销

Task 工具需要订阅事件来实时更新元数据。

**优化**: 通过严格的事件过滤减少不必要的处理。

## 十二、关键文件位置

| 功能 | 文件路径 | 行号 |
|------|---------|------|
| Session 定义 | `packages/opencode/src/session/index.ts` | - |
| 子会话创建 | `packages/opencode/src/tool/task.ts` | 34-44 |
| 消息查询 | `packages/opencode/src/session/index.ts` | `messages()` |
| 事件订阅 | `packages/opencode/src/tool/task.ts` | 57-77 |
| 会话复用 | `packages/opencode/src/tool/task.ts` | 35-38 |

## 十三、总结

会话隔离机制是 OpenCode 子代理系统的基石，通过 `parentID` 字段建立会话树，实现了：

1. **上下文隔离**: 子会话独立的消息队列和上下文
2. **权限控制**: 子会话受限的工具访问权限
3. **并行执行**: 多个子会话可以同时运行
4. **任务追溯**: 通过 `parentID` 和 `sessionId` 追溯执行路径
5. **失败隔离**: 子会话失败不影响父会话
6. **会话复用**: 支持多轮对话和上下文保持

这种设计既保证了安全性，又提供了灵活性，是一个优雅的多代理协作架构。
