# OpenCode 子代理核心架构分析

## 一、Agent 类型系统

### 1.1 三种 Agent 模式

```typescript
// packages/opencode/src/agent/agent.ts
export const Info = z.object({
  name: z.string(),
  mode: z.enum(["subagent", "primary", "all"]),
  // ...
})
```

**模式说明：**
- **`primary`**: 主代理，用户可直接切换（如 `build`, `plan`）
- **`subagent`**: 子代理，只能被其他代理调用（如 `general`, `explore`）
- **`all`**: 可同时作为主代理和子代理

### 1.2 内置子代理配置

```typescript
const result: Record<string, Info> = {
  // 主代理
  build: {
    name: "build",
    mode: "primary",
    tools: { ...defaultTools },
    permission: agentPermission,
  },
  
  // 子代理 1: 通用任务处理
  general: {
    name: "general",
    description: "General-purpose agent for researching complex questions...",
    mode: "subagent",
    hidden: true,  // 不在 UI 显示
    tools: {
      todoread: false,
      todowrite: false,
      ...defaultTools,
    },
  },
  
  // 子代理 2: 代码库探索
  explore: {
    name: "explore",
    description: "Fast agent specialized for exploring codebases...",
    mode: "subagent",
    tools: {
      todoread: false,
      todowrite: false,
      edit: false,
      write: false,
      ...defaultTools,
    },
  },
}
```

**关键特性：**
- 子代理有独立的工具配置
- 可以禁用特定工具（如 `todowrite: false`）
- 支持 `hidden` 属性隐藏内部子代理

---

## 二、Task Tool - 子代理调用机制

### 2.1 工具定义

```typescript
// packages/opencode/src/tool/task.ts
export const TaskTool = Tool.define("task", async () => {
  // 1. 过滤可用子代理（排除 primary）
  const agents = await Agent.list().then(x => 
    x.filter(a => a.mode !== "primary")
  )
  
  // 2. 动态生成工具描述
  const description = DESCRIPTION.replace(
    "{agents}",
    agents.map(a => 
      `- ${a.name}: ${a.description ?? "..."}`
    ).join("\n")
  )
  
  return {
    description,
    parameters: z.object({
      description: z.string(),
      prompt: z.string(),
      subagent_type: z.string(),
      session_id: z.string().optional(),
    }),
    async execute(params, ctx) {
      // 执行逻辑...
    }
  }
})
```

### 2.2 执行流程

```typescript
async execute(params, ctx) {
  // 1. 获取子代理配置
  const agent = await Agent.get(params.subagent_type)
  
  // 2. 创建或复用子会话
  const session = await iife(async () => {
    if (params.session_id) {
      const found = await Session.get(params.session_id).catch(() => {})
      if (found) return found
    }
    
    return await Session.create({
      parentID: ctx.sessionID,  // 关联父会话
      title: params.description + ` (@${agent.name} subagent)`
    })
  })
  
  // 3. 订阅子会话事件（实时追踪）
  const unsub = Bus.subscribe(MessageV2.Event.PartUpdated, async (evt) => {
    if (evt.properties.part.sessionID !== session.id) return
    if (evt.properties.part.type !== "tool") return
    
    // 更新元数据
    ctx.metadata({
      title: params.description,
      metadata: {
        summary: Object.values(parts),
        sessionId: session.id
      }
    })
  })
  
  // 4. 调用子代理
  const result = await SessionPrompt.prompt({
    sessionID: session.id,
    model: agent.model ?? parentModel,
    agent: agent.name,
    tools: {
      todowrite: false,
      todoread: false,
      task: false,  // 禁止递归调用
      ...agent.tools
    },
    parts: promptParts
  })
  
  // 5. 返回结果
  return {
    title: params.description,
    metadata: {
      summary,
      sessionId: session.id
    },
    output: text + "\n\n<task_metadata>..."
  }
}
```

---

## 三、Session 层级结构

### 3.1 父子会话模型

```typescript
// packages/opencode/src/session/index.ts
export const Info = z.object({
  id: Identifier.schema("session"),
  parentID: Identifier.schema("session").optional(),  // 子会话指向父会话
  title: z.string(),
  // ...
})

// 创建子会话
export async function createNext(input: {
  parentID?: string,  // 如果有 parentID，就是子会话
  directory: string,
  title?: string
}) {
  const result: Info = {
    id: Identifier.descending("session"),
    parentID: input.parentID,
    title: input.title ?? createDefaultTitle(!!input.parentID),
    time: {
      created: Date.now(),
      updated: Date.now()
    }
  }
  
  await Storage.write(["session", Instance.project.id, result.id], result)
  Bus.publish(Event.Created, { info: result })
  
  return result
}
```

### 3.2 会话查询

```typescript
// 获取子会话列表
export const children = fn(
  Identifier.schema("session"), 
  async (parentID) => {
    const result = [] as Session.Info[]
    for (const item of await Storage.list(["session", project.id])) {
      const session = await Storage.read<Info>(item)
      if (session.parentID !== parentID) continue
      result.push(session)
    }
    return result
  }
)
```

---

## 四、权限和工具隔离

### 4.1 权限配置

```typescript
// 主代理权限（完全访问）
const agentPermission: Info["permission"] = {
  edit: "allow",
  bash: { "*": "allow" },
  skill: { "*": "allow" },
  webfetch: "allow",
}

// plan 代理权限（只读）
const planPermission = {
  edit: "deny",
  bash: {
    "ls*": "allow",
    "grep*": "allow",
    "git diff*": "allow",
    "*": "ask"  // 其他命令需要询问
  },
  webfetch: "allow",
}
```

### 4.2 工具隔离

```typescript
// 子代理调用时的工具限制
tools: {
  todowrite: false,  // 禁用 todo 写入
  todoread: false,
  task: false,       // 禁止递归调用（关键！）
  ...agent.tools     // 合并代理自己的工具配置
}
```

---

## 五、事件驱动追踪

### 5.1 实时进度追踪

```typescript
// 订阅子会话的工具调用事件
const parts: Record<string, ToolPart> = {}

const unsub = Bus.subscribe(MessageV2.Event.PartUpdated, async (evt) => {
  if (evt.properties.part.sessionID !== session.id) return
  if (evt.properties.part.type !== "tool") return
  
  const part = evt.properties.part
  parts[part.id] = {
    id: part.id,
    tool: part.tool,
    state: {
      status: part.state.status,
      title: part.state.status === "completed" ? part.state.title : undefined
    }
  }
  
  // 更新父代理的元数据
  ctx.metadata({
    title: params.description,
    metadata: {
      summary: Object.values(parts).sort((a, b) => 
        a.id.localeCompare(b.id)
      ),
      sessionId: session.id
    }
  })
})
```

### 5.2 取消机制

```typescript
// 支持中断子代理执行
function cancel() {
  SessionPrompt.cancel(session.id)
}

ctx.abort.addEventListener("abort", cancel)

using _ = defer(() => 
  ctx.abort.removeEventListener("abort", cancel)
)
```

---

## 六、核心优势

### 6.1 清晰的层级关系
- 父会话 → 子会话，通过 `parentID` 关联
- 每个子代理有独立的 `sessionID`
- 支持会话复用（通过 `session_id` 参数）

### 6.2 工具隔离
- 子代理有独立的工具集
- 禁止 `task` 工具防止递归调用
- 可以精细控制每个工具的可用性

### 6.3 权限控制
- 每个代理有独立的权限配置
- 支持 `allow`、`deny`、`ask` 三种模式
- 可以针对不同命令模式设置权限

### 6.4 事件驱动
- 通过 Bus 系统实时追踪子代理执行状态
- 父代理可以获取子代理的工具调用详情
- 支持中断和取消操作

### 6.5 会话复用
- 支持通过 `session_id` 继续之前的子代理会话
- 适合多轮对话场景
- 保持上下文连续性

---

## 七、关键设计模式

### 7.1 依赖注入
```typescript
// 子代理执行时注入父代理的模型配置
const model = agent.model ?? {
  modelID: msg.info.modelID,
  providerID: msg.info.providerID
}
```

### 7.2 事件总线
```typescript
// 使用 Bus 系统解耦父子代理通信
Bus.subscribe(MessageV2.Event.PartUpdated, handler)
Bus.publish(Event.Created, { info: result })
```

### 7.3 资源清理
```typescript
// 使用 using 语法自动清理资源
using _ = defer(() => 
  ctx.abort.removeEventListener("abort", cancel)
)
```

### 7.4 策略模式
```typescript
// 不同代理有不同的工具和权限策略
const agents: Record<string, Info> = {
  build: { /* 完全访问 */ },
  plan: { /* 只读访问 */ },
  explore: { /* 探索专用 */ },
}
```
