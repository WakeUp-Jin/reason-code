# OpenCode 自定义子代理与会话分离设计

## 一、自定义子代理支持

### 1.1 是的，OpenCode 完全支持自定义子代理！

OpenCode 通过 **配置文件** 的方式支持用户创建自定义子代理，非常灵活。

### 1.2 创建方式

#### 方式一：Markdown 配置文件

在项目的 `.opencode/agent/` 目录下创建 `.md` 文件：

```markdown
<!-- .opencode/agent/my-custom-agent.md -->
---
mode: subagent
description: My custom agent for specific tasks
tools:
  write: false
  edit: false
---

You are a specialized agent for analyzing code quality.
Focus on finding potential bugs and suggesting improvements.
```

#### 方式二：JSON 配置文件

在 `opencode.json` 或 `opencode.jsonc` 中配置：

```json
{
  "agent": {
    "my-custom-agent": {
      "mode": "subagent",
      "description": "My custom agent for specific tasks",
      "prompt": "You are a specialized agent...",
      "tools": {
        "write": false,
        "edit": false
      },
      "model": {
        "providerID": "anthropic",
        "modelID": "claude-3-5-sonnet-20241022"
      }
    }
  }
}
```

### 1.3 配置加载机制

```typescript
// packages/opencode/src/config/config.ts

// 1. 扫描 agent/**/*.md 文件
const AGENT_GLOB = new Bun.Glob("agent/**/*.md")

async function loadAgent(dir: string) {
  const result: Record<string, Agent> = {}
  
  for await (const item of AGENT_GLOB.scan({ cwd: dir })) {
    // 解析 Markdown 文件
    const md = await ConfigMarkdown.parse(item)
    
    // 提取 frontmatter 和内容
    const config = {
      name: agentName,
      ...md.data,        // frontmatter 数据
      prompt: md.content  // markdown 内容作为系统提示词
    }
    
    result[config.name] = config
  }
  return result
}

// 2. 合并到全局配置
result.agent = mergeDeep(result.agent, await loadAgent(dir))
```

### 1.4 动态注册到 Task 工具

```typescript
// packages/opencode/src/agent/agent.ts

// 从配置文件加载自定义代理
for (const [key, value] of Object.entries(cfg.agent ?? {})) {
  let item = result[key]
  if (!item) {
    // 创建新的代理配置
    item = result[key] = {
      name: key,
      mode: "all",  // 默认模式
      permission: agentPermission,
      options: {},
      tools: {},
      native: false,  // 标记为非内置代理
    }
  }
  
  // 应用用户配置
  if (value.mode) item.mode = value.mode
  if (value.prompt) item.prompt = value.prompt
  if (value.tools) item.tools = { ...item.tools, ...value.tools }
  // ...
}
```

### 1.5 自动出现在 Task 工具中

```typescript
// packages/opencode/src/tool/task.ts

export const TaskTool = Tool.define("task", async () => {
  // 自动获取所有子代理（包括自定义的）
  const agents = await Agent.list().then(x => 
    x.filter(a => a.mode !== "primary")
  )
  
  // 动态生成工具描述
  const description = DESCRIPTION.replace(
    "{agents}",
    agents.map(a => 
      `- ${a.name}: ${a.description ?? "..."}`
    ).join("\n")
  )
  
  // 自定义代理会自动出现在可选列表中
  return {
    description,
    parameters: z.object({
      subagent_type: z.string().describe("Type of agent to use")
    })
  }
})
```

---

## 二、为什么要分离主会话和子会话？

### 2.1 核心原因：隔离和追踪

#### 原因 1: **上下文隔离**

```typescript
// 主会话
Session {
  id: "session_main_123",
  messages: [
    { role: "user", content: "帮我分析这个项目" },
    { role: "assistant", content: "我会调用 explore 代理..." },
    // 主代理的对话历史
  ]
}

// 子会话（独立的上下文）
Session {
  id: "session_sub_456",
  parentID: "session_main_123",  // 关联父会话
  messages: [
    { role: "user", content: "Find all API endpoints..." },
    { role: "assistant", content: "I found 15 endpoints..." },
    // 子代理的对话历史（不污染主会话）
  ]
}
```

**好处：**
- 子代理的长对话不会占用主代理的上下文窗口
- 每个子代理有独立的思考空间
- 主代理只需要知道子代理的最终结果

#### 原因 2: **并行执行**

```typescript
// 主代理可以同时启动多个子代理
const toolCalls = [
  {
    name: 'task',
    parameters: {
      subagent_type: 'explore',
      prompt: 'Analyze frontend structure'
    }
  },
  {
    name: 'task',
    parameters: {
      subagent_type: 'explore',
      prompt: 'Analyze backend API'
    }
  }
]

// 每个子代理在独立的会话中并行执行
// session_sub_001: 分析前端
// session_sub_002: 分析后端
// 互不干扰，可以同时进行
```

**好处：**
- 提高执行效率
- 避免会话冲突
- 每个子任务有独立的进度追踪

#### 原因 3: **会话复用**

```typescript
// 第一次调用
const result1 = await task({
  subagent_type: 'explore',
  prompt: 'Find all React components'
})
// 返回: { sessionId: 'session_sub_789', output: '...' }

// 第二次调用，继续之前的会话
const result2 = await task({
  subagent_type: 'explore',
  session_id: 'session_sub_789',  // 复用！
  prompt: 'Now analyze their props'
})
```

**好处：**
- 子代理可以保持上下文连续性
- 支持多轮对话
- 避免重复传递信息

#### 原因 4: **清晰的层级关系**

```
主会话 (session_main)
├── 子会话 1 (explore 代理)
│   └── 工具调用: read_file, grep, ls
├── 子会话 2 (general 代理)
│   └── 工具调用: web_search, read_file
└── 子会话 3 (explore 代理 - 复用)
    └── 工具调用: grep, read_file
```

**好处：**
- 清晰的执行树结构
- 方便调试和追踪
- 可以查看每个子任务的详细执行过程

#### 原因 5: **资源管理**

```typescript
// 子会话可以独立清理
async function cleanup(sessionId: string) {
  const children = await Session.children(sessionId)
  
  // 清理所有子会话
  for (const child of children) {
    await Session.remove(child.id)
  }
  
  // 清理主会话
  await Session.remove(sessionId)
}
```

**好处：**
- 可以单独删除子会话
- 避免内存泄漏
- 灵活的生命周期管理

### 2.2 实际场景示例

#### 场景 1: 复杂任务分解

```
用户: "帮我重构这个项目的认证系统"

主代理思考:
1. 需要分析现有代码
2. 需要设计新方案
3. 需要实现代码

主代理执行:
├── 调用 explore 代理 (子会话 1)
│   └── 分析现有认证代码
├── 调用 general 代理 (子会话 2)
│   └── 研究最佳实践
└── 主代理自己实现代码
    └── 基于子代理的分析结果
```

#### 场景 2: 并行信息收集

```
用户: "对比分析 React 和 Vue 的状态管理"

主代理执行:
├── 子会话 1: 研究 React 状态管理
└── 子会话 2: 研究 Vue 状态管理
    (同时进行，互不干扰)

主代理汇总:
└── 基于两个子会话的结果生成对比报告
```

### 2.3 技术实现细节

```typescript
// 创建子会话时的关键代码
const session = await Session.create({
  parentID: ctx.sessionID,  // 关键：关联父会话
  title: `${description} (@${agent.name})`
})

// 查询子会话
const children = await Session.children(parentID)

// 会话数据结构
interface Session {
  id: string
  parentID?: string  // 如果有值，就是子会话
  title: string
  messages: Message[]
  createdAt: number
  updatedAt: number
}
```

---

## 三、设计优势总结

### 3.1 对比单一会话模式

| 特性 | 单一会话 | 父子会话 |
|------|---------|---------|
| **上下文管理** | 混乱，所有对话在一起 | 清晰，分层隔离 |
| **并行执行** | 困难，容易冲突 | 简单，天然支持 |
| **会话复用** | 不支持 | 支持 |
| **调试追踪** | 困难 | 清晰的执行树 |
| **资源清理** | 全部或全不 | 灵活的粒度 |

### 3.2 类似的设计模式

这种设计类似于：
- **进程和子进程**: 父进程可以 fork 子进程
- **函数调用栈**: 主函数调用子函数
- **任务队列**: 主任务分解为子任务

### 3.3 Reason-Code 的适配建议

```typescript
// 简化版的会话管理
interface Session {
  id: string
  parentId?: string  // 可选的父会话 ID
  agentName: string  // 哪个代理创建的
  messages: Message[]
  metadata: {
    createdAt: number
    duration?: number
  }
}

class SessionManager {
  // 创建子会话
  async createChild(parentId: string, agentName: string) {
    return this.create({
      parentId,
      agentName,
      title: `Subtask (@${agentName})`
    })
  }
  
  // 查询子会话
  async getChildren(parentId: string) {
    return this.sessions.filter(s => s.parentId === parentId)
  }
  
  // 清理会话树
  async removeTree(sessionId: string) {
    const children = await this.getChildren(sessionId)
    for (const child of children) {
      await this.removeTree(child.id)  // 递归清理
    }
    await this.remove(sessionId)
  }
}
```

---

## 四、关键要点

### ✅ 自定义子代理
- 通过 `.opencode/agent/*.md` 文件配置
- 或在 `opencode.json` 中配置
- 自动注册到 Task 工具
- 支持自定义工具集、模型、提示词

### ✅ 会话分离的原因
1. **上下文隔离**: 子代理不污染主会话
2. **并行执行**: 多个子代理同时工作
3. **会话复用**: 支持多轮对话
4. **清晰层级**: 便于调试和追踪
5. **资源管理**: 灵活的清理策略

### ✅ 实现建议
- 保持简单的父子关系（parentId）
- 支持查询子会话列表
- 实现递归清理机制
- 考虑会话持久化（文件系统）

---

## 五、示例：完整的自定义子代理

```markdown
<!-- .opencode/agent/code-reviewer.md -->
---
mode: subagent
description: Specialized agent for code review and quality analysis
tools:
  write: false
  edit: false
  bash: false
model:
  providerID: anthropic
  modelID: claude-3-5-sonnet-20241022
---

You are a code review specialist. Your role is to:

1. Analyze code for potential bugs and issues
2. Check for security vulnerabilities
3. Suggest performance improvements
4. Verify code style and best practices

When reviewing code:
- Be constructive and specific
- Provide examples of improvements
- Prioritize critical issues
- Consider maintainability

Always structure your review with:
- Summary of findings
- Critical issues (if any)
- Suggestions for improvement
- Positive aspects of the code
```

使用：
```typescript
// 主代理会自动看到这个子代理
const result = await task({
  subagent_type: 'code-reviewer',
  description: 'Review authentication code',
  prompt: 'Review the files in src/auth/ for security issues'
})
```

这就是 OpenCode 的子代理系统设计！简洁、灵活、强大。
