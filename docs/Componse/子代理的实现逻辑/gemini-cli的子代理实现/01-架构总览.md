# Gemini CLI 子代理架构总览

## 概述

Gemini CLI 的子代理（Subagent）系统是一个强大的架构设计，允许主 AI 代理将复杂任务委托给专门的子代理执行。这种设计实现了任务的模块化、专业化和并行处理。

## 核心架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        主代理 (Main Agent)                    │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              工具注册表 (Tool Registry)              │   │
│  │                                                       │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌───────────┐ │   │
│  │  │ 标准工具      │  │ MCP 工具     │  │ 子代理工具 │ │   │
│  │  │ (read_file)  │  │ (custom)     │  │ (wrapped)  │ │   │
│  │  └──────────────┘  └──────────────┘  └───────────┘ │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ 调用子代理工具
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   SubagentToolWrapper                         │
│                   (工具包装器)                                 │
│                                                               │
│  • 将 AgentDefinition 包装成标准工具                          │
│  • 动态生成参数 Schema                                        │
│  • 创建 SubagentInvocation                                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ 创建调用实例
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   SubagentInvocation                          │
│                   (调用实例)                                   │
│                                                               │
│  • 管理单次执行的生命周期                                      │
│  • 桥接活动事件到输出流                                        │
│  • 格式化最终结果                                             │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ 创建执行器
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    AgentExecutor                              │
│                    (执行引擎)                                  │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              执行循环 (Execution Loop)               │   │
│  │                                                       │   │
│  │  1. 检查终止条件 (超时/最大轮次)                      │   │
│  │  2. 调用 Gemini 模型                                 │   │
│  │  3. 处理工具调用                                      │   │
│  │  4. 检查 complete_task                               │   │
│  │  5. 返回结果或继续循环                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │          隔离的工具注册表 (Isolated Registry)         │   │
│  │                                                       │   │
│  │  • 只包含授权的工具                                   │   │
│  │  • 独立于主代理的工具集                               │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

## 核心组件

### 1. AgentDefinition（代理定义）
- **位置**：`packages/core/src/agents/types.ts`
- **作用**：声明式配置子代理的所有行为
- **包含**：提示、模型参数、工具集、输入输出定义

### 2. AgentRegistry（代理注册表）
- **位置**：`packages/core/src/agents/registry.ts`
- **作用**：管理所有可用的子代理定义
- **功能**：注册、查询、列举代理

### 3. SubagentToolWrapper（工具包装器）
- **位置**：`packages/core/src/agents/subagent-tool-wrapper.ts`
- **作用**：将子代理包装成标准工具
- **功能**：动态生成 Schema、创建调用实例

### 4. SubagentInvocation（调用实例）
- **位置**：`packages/core/src/agents/invocation.ts`
- **作用**：表示一次具体的子代理执行
- **功能**：生命周期管理、事件桥接、结果格式化

### 5. AgentExecutor（执行引擎）
- **位置**：`packages/core/src/agents/executor.ts`
- **作用**：运行子代理的核心循环
- **功能**：模型调用、工具执行、终止控制

## 数据流

```
用户请求
  │
  ▼
主代理决策
  │
  ▼
选择子代理工具
  │
  ▼
SubagentToolWrapper.build(params)
  │
  ▼
SubagentInvocation.execute()
  │
  ▼
AgentExecutor.run()
  │
  ├─> 循环开始
  │   │
  │   ├─> 调用 Gemini 模型
  │   │   └─> 返回工具调用列表
  │   │
  │   ├─> 执行工具调用
  │   │   ├─> 标准工具 (read_file, grep, etc.)
  │   │   └─> complete_task (特殊终止工具)
  │   │
  │   ├─> 检查完成状态
  │   │   ├─> 已完成 → 退出循环
  │   │   └─> 未完成 → 继续循环
  │   │
  │   └─> 检查终止条件
  │       ├─> 超时 → 退出
  │       ├─> 最大轮次 → 退出
  │       └─> 继续
  │
  ▼
返回结果给主代理
  │
  ▼
主代理继续处理
```

## 关键特性

### 1. 隔离性
- **独立工具集**：每个子代理有自己的工具注册表
- **独立上下文**：不污染主代理的对话历史
- **独立配置**：可使用不同的模型和参数

### 2. 安全性
- **工具授权**：只能调用明确授权的工具
- **非交互验证**：启动前验证工具不需要用户确认
- **超时保护**：防止无限循环

### 3. 可观察性
- **活动事件**：
  - `THOUGHT_CHUNK`：思考过程
  - `TOOL_CALL_START`：工具调用开始
  - `TOOL_CALL_END`：工具调用结束
  - `ERROR`：错误信息
- **遥测日志**：启动、完成、执行时间等

### 4. 类型安全
- **Zod Schema**：输出验证
- **TypeScript 泛型**：编译时类型检查
- **参数验证**：运行时参数校验

### 5. 灵活性
- **模板系统**：`${variable}` 语法支持
- **自定义处理**：`processOutput` 函数
- **多种工具类型**：字符串、声明、实例

## 终止机制

子代理通过 `complete_task` 工具正常终止：

```typescript
// 子代理调用
{
  name: 'complete_task',
  args: {
    [outputName]: {
      // 符合 schema 的输出数据
    }
  }
}
```

其他终止原因：
- `TIMEOUT`：超过最大执行时间
- `MAX_TURNS`：超过最大对话轮次
- `ABORTED`：外部中止信号
- `ERROR`：协议违规（未调用 complete_task）

## 实际案例

### CodebaseInvestigatorAgent
专门用于代码库分析的子代理：

**输入**：
```typescript
{
  objective: "Find all files related to user authentication"
}
```

**工具集**：
- `ls`：列出目录
- `read_file`：读取文件
- `glob`：文件匹配
- `grep`：文本搜索

**输出**：
```json
{
  "SummaryOfFindings": "认证系统位于 src/auth/ 目录...",
  "ExplorationTrace": [
    "使用 grep 搜索 'authentication'",
    "读取 src/auth/index.ts",
    "..."
  ],
  "RelevantLocations": [
    {
      "FilePath": "src/auth/login.ts",
      "Reasoning": "包含登录逻辑",
      "KeySymbols": ["login", "validateCredentials"]
    }
  ]
}
```

## 优势

1. **专业化**：每个子代理专注于特定任务
2. **可重用**：可被多个主代理使用
3. **可测试**：独立定义便于测试
4. **可维护**：清晰的职责分离
5. **可扩展**：轻松添加新子代理
6. **安全**：严格的授权和验证

## 下一步

详细文档：
- [02-AgentDefinition详解.md](./02-AgentDefinition详解.md) - 代理定义的完整说明
- [03-执行流程详解.md](./03-执行流程详解.md) - 执行循环的深入分析
- [04-工具包装机制.md](./04-工具包装机制.md) - 如何将代理包装成工具
- [05-实战案例分析.md](./05-实战案例分析.md) - CodebaseInvestigator 详解
- [06-扩展指南.md](./06-扩展指南.md) - 如何创建自定义子代理
