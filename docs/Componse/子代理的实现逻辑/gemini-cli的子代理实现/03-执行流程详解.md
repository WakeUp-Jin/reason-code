# æ‰§è¡Œæµç¨‹è¯¦è§£

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è§£æå­ä»£ç†ä»è¢«è°ƒç”¨åˆ°è¿”å›ç»“æœçš„å®Œæ•´æ‰§è¡Œæµç¨‹ï¼ŒåŒ…æ‹¬æ¯ä¸ªé˜¶æ®µçš„å…³é”®æ“ä½œå’Œæ•°æ®æµè½¬ã€‚

## å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é˜¶æ®µ 1: å·¥å…·è°ƒç”¨                                              â”‚
â”‚ ä¸»ä»£ç†å†³å®šä½¿ç”¨å­ä»£ç†å·¥å…·                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é˜¶æ®µ 2: å·¥å…·åŒ…è£…å™¨                                            â”‚
â”‚ SubagentToolWrapper.build(params)                           â”‚
â”‚ - éªŒè¯å‚æ•°                                                    â”‚
â”‚ - åˆ›å»º SubagentInvocation                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é˜¶æ®µ 3: è°ƒç”¨å®ä¾‹                                              â”‚
â”‚ SubagentInvocation.execute()                                â”‚
â”‚ - è®¾ç½®æ´»åŠ¨å›è°ƒ                                                â”‚
â”‚ - åˆ›å»º AgentExecutor                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é˜¶æ®µ 4: æ‰§è¡Œå™¨åˆ›å»º                                            â”‚
â”‚ AgentExecutor.create()                                      â”‚
â”‚ - åˆ›å»ºéš”ç¦»çš„å·¥å…·æ³¨å†Œè¡¨                                         â”‚
â”‚ - æ³¨å†Œæˆæƒçš„å·¥å…·                                              â”‚
â”‚ - éªŒè¯å·¥å…·éäº¤äº’æ€§                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é˜¶æ®µ 5: æ‰§è¡Œå¾ªç¯                                              â”‚
â”‚ AgentExecutor.run()                                         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â”‚ å¾ªç¯å¼€å§‹                                              â”‚    â”‚
â”‚ â”‚                                                       â”‚    â”‚
â”‚ â”‚ 1. æ£€æŸ¥ç»ˆæ­¢æ¡ä»¶                                       â”‚    â”‚
â”‚ â”‚    - è¶…æ—¶ï¼Ÿ                                           â”‚    â”‚
â”‚ â”‚    - æœ€å¤§è½®æ¬¡ï¼Ÿ                                       â”‚    â”‚
â”‚ â”‚    - ä¸­æ­¢ä¿¡å·ï¼Ÿ                                       â”‚    â”‚
â”‚ â”‚                                                       â”‚    â”‚
â”‚ â”‚ 2. è°ƒç”¨æ¨¡å‹                                           â”‚    â”‚
â”‚ â”‚    - å‘é€å½“å‰æ¶ˆæ¯                                     â”‚    â”‚
â”‚ â”‚    - æ¥æ”¶å“åº”æµ                                       â”‚    â”‚
â”‚ â”‚    - æå–å·¥å…·è°ƒç”¨                                     â”‚    â”‚
â”‚ â”‚    - æå–æ€è€ƒå†…å®¹                                     â”‚    â”‚
â”‚ â”‚                                                       â”‚    â”‚
â”‚ â”‚ 3. å¤„ç†å·¥å…·è°ƒç”¨                                       â”‚    â”‚
â”‚ â”‚    - complete_taskï¼Ÿâ†’ éªŒè¯è¾“å‡º â†’ é€€å‡º               â”‚    â”‚
â”‚ â”‚    - å…¶ä»–å·¥å…·ï¼Ÿâ†’ æ£€æŸ¥æˆæƒ â†’ æ‰§è¡Œ                     â”‚    â”‚
â”‚ â”‚                                                       â”‚    â”‚
â”‚ â”‚ 4. æ„å»ºä¸‹ä¸€æ¡æ¶ˆæ¯                                     â”‚    â”‚
â”‚ â”‚    - æ”¶é›†å·¥å…·å“åº”                                     â”‚    â”‚
â”‚ â”‚    - æ ¼å¼åŒ–ä¸º Content                                â”‚    â”‚
â”‚ â”‚                                                       â”‚    â”‚
â”‚ â”‚ 5. æ£€æŸ¥å®ŒæˆçŠ¶æ€                                       â”‚    â”‚
â”‚ â”‚    - å·²å®Œæˆï¼Ÿâ†’ é€€å‡ºå¾ªç¯                              â”‚    â”‚
â”‚ â”‚    - æœªå®Œæˆï¼Ÿâ†’ ç»§ç»­å¾ªç¯                              â”‚    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é˜¶æ®µ 6: ç»“æœè¿”å›                                              â”‚
â”‚ - æ ¼å¼åŒ–è¾“å‡º                                                  â”‚
â”‚ - è¿”å› ToolResult                                            â”‚
â”‚ - ä¸»ä»£ç†æ¥æ”¶ç»“æœ                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## é˜¶æ®µè¯¦è§£

### é˜¶æ®µ 1: å·¥å…·è°ƒç”¨

ä¸»ä»£ç†é€šè¿‡ Gemini API è¿”å›å·¥å…·è°ƒç”¨ï¼š

```typescript
// ä¸»ä»£ç†æ”¶åˆ°çš„å“åº”
{
  functionCalls: [
    {
      name: 'codebase_investigator',
      args: {
        objective: 'Find all authentication-related files'
      }
    }
  ]
}
```

### é˜¶æ®µ 2: å·¥å…·åŒ…è£…å™¨

`SubagentToolWrapper` å¤„ç†è°ƒç”¨ï¼š

```typescript
class SubagentToolWrapper {
  // 1. ä¸»ä»£ç†è°ƒç”¨ build æ–¹æ³•
  build(params: AgentInputs): ToolInvocation {
    // 2. å‚æ•°å·²ç”±æ¡†æ¶éªŒè¯ï¼ˆåŸºäº inputConfig ç”Ÿæˆçš„ Schemaï¼‰
    
    // 3. åˆ›å»ºè°ƒç”¨å®ä¾‹
    return this.createInvocation(params);
  }
  
  protected createInvocation(params: AgentInputs) {
    return new SubagentInvocation(
      params,
      this.definition,
      this.config,
      this.messageBus
    );
  }
}
```

### é˜¶æ®µ 3: è°ƒç”¨å®ä¾‹

`SubagentInvocation` ç®¡ç†æ‰§è¡Œï¼š

```typescript
class SubagentInvocation {
  async execute(
    signal: AbortSignal,
    updateOutput?: (output: string) => void
  ): Promise<ToolResult> {
    // 1. è®¾ç½®æ´»åŠ¨å›è°ƒ
    const onActivity = (activity: SubagentActivityEvent) => {
      if (activity.type === 'THOUGHT_CHUNK') {
        updateOutput?.(`ğŸ¤–ğŸ’­ ${activity.data['text']}`);
      }
    };
    
    // 2. åˆ›å»ºæ‰§è¡Œå™¨
    const executor = await AgentExecutor.create(
      this.definition,
      this.config,
      onActivity
    );
    
    // 3. è¿è¡Œå­ä»£ç†
    const output = await executor.run(this.params, signal);
    
    // 4. æ ¼å¼åŒ–ç»“æœ
    return {
      llmContent: [{ text: resultContent }],
      returnDisplay: displayContent
    };
  }
}
```

### é˜¶æ®µ 4: æ‰§è¡Œå™¨åˆ›å»º

`AgentExecutor.create()` å‡†å¤‡æ‰§è¡Œç¯å¢ƒï¼š

```typescript
static async create(definition, runtimeContext, onActivity) {
  // 1. åˆ›å»ºéš”ç¦»çš„å·¥å…·æ³¨å†Œè¡¨
  const agentToolRegistry = new ToolRegistry(runtimeContext);
  const parentToolRegistry = await runtimeContext.getToolRegistry();
  
  // 2. æ³¨å†Œæˆæƒçš„å·¥å…·
  for (const toolRef of definition.toolConfig.tools) {
    if (typeof toolRef === 'string') {
      // ä»çˆ¶æ³¨å†Œè¡¨è·å–å·¥å…·
      const tool = parentToolRegistry.getTool(toolRef);
      if (tool) {
        agentToolRegistry.registerTool(tool);
      }
    } else if ('build' in toolRef) {
      // ç›´æ¥æ³¨å†Œå·¥å…·å®ä¾‹
      agentToolRegistry.registerTool(toolRef);
    }
  }
  
  // 3. éªŒè¯å·¥å…·éäº¤äº’æ€§
  await this.validateTools(agentToolRegistry, definition.name);
  
  // 4. åˆ›å»ºæ‰§è¡Œå™¨å®ä¾‹
  return new AgentExecutor(
    definition,
    runtimeContext,
    agentToolRegistry,
    parentPromptId,
    onActivity
  );
}
```

å·¥å…·éªŒè¯é€»è¾‘ï¼š

```typescript
static async validateTools(registry, agentName) {
  for (const tool of registry.getAllTools()) {
    const schema = tool.schema.parametersJsonSchema;
    const requiredParams = schema?.required ?? [];
    
    // å¦‚æœå·¥å…·éœ€è¦å‚æ•°ï¼Œæ— æ³•éªŒè¯ï¼Œå‘å‡ºè­¦å‘Š
    if (requiredParams.length > 0) {
      console.warn(
        `Cannot check tool "${tool.name}" for interactivity ` +
        `because it requires parameters. Assuming safe.`
      );
      continue;
    }
    
    // æ„å»ºç©ºå‚æ•°è°ƒç”¨
    const invocation = tool.build({});
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç¡®è®¤
    const confirmationDetails = await invocation.shouldConfirmExecute(
      new AbortController().signal
    );
    
    if (confirmationDetails) {
      throw new Error(
        `Tool "${tool.name}" requires user confirmation and ` +
        `cannot be used in a non-interactive subagent.`
      );
    }
  }
}
```

### é˜¶æ®µ 5: æ‰§è¡Œå¾ªç¯

è¿™æ˜¯æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ï¼Œè¯¦ç»†åˆ†è§£å¦‚ä¸‹ï¼š

#### 5.1 åˆå§‹åŒ–

```typescript
async run(inputs: AgentInputs, signal: AbortSignal) {
  const startTime = Date.now();
  let turnCounter = 0;
  let terminateReason = AgentTerminateMode.ERROR;
  let finalResult: string | null = null;
  
  // è®°å½•å¯åŠ¨äº‹ä»¶
  logAgentStart(this.runtimeContext, new AgentStartEvent(...));
  
  try {
    // åˆ›å»ºèŠå¤©å¯¹è±¡
    const chat = await this.createChatObject(inputs);
    
    // å‡†å¤‡å·¥å…·åˆ—è¡¨
    const tools = this.prepareToolsList();
    
    // æ„å»ºåˆå§‹æŸ¥è¯¢
    const query = templateString(
      this.definition.promptConfig.query || 'Get Started!',
      inputs
    );
    let currentMessage = { role: 'user', parts: [{ text: query }] };
    
    // è¿›å…¥å¾ªç¯...
  }
}
```

#### 5.2 å¾ªç¯è¿­ä»£

```typescript
while (true) {
  // ========== æ­¥éª¤ 1: æ£€æŸ¥ç»ˆæ­¢æ¡ä»¶ ==========
  const reason = this.checkTermination(startTime, turnCounter);
  if (reason) {
    terminateReason = reason;
    break;
  }
  if (signal.aborted) {
    terminateReason = AgentTerminateMode.ABORTED;
    break;
  }
  
  // ========== æ­¥éª¤ 2: è°ƒç”¨æ¨¡å‹ ==========
  const promptId = `${this.agentId}#${turnCounter++}`;
  
  const { functionCalls } = await promptIdContext.run(
    promptId,
    async () => this.callModel(chat, currentMessage, tools, signal, promptId)
  );
  
  if (signal.aborted) {
    terminateReason = AgentTerminateMode.ABORTED;
    break;
  }
  
  // ========== æ­¥éª¤ 3: æ£€æŸ¥åè®®è¿è§„ ==========
  if (functionCalls.length === 0) {
    // æ¨¡å‹åœæ­¢è°ƒç”¨å·¥å…·ä½†æœªè°ƒç”¨ complete_task
    terminateReason = AgentTerminateMode.ERROR;
    finalResult = `Agent stopped calling tools but did not call ` +
                  `'complete_task' to finalize the session.`;
    this.emitActivity('ERROR', { error: finalResult });
    break;
  }
  
  // ========== æ­¥éª¤ 4: å¤„ç†å·¥å…·è°ƒç”¨ ==========
  const { nextMessage, submittedOutput, taskCompleted } =
    await this.processFunctionCalls(functionCalls, signal, promptId);
  
  // ========== æ­¥éª¤ 5: æ£€æŸ¥å®ŒæˆçŠ¶æ€ ==========
  if (taskCompleted) {
    finalResult = submittedOutput ?? 'Task completed successfully.';
    terminateReason = AgentTerminateMode.GOAL;
    break;
  }
  
  // å‡†å¤‡ä¸‹ä¸€è½®
  currentMessage = nextMessage;
}
```

#### 5.3 è°ƒç”¨æ¨¡å‹

```typescript
private async callModel(
  chat: GeminiChat,
  message: Content,
  tools: FunctionDeclaration[],
  signal: AbortSignal,
  promptId: string
) {
  // 1. å‡†å¤‡æ¶ˆæ¯å‚æ•°
  const messageParams = {
    message: message.parts || [],
    config: {
      abortSignal: signal,
      tools: tools.length > 0 
        ? [{ functionDeclarations: tools }] 
        : undefined
    }
  };
  
  // 2. å‘é€æ¶ˆæ¯å¹¶è·å–æµå¼å“åº”
  const responseStream = await chat.sendMessageStream(
    this.definition.modelConfig.model,
    messageParams,
    promptId
  );
  
  const functionCalls: FunctionCall[] = [];
  let textResponse = '';
  
  // 3. å¤„ç†å“åº”æµ
  for await (const resp of responseStream) {
    if (signal.aborted) break;
    
    if (resp.type === StreamEventType.CHUNK) {
      const chunk = resp.value;
      const parts = chunk.candidates?.[0]?.content?.parts;
      
      // 3a. æå–æ€è€ƒå†…å®¹
      const { subject } = parseThought(
        parts?.find(p => p.thought)?.text || ''
      );
      if (subject) {
        this.emitActivity('THOUGHT_CHUNK', { text: subject });
      }
      
      // 3b. æ”¶é›†å·¥å…·è°ƒç”¨
      if (chunk.functionCalls) {
        functionCalls.push(...chunk.functionCalls);
      }
      
      // 3c. æ”¶é›†æ–‡æœ¬å“åº”
      const text = parts
        ?.filter(p => !p.thought && p.text)
        .map(p => p.text)
        .join('') || '';
      if (text) {
        textResponse += text;
      }
    }
  }
  
  return { functionCalls, textResponse };
}
```

#### 5.4 å¤„ç†å·¥å…·è°ƒç”¨

```typescript
private async processFunctionCalls(
  functionCalls: FunctionCall[],
  signal: AbortSignal,
  promptId: string
) {
  const allowedToolNames = new Set(this.toolRegistry.getAllToolNames());
  allowedToolNames.add(TASK_COMPLETE_TOOL_NAME);
  
  let submittedOutput: string | null = null;
  let taskCompleted = false;
  
  const toolExecutionPromises: Array<Promise<Part[] | void>> = [];
  const syncResponseParts: Part[] = [];
  
  for (const [index, functionCall] of functionCalls.entries()) {
    const callId = functionCall.id ?? `${promptId}-${index}`;
    const args = (functionCall.args ?? {}) as Record<string, unknown>;
    
    this.emitActivity('TOOL_CALL_START', {
      name: functionCall.name,
      args
    });
    
    // ========== ç‰¹æ®Šå¤„ç†: complete_task ==========
    if (functionCall.name === TASK_COMPLETE_TOOL_NAME) {
      if (taskCompleted) {
        // é‡å¤è°ƒç”¨ï¼Œå¿½ç•¥
        syncResponseParts.push({
          functionResponse: {
            name: TASK_COMPLETE_TOOL_NAME,
            response: { error: 'Task already marked complete' },
            id: callId
          }
        });
        continue;
      }
      
      const { outputConfig } = this.definition;
      taskCompleted = true;
      
      if (outputConfig) {
        const outputName = outputConfig.outputName;
        if (args[outputName] !== undefined) {
          const outputValue = args[outputName];
          
          // éªŒè¯è¾“å‡º
          const validationResult = outputConfig.schema.safeParse(outputValue);
          
          if (!validationResult.success) {
            // éªŒè¯å¤±è´¥ï¼Œæ’¤é”€å®ŒæˆçŠ¶æ€
            taskCompleted = false;
            const error = `Output validation failed: ` +
                         JSON.stringify(validationResult.error.flatten());
            syncResponseParts.push({
              functionResponse: {
                name: TASK_COMPLETE_TOOL_NAME,
                response: { error },
                id: callId
              }
            });
            this.emitActivity('ERROR', { error });
            continue;
          }
          
          // å¤„ç†è¾“å‡º
          const validatedOutput = validationResult.data;
          if (this.definition.processOutput) {
            submittedOutput = this.definition.processOutput(validatedOutput);
          } else {
            submittedOutput = typeof outputValue === 'string'
              ? outputValue
              : JSON.stringify(outputValue, null, 2);
          }
          
          syncResponseParts.push({
            functionResponse: {
              name: TASK_COMPLETE_TOOL_NAME,
              response: { result: 'Output submitted and task completed.' },
              id: callId
            }
          });
          this.emitActivity('TOOL_CALL_END', {
            name: functionCall.name,
            output: 'Output submitted and task completed.'
          });
        } else {
          // ç¼ºå°‘å¿…éœ€çš„è¾“å‡ºå‚æ•°
          taskCompleted = false;
          const error = `Missing required argument '${outputName}'`;
          syncResponseParts.push({
            functionResponse: {
              name: TASK_COMPLETE_TOOL_NAME,
              response: { error },
              id: callId
            }
          });
          this.emitActivity('ERROR', { error });
        }
      } else {
        // æ— è¾“å‡ºè¦æ±‚ï¼Œç›´æ¥å®Œæˆ
        submittedOutput = 'Task completed successfully.';
        syncResponseParts.push({
          functionResponse: {
            name: TASK_COMPLETE_TOOL_NAME,
            response: { status: 'Task marked complete.' },
            id: callId
          }
        });
        this.emitActivity('TOOL_CALL_END', {
          name: functionCall.name,
          output: 'Task marked complete.'
        });
      }
      continue;
    }
    
    // ========== å¤„ç†æ ‡å‡†å·¥å…· ==========
    
    // æ£€æŸ¥æˆæƒ
    if (!allowedToolNames.has(functionCall.name as string)) {
      const error = `Unauthorized tool call: '${functionCall.name}'`;
      console.warn(`[AgentExecutor] Blocked call: ${error}`);
      
      syncResponseParts.push({
        functionResponse: {
          name: functionCall.name as string,
          id: callId,
          response: { error }
        }
      });
      
      this.emitActivity('ERROR', {
        context: 'tool_call_unauthorized',
        name: functionCall.name,
        error
      });
      continue;
    }
    
    // æ‰§è¡Œå·¥å…·
    const requestInfo: ToolCallRequestInfo = {
      callId,
      name: functionCall.name as string,
      args,
      isClientInitiated: true,
      prompt_id: promptId
    };
    
    const executionPromise = (async () => {
      const toolResponse = await executeToolCall(
        this.runtimeContext,
        requestInfo,
        signal
      );
      
      if (toolResponse.error) {
        this.emitActivity('ERROR', {
          context: 'tool_call',
          name: functionCall.name,
          error: toolResponse.error.message
        });
      } else {
        this.emitActivity('TOOL_CALL_END', {
          name: functionCall.name,
          output: toolResponse.resultDisplay
        });
      }
      
      return toolResponse.responseParts;
    })();
    
    toolExecutionPromises.push(executionPromise);
  }
  
  // ç­‰å¾…æ‰€æœ‰å·¥å…·æ‰§è¡Œå®Œæˆ
  const asyncResults = await Promise.all(toolExecutionPromises);
  
  // åˆå¹¶æ‰€æœ‰å“åº”
  const toolResponseParts: Part[] = [...syncResponseParts];
  for (const result of asyncResults) {
    if (result) {
      toolResponseParts.push(...result);
    }
  }
  
  // å¦‚æœæ‰€æœ‰å·¥å…·éƒ½å¤±è´¥ä¸”ä»»åŠ¡æœªå®Œæˆï¼Œæä¾›é€šç”¨é”™è¯¯
  if (
    functionCalls.length > 0 &&
    toolResponseParts.length === 0 &&
    !taskCompleted
  ) {
    toolResponseParts.push({
      text: 'All tool calls failed or were unauthorized. ' +
            'Please analyze the errors and try an alternative approach.'
    });
  }
  
  return {
    nextMessage: { role: 'user', parts: toolResponseParts },
    submittedOutput,
    taskCompleted
  };
}
```

### é˜¶æ®µ 6: ç»“æœè¿”å›

æ‰§è¡Œå®Œæˆåï¼Œç»“æœæ²¿è°ƒç”¨é“¾è¿”å›ï¼š

```typescript
// AgentExecutor.run() è¿”å›
return {
  result: finalResult || 'Task completed.',
  terminate_reason: terminateReason
};

// SubagentInvocation.execute() æ ¼å¼åŒ–
const resultContent = `
Subagent '${this.definition.name}' finished.
Termination Reason: ${output.terminate_reason}
Result:
${output.result}
`;

return {
  llmContent: [{ text: resultContent }],
  returnDisplay: displayContent
};

// ä¸»ä»£ç†æ¥æ”¶ ToolResult
// å°†å…¶ä½œä¸ºå·¥å…·å“åº”æ·»åŠ åˆ°å¯¹è¯å†å²
```

## å…³é”®æ—¶åº

```
T0: ä¸»ä»£ç†è°ƒç”¨å·¥å…·
  â””â”€> SubagentToolWrapper.build()
      
T1: åˆ›å»ºè°ƒç”¨å®ä¾‹
  â””â”€> SubagentInvocation.execute()
      
T2: åˆ›å»ºæ‰§è¡Œå™¨
  â””â”€> AgentExecutor.create()
      â”œâ”€> æ³¨å†Œå·¥å…· (åŒæ­¥)
      â””â”€> éªŒè¯å·¥å…· (å¼‚æ­¥)
      
T3: å¼€å§‹æ‰§è¡Œå¾ªç¯
  â””â”€> AgentExecutor.run()
      
T4-T(N): å¾ªç¯è¿­ä»£
  â”œâ”€> è°ƒç”¨æ¨¡å‹ (å¼‚æ­¥, ~1-5ç§’)
  â”œâ”€> å¤„ç†å·¥å…·è°ƒç”¨ (å¹¶è¡Œæ‰§è¡Œ)
  â”‚   â”œâ”€> å·¥å…·1 (å¼‚æ­¥)
  â”‚   â”œâ”€> å·¥å…·2 (å¼‚æ­¥)
  â”‚   â””â”€> å·¥å…·3 (å¼‚æ­¥)
  â””â”€> æ„å»ºä¸‹ä¸€æ¡æ¶ˆæ¯
      
T(N+1): ä»»åŠ¡å®Œæˆ
  â””â”€> è¿”å›ç»“æœ
      
T(N+2): æ ¼å¼åŒ–è¾“å‡º
  â””â”€> è¿”å›ç»™ä¸»ä»£ç†
```

## é”™è¯¯å¤„ç†

### 1. è¶…æ—¶å¤„ç†

```typescript
checkTermination(startTime: number, turnCounter: number) {
  // æ£€æŸ¥æ—¶é—´
  const durationMin = (Date.now() - startTime) / (1000 * 60);
  if (durationMin >= this.definition.runConfig.max_time_minutes) {
    return AgentTerminateMode.TIMEOUT;
  }
  
  // æ£€æŸ¥è½®æ¬¡
  if (
    this.definition.runConfig.max_turns &&
    turnCounter >= this.definition.runConfig.max_turns
  ) {
    return AgentTerminateMode.MAX_TURNS;
  }
  
  return null;
}
```

### 2. ä¸­æ­¢å¤„ç†

```typescript
// åœ¨å¤šä¸ªå…³é”®ç‚¹æ£€æŸ¥ä¸­æ­¢ä¿¡å·
if (signal.aborted) {
  terminateReason = AgentTerminateMode.ABORTED;
  break;
}
```

### 3. åè®®è¿è§„

```typescript
// æ¨¡å‹åœæ­¢è°ƒç”¨å·¥å…·ä½†æœªè°ƒç”¨ complete_task
if (functionCalls.length === 0) {
  terminateReason = AgentTerminateMode.ERROR;
  finalResult = 'Agent stopped calling tools but did not call complete_task';
  break;
}
```

### 4. è¾“å‡ºéªŒè¯å¤±è´¥

```typescript
const validationResult = outputConfig.schema.safeParse(outputValue);
if (!validationResult.success) {
  taskCompleted = false;  // æ’¤é”€å®ŒæˆçŠ¶æ€
  // è¿”å›é”™è¯¯ç»™æ¨¡å‹ï¼Œè®©å®ƒé‡è¯•
}
```

### 5. å·¥å…·æ‰§è¡Œå¤±è´¥

```typescript
const toolResponse = await executeToolCall(...);
if (toolResponse.error) {
  // è®°å½•é”™è¯¯
  this.emitActivity('ERROR', { error: toolResponse.error.message });
  // å°†é”™è¯¯è¿”å›ç»™æ¨¡å‹
  return toolResponse.responseParts;  // åŒ…å«é”™è¯¯ä¿¡æ¯
}
```

## æ€§èƒ½ä¼˜åŒ–

### 1. å¹¶è¡Œå·¥å…·æ‰§è¡Œ

```typescript
// æ”¶é›†æ‰€æœ‰å·¥å…·æ‰§è¡Œçš„ Promise
const toolExecutionPromises: Array<Promise<Part[]>> = [];

for (const functionCall of functionCalls) {
  const promise = executeToolCall(...);
  toolExecutionPromises.push(promise);
}

// å¹¶è¡Œç­‰å¾…æ‰€æœ‰å·¥å…·å®Œæˆ
const results = await Promise.all(toolExecutionPromises);
```

### 2. æµå¼è¾“å‡º

```typescript
// å®æ—¶ä¼ è¾“æ€è€ƒå†…å®¹
for await (const resp of responseStream) {
  if (resp.type === StreamEventType.CHUNK) {
    const { subject } = parseThought(...);
    if (subject) {
      // ç«‹å³å‘é€ç»™ UIï¼Œä¸ç­‰å¾…å®Œæ•´å“åº”
      this.emitActivity('THOUGHT_CHUNK', { text: subject });
    }
  }
}
```

### 3. æå‰ç»ˆæ­¢

```typescript
// åœ¨å¤šä¸ªç‚¹æ£€æŸ¥ç»ˆæ­¢æ¡ä»¶ï¼Œé¿å…ä¸å¿…è¦çš„è®¡ç®—
const reason = this.checkTermination(startTime, turnCounter);
if (reason) {
  terminateReason = reason;
  break;  // ç«‹å³é€€å‡ºå¾ªç¯
}
```

## æ€»ç»“

å­ä»£ç†çš„æ‰§è¡Œæµç¨‹æ˜¯ä¸€ä¸ªç²¾å¿ƒè®¾è®¡çš„å¾ªç¯ç³»ç»Ÿï¼š

1. **éš”ç¦»æ€§**ï¼šç‹¬ç«‹çš„å·¥å…·æ³¨å†Œè¡¨å’Œå¯¹è¯å†å²
2. **å®‰å…¨æ€§**ï¼šå¤šå±‚éªŒè¯å’Œæˆæƒæ£€æŸ¥
3. **å¯è§‚å¯Ÿæ€§**ï¼šä¸°å¯Œçš„æ´»åŠ¨äº‹ä»¶æµ
4. **å®¹é”™æ€§**ï¼šå¤šç§ç»ˆæ­¢æ¡ä»¶å’Œé”™è¯¯å¤„ç†
5. **æ€§èƒ½**ï¼šå¹¶è¡Œæ‰§è¡Œå’Œæµå¼è¾“å‡º

ç†è§£è¿™ä¸ªæµç¨‹å¯¹äºè°ƒè¯•é—®é¢˜ã€ä¼˜åŒ–æ€§èƒ½å’Œæ‰©å±•åŠŸèƒ½éƒ½è‡³å…³é‡è¦ã€‚
