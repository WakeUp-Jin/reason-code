# 工具包装机制详解

## 概述

工具包装机制是子代理系统的关键创新，它将 `AgentDefinition` 转换为标准的 `DeclarativeTool`，使子代理能够无缝集成到主代理的工具系统中。

## 核心概念

### 为什么需要包装？

主代理通过工具系统与外部功能交互。要让子代理被主代理使用，必须：

1. **统一接口**：子代理需要实现 `DeclarativeTool` 接口
2. **参数验证**：自动生成 JSON Schema 用于参数验证
3. **生命周期管理**：处理调用、执行、结果返回
4. **类型安全**：确保编译时和运行时的类型一致性

### 包装流程

```
AgentDefinition
  │
  │ 包装
  ▼
SubagentToolWrapper (extends BaseDeclarativeTool)
  │
  │ 注册
  ▼
ToolRegistry
  │
  │ 主代理调用
  ▼
SubagentInvocation
  │
  │ 执行
  ▼
AgentExecutor
```

## SubagentToolWrapper 实现

### 类定义

```typescript
export class SubagentToolWrapper extends BaseDeclarativeTool<
  AgentInputs,
  ToolResult
> {
  constructor(
    private readonly definition: AgentDefinition,
    private readonly config: Config,
    messageBus?: MessageBus
  ) {
    // 1. 从 inputConfig 动态生成 JSON Schema
    const parameterSchema = convertInputConfigToJsonSchema(
      definition.inputConfig
    );
    
    // 2. 调用父类构造函数
    super(
      definition.name,                    // 工具名称
      definition.displayName ?? definition.name,  // 显示名称
      definition.description,             // 工具描述
      Kind.Think,                         // 工具类型
      parameterSchema,                    // 参数 Schema
      /* isOutputMarkdown */ true,        // 输出是 Markdown
      /* canUpdateOutput */ true,         // 支持流式更新
      messageBus                          // 消息总线
    );
  }
  
  protected createInvocation(
    params: AgentInputs
  ): ToolInvocation<AgentInputs, ToolResult> {
    return new SubagentInvocation(
      params,
      this.definition,
      this.config,
      this.messageBus
    );
  }
}
```

### 关键特性

#### 1. 动态 Schema 生成

`convertInputConfigToJsonSchema` 函数将 `InputConfig` 转换为 JSON Schema：

```typescript
function convertInputConfigToJsonSchema(
  inputConfig: InputConfig
): Record<string, unknown> {
  const properties: Record<string, unknown> = {};
  const required: string[] = [];
  
  for (const [key, config] of Object.entries(inputConfig.inputs)) {
    // 转换类型
    let jsonType: string;
    let items: unknown = undefined;
    
    switch (config.type) {
      case 'string':
        jsonType = 'string';
        break;
      case 'number':
        jsonType = 'number';
        break;
      case 'integer':
        jsonType = 'integer';
        break;
      case 'boolean':
        jsonType = 'boolean';
        break;
      case 'string[]':
        jsonType = 'array';
        items = { type: 'string' };
        break;
      case 'number[]':
        jsonType = 'array';
        items = { type: 'number' };
        break;
      default:
        jsonType = 'string';
    }
    
    // 构建属性定义
    properties[key] = {
      type: jsonType,
      description: config.description,
      ...(items && { items })
    };
    
    // 收集必需字段
    if (config.required) {
      required.push(key);
    }
  }
  
  return {
    type: 'object',
    properties,
    required
  };
}
```

**示例转换**：

输入（InputConfig）：
```typescript
{
  inputs: {
    objective: {
      description: 'Investigation goal',
      type: 'string',
      required: true
    },
    max_files: {
      description: 'Maximum files to analyze',
      type: 'integer',
      required: false
    }
  }
}
```

输出（JSON Schema）：
```json
{
  "type": "object",
  "properties": {
    "objective": {
      "type": "string",
      "description": "Investigation goal"
    },
    "max_files": {
      "type": "integer",
      "description": "Maximum files to analyze"
    }
  },
  "required": ["objective"]
}
```

#### 2. 工具类型

```typescript
Kind.Think
```

- **含义**：这是一个"思考型"工具
- **特点**：
  - 执行时间较长
  - 可能产生大量输出
  - 支持流式更新
  - 适合复杂推理任务

其他工具类型：
- `Kind.Read`：读取操作（快速）
- `Kind.Write`：写入操作（需要确认）
- `Kind.Execute`：执行操作（需要确认）

#### 3. 输出特性

```typescript
/* isOutputMarkdown */ true
```
- 输出内容是 Markdown 格式
- UI 可以进行富文本渲染

```typescript
/* canUpdateOutput */ true
```
- 支持流式更新输出
- 可以实时显示子代理的思考过程

## 注册流程

### 在 Config 中注册

```typescript
// packages/core/src/config/config.ts

async getToolRegistry(): Promise<ToolRegistry> {
  const registry = new ToolRegistry(this);
  
  // 1. 注册标准工具
  await registry.discoverAllTools();
  
  // 2. 如果启用了子代理功能
  if (this.getEnableSubagents()) {
    // 获取代理注册表
    const agentRegistry = await this.getAgentRegistry();
    const agentDefinitions = agentRegistry.getAllDefinitions();
    
    // 3. 为每个代理创建包装器
    for (const definition of agentDefinitions) {
      // 检查允许/排除列表
      const excludeTools = this.getExcludeTools() || [];
      const allowedTools = this.getAllowedTools();
      
      const isExcluded = excludeTools.includes(definition.name);
      const isAllowed = !allowedTools || allowedTools.includes(definition.name);
      
      if (isAllowed && !isExcluded) {
        try {
          const messageBusEnabled = this.getEnableMessageBusIntegration();
          
          // 4. 创建包装器
          const wrapper = new SubagentToolWrapper(
            definition,
            this,
            messageBusEnabled ? this.getMessageBus() : undefined
          );
          
          // 5. 注册到工具注册表
          registry.registerTool(wrapper);
        } catch (error) {
          console.error(
            `Failed to wrap agent '${definition.name}' as a tool:`,
            error
          );
        }
      }
    }
  }
  
  return registry;
}
```

### 注册后的效果

注册后，主代理会看到新的工具：

```typescript
// 主代理的工具列表
{
  tools: [
    {
      name: 'read_file',
      description: 'Read contents of a file',
      parameters: { ... }
    },
    {
      name: 'grep',
      description: 'Search for patterns in files',
      parameters: { ... }
    },
    {
      name: 'codebase_investigator',  // 子代理工具
      description: 'Your primary tool for multifile search tasks...',
      parameters: {
        type: 'object',
        properties: {
          objective: {
            type: 'string',
            description: 'A comprehensive description...'
          }
        },
        required: ['objective']
      }
    }
  ]
}
```

## 调用流程

### 1. 主代理决策

主代理根据工具描述选择合适的工具：

```typescript
// 主代理的思考过程
"The user wants to find authentication files. 
The 'codebase_investigator' tool is perfect for this task."

// 生成工具调用
{
  name: 'codebase_investigator',
  args: {
    objective: 'Find all authentication-related files and their key functions'
  }
}
```

### 2. 框架验证参数

工具框架使用生成的 JSON Schema 验证参数：

```typescript
// 伪代码
const schema = tool.schema.parametersJsonSchema;
const isValid = validateAgainstSchema(args, schema);

if (!isValid) {
  throw new Error('Invalid parameters');
}
```

### 3. 构建调用实例

```typescript
// SubagentToolWrapper.build() 被调用
const invocation = wrapper.build({
  objective: 'Find all authentication-related files...'
});

// 返回 SubagentInvocation 实例
```

### 4. 执行调用

```typescript
// 框架调用 execute 方法
const result = await invocation.execute(
  signal,
  (output) => {
    // 流式更新回调
    console.log(output);
  }
);

// 返回 ToolResult
```

## 与标准工具的对比

### 标准工具

```typescript
class ReadFileTool extends BaseDeclarativeTool {
  constructor() {
    super(
      'read_file',
      'Read File',
      'Read contents of a file',
      Kind.Read,
      {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'File path' }
        },
        required: ['path']
      }
    );
  }
  
  protected createInvocation(params) {
    return new ReadFileInvocation(params);
  }
}

class ReadFileInvocation extends BaseToolInvocation {
  async execute(signal) {
    const content = await fs.readFile(this.params.path, 'utf-8');
    return {
      llmContent: [{ text: content }],
      returnDisplay: content
    };
  }
}
```

### 子代理工具

```typescript
// 通过包装器自动生成
const wrapper = new SubagentToolWrapper(
  CodebaseInvestigatorAgent,  // AgentDefinition
  config
);

// 调用实例自动创建
class SubagentInvocation extends BaseToolInvocation {
  async execute(signal, updateOutput) {
    // 创建并运行 AgentExecutor
    const executor = await AgentExecutor.create(...);
    const output = await executor.run(this.params, signal);
    
    return {
      llmContent: [{ text: output.result }],
      returnDisplay: output.result
    };
  }
}
```

**关键区别**：
- 标准工具：直接实现功能
- 子代理工具：运行一个完整的 AI 代理循环

## 高级特性

### 1. 消息总线集成

```typescript
const messageBusEnabled = this.getEnableMessageBusIntegration();

const wrapper = new SubagentToolWrapper(
  definition,
  this,
  messageBusEnabled ? this.getMessageBus() : undefined
);
```

**作用**：
- 策略执行（如需要审批）
- 审计日志
- 权限控制

### 2. 允许/排除列表

```typescript
const excludeTools = this.getExcludeTools() || [];
const allowedTools = this.getAllowedTools();

const isExcluded = excludeTools.includes(definition.name);
const isAllowed = !allowedTools || allowedTools.includes(definition.name);

if (isAllowed && !isExcluded) {
  // 注册工具
}
```

**用途**：
- 企业环境中限制可用工具
- 测试时禁用某些工具
- 按项目配置工具集

### 3. 错误处理

```typescript
try {
  const wrapper = new SubagentToolWrapper(definition, this, messageBus);
  registry.registerTool(wrapper);
} catch (error) {
  console.error(
    `Failed to wrap agent '${definition.name}' as a tool:`,
    error
  );
  // 继续注册其他工具，不中断整个流程
}
```

## 类型安全

### 泛型参数

```typescript
class SubagentToolWrapper extends BaseDeclarativeTool<
  AgentInputs,    // 输入类型
  ToolResult      // 输出类型
>
```

### AgentInputs 类型

```typescript
type AgentInputs = Record<string, unknown>;
```

- 灵活的键值对结构
- 运行时通过 JSON Schema 验证
- 编译时通过 TypeScript 检查

### ToolResult 类型

```typescript
interface ToolResult {
  llmContent: string | Part[];
  returnDisplay?: string;
  error?: ToolError;
}
```

- 标准化的返回格式
- 支持富文本内容
- 包含错误信息

## 实际示例

### 完整的包装过程

```typescript
// 1. 定义代理
const MyAgent: AgentDefinition = {
  name: 'my_agent',
  description: 'Does something useful',
  inputConfig: {
    inputs: {
      task: {
        description: 'Task to perform',
        type: 'string',
        required: true
      }
    }
  },
  // ... 其他配置
};

// 2. 注册代理
agentRegistry.registerAgent(MyAgent);

// 3. 自动包装（在 getToolRegistry 中）
const wrapper = new SubagentToolWrapper(MyAgent, config);

// 4. 注册工具
toolRegistry.registerTool(wrapper);

// 5. 主代理可以使用
// 主代理看到的工具：
{
  name: 'my_agent',
  description: 'Does something useful',
  parameters: {
    type: 'object',
    properties: {
      task: {
        type: 'string',
        description: 'Task to perform'
      }
    },
    required: ['task']
  }
}

// 6. 主代理调用
functionCall: {
  name: 'my_agent',
  args: {
    task: 'Analyze the codebase'
  }
}

// 7. 执行流程
wrapper.build(args)
  → SubagentInvocation.execute()
    → AgentExecutor.run()
      → [子代理循环]
        → 返回结果
```

## 总结

工具包装机制是子代理系统的桥梁：

1. **自动化**：从 `AgentDefinition` 自动生成工具
2. **标准化**：统一的 `DeclarativeTool` 接口
3. **类型安全**：编译时和运行时双重保证
4. **灵活性**：支持各种配置和扩展
5. **透明性**：主代理无需知道工具是子代理

这种设计使得添加新的子代理变得非常简单，只需定义 `AgentDefinition`，其余的都由框架自动处理。
