# 实战案例：CodebaseInvestigatorAgent 深度解析

## 概述

`CodebaseInvestigatorAgent` 是 Gemini CLI 内置的代码库分析子代理，专门用于深度探索代码库结构、依赖关系和技术细节。本文档通过这个实际案例，展示子代理的完整设计和实现。

## 完整定义

```typescript
const CodebaseInvestigationReportSchema = z.object({
  SummaryOfFindings: z.string().describe(
    "A summary of the investigation's conclusions and insights"
  ),
  ExplorationTrace: z.array(z.string()).describe(
    'A step-by-step list of actions and tools used'
  ),
  RelevantLocations: z.array(
    z.object({
      FilePath: z.string(),
      Reasoning: z.string(),
      KeySymbols: z.array(z.string())
    })
  ).describe('A list of relevant files and key symbols')
});

export const CodebaseInvestigatorAgent: AgentDefinition<
  typeof CodebaseInvestigationReportSchema
> = {
  name: 'codebase_investigator',
  displayName: 'Codebase Investigator Agent',
  
  description: `
    Your primary tool for multifile search tasks and codebase exploration.
    Invoke this tool to delegate search tasks to an autonomous subagent.
    Use this to find features, understand context, or locate specific files.
    Returns a structured JSON report with key file paths, symbols, and insights.
  `,
  
  inputConfig: {
    inputs: {
      objective: {
        description: `
          A comprehensive and detailed description of the user's ultimate goal.
          Include original user's objective as well as any extra context.
        `,
        type: 'string',
        required: true
      }
    }
  },
  
  outputConfig: {
    outputName: 'report',
    description: 'The final investigation report as a JSON object',
    schema: CodebaseInvestigationReportSchema
  },
  
  processOutput: (output) => JSON.stringify(output, null, 2),
  
  modelConfig: {
    model: DEFAULT_GEMINI_MODEL,
    temp: 0.1,
    top_p: 0.95,
    thinkingBudget: -1
  },
  
  runConfig: {
    max_time_minutes: 5,
    max_turns: 15
  },
  
  toolConfig: {
    tools: [LSTool.Name, ReadFileTool.Name, GLOB_TOOL_NAME, GrepTool.Name]
  },
  
  promptConfig: {
    query: `
      Your task is to investigate the codebase for:
      <objective>
      \${objective}
      </objective>
    `,
    systemPrompt: `[详见下文]`
  }
};
```

## 设计分析

### 1. 输入设计

```typescript
inputConfig: {
  inputs: {
    objective: {
      description: 'A comprehensive description of the user\'s goal',
      type: 'string',
      required: true
    }
  }
}
```

**设计考虑**：
- **单一参数**：简化调用，主代理只需提供目标描述
- **灵活性**：`objective` 可以是任何形式的查询
- **上下文丰富**：鼓励主代理提供详细的上下文

**示例输入**：
```typescript
{
  objective: `
    Find all files related to user authentication.
    The user mentioned they're using JWT tokens.
    We need to understand the login flow and session management.
  `
}
```

### 2. 输出设计

```typescript
const CodebaseInvestigationReportSchema = z.object({
  SummaryOfFindings: z.string(),
  ExplorationTrace: z.array(z.string()),
  RelevantLocations: z.array(
    z.object({
      FilePath: z.string(),
      Reasoning: z.string(),
      KeySymbols: z.array(z.string())
    })
  )
});
```

**设计考虑**：

#### SummaryOfFindings
- **目的**：提供高层次的结论
- **内容**：架构理解、关键发现、建议
- **受众**：主代理和最终用户

#### ExplorationTrace
- **目的**：记录探索过程
- **内容**：使用的工具、搜索的关键词、分析的文件
- **价值**：
  - 可审计性
  - 调试帮助
  - 学习示例

#### RelevantLocations
- **目的**：精确定位相关代码
- **结构**：
  - `FilePath`：文件路径
  - `Reasoning`：为什么这个文件相关
  - `KeySymbols`：重要的函数、类、变量名

**示例输出**：
```json
{
  "SummaryOfFindings": "认证系统使用 JWT，主要逻辑在 src/auth/ 目录。登录流程涉及 3 个主要文件，使用 bcrypt 进行密码哈希。",
  "ExplorationTrace": [
    "使用 glob 搜索 'auth' 相关文件",
    "读取 src/auth/index.ts 了解模块结构",
    "使用 grep 搜索 'jwt' 关键词",
    "读取 src/auth/jwt.ts 分析 token 生成逻辑"
  ],
  "RelevantLocations": [
    {
      "FilePath": "src/auth/login.ts",
      "Reasoning": "包含登录端点和凭证验证逻辑",
      "KeySymbols": ["loginHandler", "validateCredentials", "generateToken"]
    },
    {
      "FilePath": "src/auth/jwt.ts",
      "Reasoning": "JWT token 的生成和验证",
      "KeySymbols": ["createToken", "verifyToken", "refreshToken"]
    }
  ]
}
```

### 3. 模型配置

```typescript
modelConfig: {
  model: DEFAULT_GEMINI_MODEL,  // gemini-2.5-pro
  temp: 0.1,
  top_p: 0.95,
  thinkingBudget: -1
}
```

**设计考虑**：

#### 低温度 (0.1)
- **原因**：代码分析需要高精确度
- **效果**：
  - 减少幻觉
  - 更准确的文件路径
  - 更可靠的符号识别

#### 无限思考预算 (-1)
- **原因**：复杂的代码库需要深度推理
- **效果**：
  - 允许充分的分析时间
  - 更全面的探索
  - 更深入的理解

### 4. 运行配置

```typescript
runConfig: {
  max_time_minutes: 5,
  max_turns: 15
}
```

**设计考虑**：

#### 5 分钟超时
- **足够时间**：探索中等规模的代码库
- **防止卡死**：避免无限循环
- **用户体验**：合理的等待时间

#### 15 轮对话
- **典型流程**：
  1. 初始探索 (2-3 轮)
  2. 深入分析 (5-8 轮)
  3. 验证和补充 (2-4 轮)
  4. 生成报告 (1 轮)

### 5. 工具配置

```typescript
toolConfig: {
  tools: [
    LSTool.Name,        // 列出目录内容
    ReadFileTool.Name,  // 读取文件
    GLOB_TOOL_NAME,     // 文件模式匹配
    GrepTool.Name       // 文本搜索
  ]
}
```

**设计考虑**：

#### 只读工具
- **安全性**：不会修改代码库
- **适用性**：分析任务不需要写权限

#### 工具组合
- **ls**：了解目录结构
- **glob**：快速定位文件
- **grep**：搜索关键词
- **read_file**：深入分析内容

**典型使用模式**：
```
1. glob("**/*auth*")  → 找到候选文件
2. ls("src/auth")     → 了解目录结构
3. grep("jwt")        → 搜索 JWT 相关代码
4. read_file("src/auth/jwt.ts")  → 详细分析
```

## 系统提示分析

系统提示是子代理行为的核心，让我们逐部分分析：

### 角色定义

```
You are **Codebase Investigator**, a hyper-specialized AI agent 
and an expert in reverse-engineering complex software projects.
You are a sub-agent within a larger development system.
```

**作用**：
- 建立专家身份
- 明确子代理定位
- 设定期望的专业水平

### 核心职责

```
Your **SOLE PURPOSE** is to build a complete mental model of the code 
relevant to a given investigation.

You must identify all relevant files, understand their roles, 
and foresee the direct architectural consequences of potential changes.
```

**作用**：
- 聚焦任务范围
- 强调深度理解
- 要求前瞻性思考

### 行为准则

```
- **DO:** Find the key modules, classes, and functions
- **DO:** Understand *why* the code is written the way it is
- **DO:** Foresee the ripple effects of a change
- **DO:** Provide conclusions and insights to the main agent
- **DO NOT:** Write the final implementation code yourself
- **DO NOT:** Stop at the first relevant file
```

**作用**：
- 明确期望行为
- 防止常见错误
- 引导深度分析

### 核心指令

```
<RULES>
1. DEEP ANALYSIS, NOT JUST FILE FINDING
   Your goal is to understand the *why* behind the code.
   
2. SYSTEMATIC & CURIOUS EXPLORATION
   Start with high-value clues and broaden your search.
   If you find something you don't understand, investigate it.
   
3. HOLISTIC & PRECISE
   Find the complete and minimal set of locations.
   Consider side effects of potential fixes.
   
4. WEB SEARCH
   You are allowed to use web_fetch to research libraries or concepts.
</RULES>
```

**作用**：
- 提供具体的操作指南
- 鼓励好奇心和深度
- 允许外部研究

### Scratchpad 管理

```
## Scratchpad Management

1. **Initialization:** On your very first turn, create the <scratchpad> section.
   Analyze the task and create an initial Checklist and Questions to Resolve.

2. **Constant Updates:** After **every** <OBSERVATION>, update the scratchpad.
   - Mark checklist items as complete: [x]
   - Add new checklist items
   - Log questions in Questions to Resolve
   - Record Key Findings
   - Update Irrelevant Paths to Ignore

3. **Thinking on Paper:** The scratchpad must show your reasoning process.
```

**作用**：
- 强制结构化思考
- 跟踪进度
- 记录决策过程

**示例 Scratchpad**：
```
<scratchpad>
Checklist:
[x] Search for 'auth' in file names
[x] Read src/auth/index.ts
[ ] Understand JWT token generation
[ ] Find session management code

Questions to Resolve:
[x] Where is the JWT secret stored? → Found in config/secrets.ts
[ ] How are refresh tokens handled?

Key Findings:
- Authentication uses JWT with 1-hour expiry
- Passwords hashed with bcrypt (10 rounds)
- Session data stored in Redis

Irrelevant Paths:
- tests/ (not implementation code)
- docs/ (documentation only)
</scratchpad>
```

### 终止条件

```
## Termination

Your mission is complete **ONLY** when:
- Your Questions to Resolve list is empty
- You have identified all files and necessary change considerations

When finished, call the complete_task tool with a valid JSON report.
```

**作用**：
- 明确完成标准
- 防止过早终止
- 确保输出格式

## 执行示例

### 场景：查找认证相关代码

#### 用户请求
```
主代理：Find all files related to user authentication
```

#### 子代理执行

**Turn 1: 初始化**
```
<scratchpad>
Checklist:
[ ] Search for 'auth' in file names
[ ] Search for 'login' in code
[ ] Find JWT-related code
[ ] Understand session management

Questions to Resolve:
[ ] What authentication method is used?
[ ] Where are credentials validated?
[ ] How are sessions managed?
</scratchpad>

I'll start by searching for authentication-related files.

Tool: glob
Args: { pattern: "**/*auth*" }
```

**Turn 2: 探索目录**
```
<scratchpad>
Checklist:
[x] Search for 'auth' in file names → Found src/auth/ directory
[ ] Explore src/auth/ structure
[ ] Search for 'login' in code
[ ] Find JWT-related code

Questions to Resolve:
[ ] What authentication method is used?
[ ] What files are in src/auth/?
</scratchpad>

Found src/auth/ directory. Let me explore its structure.

Tool: ls
Args: { path: "src/auth", recursive: true }
```

**Turn 3: 读取主文件**
```
<scratchpad>
Checklist:
[x] Search for 'auth' in file names
[x] Explore src/auth/ structure → Found index.ts, login.ts, jwt.ts
[ ] Read src/auth/index.ts
[ ] Search for 'login' in code

Questions to Resolve:
[x] What authentication method is used? → JWT (found jwt.ts)
[ ] How is JWT implemented?
</scratchpad>

Let me read the main auth module to understand the structure.

Tool: read_file
Args: { path: "src/auth/index.ts" }
```

**Turn 4-10: 深入分析**
```
[继续读取关键文件，搜索相关代码，解答问题]
```

**Turn 11: 完成**
```
<scratchpad>
Checklist:
[x] All items completed

Questions to Resolve:
[x] All questions resolved

Key Findings:
- JWT authentication with 1-hour expiry
- Passwords hashed with bcrypt
- Session data in Redis
- Refresh token mechanism implemented
</scratchpad>

All investigation complete. Generating final report.

Tool: complete_task
Args: {
  report: {
    "SummaryOfFindings": "...",
    "ExplorationTrace": [...],
    "RelevantLocations": [...]
  }
}
```

## 输出处理

```typescript
processOutput: (output) => JSON.stringify(output, null, 2)
```

**简单但有效**：
- 格式化 JSON 便于阅读
- 保留完整的结构化数据
- 主代理可以解析和使用

**主代理接收**：
```json
{
  "SummaryOfFindings": "认证系统使用 JWT...",
  "ExplorationTrace": ["使用 glob 搜索...", "读取 src/auth/index.ts..."],
  "RelevantLocations": [
    {
      "FilePath": "src/auth/login.ts",
      "Reasoning": "包含登录逻辑",
      "KeySymbols": ["loginHandler", "validateCredentials"]
    }
  ]
}
```

## 与主代理的集成

### 主代理的提示

```
## Available Tools

...

codebase_investigator:
  Your primary tool for multifile search tasks and codebase exploration.
  Use this to find features, understand context, or locate specific files.
  Returns a structured JSON report with key file paths and symbols.
```

### 使用场景

主代理会在以下情况使用：

1. **多文件搜索**
   ```
   用户：Where is the payment processing code?
   主代理：I'll use codebase_investigator to find it.
   ```

2. **架构理解**
   ```
   用户：How does the authentication system work?
   主代理：Let me investigate the auth architecture.
   ```

3. **影响分析**
   ```
   用户：If I change the User model, what else needs updating?
   主代理：I'll analyze the dependencies.
   ```

4. **Bug 定位**
   ```
   用户：There's a bug in the login flow.
   主代理：Let me find all related files first.
   ```

## 优化建议

### 1. 输出增强

可以添加更多字段：

```typescript
const EnhancedReportSchema = z.object({
  SummaryOfFindings: z.string(),
  ExplorationTrace: z.array(z.string()),
  RelevantLocations: z.array(z.object({
    FilePath: z.string(),
    Reasoning: z.string(),
    KeySymbols: z.array(z.string()),
    LineNumbers: z.array(z.number()).optional(),  // 新增
    Dependencies: z.array(z.string()).optional()   // 新增
  })),
  ArchitectureDiagram: z.string().optional(),      // 新增
  Recommendations: z.array(z.string()).optional()  // 新增
});
```

### 2. 工具扩展

可以添加更多工具：

```typescript
toolConfig: {
  tools: [
    LSTool.Name,
    ReadFileTool.Name,
    GLOB_TOOL_NAME,
    GrepTool.Name,
    'web_fetch',      // 研究库文档
    'git_log',        // 查看历史
    'dependency_graph' // 分析依赖
  ]
}
```

### 3. 提示优化

可以添加示例：

```typescript
promptConfig: {
  initialMessages: [
    {
      role: 'user',
      parts: [{ text: 'Find authentication code' }]
    },
    {
      role: 'model',
      parts: [{ text: `
<scratchpad>
Checklist:
[ ] Search for 'auth' files
...
</scratchpad>

I'll start with glob to find auth files.
      ` }]
    }
  ]
}
```

## 总结

`CodebaseInvestigatorAgent` 展示了子代理设计的最佳实践：

1. **清晰的职责**：专注于代码库分析
2. **结构化输出**：JSON Schema 确保一致性
3. **系统化方法**：Scratchpad 强制结构化思考
4. **适当的工具**：只读工具集合
5. **合理的限制**：超时和轮次保护
6. **深度分析**：低温度和无限思考预算

这个案例可以作为创建其他专业子代理的模板。
