# æ‰©å±•æŒ‡å—ï¼šåˆ›å»ºè‡ªå®šä¹‰å­ä»£ç†

## æ¦‚è¿°

æœ¬æŒ‡å—å°†æ‰‹æŠŠæ‰‹æ•™ä½ åˆ›å»ºè‡ªå®šä¹‰å­ä»£ç†ï¼Œä»ç®€å•åˆ°å¤æ‚ï¼Œæ¶µç›–æ‰€æœ‰å…³é”®æ­¥éª¤å’Œæœ€ä½³å®è·µã€‚

## å¿«é€Ÿå¼€å§‹

### æœ€å°åŒ–ç¤ºä¾‹

åˆ›å»ºä¸€ä¸ªæœ€ç®€å•çš„å­ä»£ç†ï¼š

```typescript
import { z } from 'zod';
import type { AgentDefinition } from './types.js';

export const SimpleAgent: AgentDefinition<z.ZodString> = {
  name: 'simple_agent',
  description: 'A simple example agent',
  
  inputConfig: {
    inputs: {
      task: {
        description: 'Task to perform',
        type: 'string',
        required: true
      }
    }
  },
  
  outputConfig: {
    outputName: 'result',
    description: 'The result',
    schema: z.string()
  },
  
  modelConfig: {
    model: 'gemini-2.5-flash',
    temp: 0.7,
    top_p: 0.95
  },
  
  runConfig: {
    max_time_minutes: 2,
    max_turns: 5
  },
  
  promptConfig: {
    query: 'Complete this task: ${task}',
    systemPrompt: `
      You are a helpful assistant.
      Complete the task and call complete_task with the result.
    `
  }
};
```

### æ³¨å†Œä»£ç†

```typescript
// packages/core/src/agents/registry.ts

import { SimpleAgent } from './simple-agent.js';

class AgentRegistry {
  private loadBuiltInAgents(): void {
    this.registerAgent(CodebaseInvestigatorAgent);
    this.registerAgent(SimpleAgent);  // æ·»åŠ è¿™è¡Œ
  }
}
```

### æµ‹è¯•ä»£ç†

```typescript
// åˆ›å»ºæµ‹è¯•æ–‡ä»¶
import { AgentExecutor } from './executor.js';
import { SimpleAgent } from './simple-agent.js';

async function testSimpleAgent() {
  const executor = await AgentExecutor.create(
    SimpleAgent,
    config,
    (activity) => console.log(activity)
  );
  
  const result = await executor.run(
    { task: 'Say hello' },
    new AbortController().signal
  );
  
  console.log(result);
}
```

## å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1ï¼šæ–‡æ¡£ç”Ÿæˆå™¨

åˆ›å»ºä¸€ä¸ªç”Ÿæˆ README æ–‡æ¡£çš„å­ä»£ç†ï¼š

```typescript
const ReadmeGeneratorSchema = z.object({
  title: z.string(),
  description: z.string(),
  sections: z.array(
    z.object({
      heading: z.string(),
      content: z.string()
    })
  ),
  badges: z.array(z.string()).optional()
});

export const ReadmeGeneratorAgent: AgentDefinition<
  typeof ReadmeGeneratorSchema
> = {
  name: 'readme_generator',
  displayName: 'README Generator',
  
  description: `
    Generates comprehensive README.md files for projects.
    Analyzes the codebase and creates well-structured documentation.
  `,
  
  inputConfig: {
    inputs: {
      project_path: {
        description: 'Path to the project root',
        type: 'string',
        required: true
      },
      include_badges: {
        description: 'Whether to include badges',
        type: 'boolean',
        required: false
      }
    }
  },
  
  outputConfig: {
    outputName: 'readme',
    description: 'Generated README structure',
    schema: ReadmeGeneratorSchema
  },
  
  processOutput: (output) => {
    // è½¬æ¢ä¸º Markdown
    let md = `# ${output.title}\n\n`;
    
    if (output.badges && output.badges.length > 0) {
      md += output.badges.join(' ') + '\n\n';
    }
    
    md += `${output.description}\n\n`;
    
    for (const section of output.sections) {
      md += `## ${section.heading}\n\n`;
      md += `${section.content}\n\n`;
    }
    
    return md;
  },
  
  modelConfig: {
    model: 'gemini-2.5-pro',
    temp: 0.5,
    top_p: 0.95,
    thinkingBudget: -1
  },
  
  runConfig: {
    max_time_minutes: 5,
    max_turns: 10
  },
  
  toolConfig: {
    tools: [
      'ls',
      'read_file',
      'glob',
      'grep'
    ]
  },
  
  promptConfig: {
    query: `
      Generate a comprehensive README for the project at: \${project_path}
      Include badges: \${include_badges || false}
    `,
    
    systemPrompt: `
      You are README Generator, an expert in creating excellent documentation.
      
      Your process:
      1. Explore the project structure
      2. Read key files (package.json, main source files)
      3. Identify the project's purpose and features
      4. Generate a well-structured README
      
      README should include:
      - Clear title and description
      - Installation instructions
      - Usage examples
      - API documentation (if applicable)
      - Contributing guidelines
      - License information
      
      Call complete_task with the structured README data.
    `
  }
};
```

### æ¡ˆä¾‹ 2ï¼šæµ‹è¯•ç”Ÿæˆå™¨

åˆ›å»ºä¸€ä¸ªç”Ÿæˆå•å…ƒæµ‹è¯•çš„å­ä»£ç†ï¼š

```typescript
const TestSuiteSchema = z.object({
  test_file_path: z.string(),
  test_framework: z.enum(['jest', 'vitest', 'mocha']),
  test_code: z.string(),
  test_cases: z.array(
    z.object({
      name: z.string(),
      description: z.string(),
      type: z.enum(['unit', 'integration', 'edge_case']),
      covers: z.array(z.string())
    })
  ),
  coverage_estimate: z.number().min(0).max(100),
  setup_required: z.string().optional(),
  mocks_needed: z.array(z.string()).optional()
});

export const TestGeneratorAgent: AgentDefinition<
  typeof TestSuiteSchema
> = {
  name: 'test_generator',
  displayName: 'Test Generator',
  
  description: `
    Generates comprehensive test suites for source files.
    Analyzes code structure and creates unit tests with edge cases.
    Supports Jest, Vitest, and Mocha frameworks.
  `,
  
  inputConfig: {
    inputs: {
      source_file: {
        description: 'Path to the source file to test',
        type: 'string',
        required: true
      },
      framework: {
        description: 'Testing framework (jest, vitest, mocha)',
        type: 'string',
        required: false
      },
      coverage_target: {
        description: 'Target code coverage percentage',
        type: 'integer',
        required: false
      }
    }
  },
  
  outputConfig: {
    outputName: 'test_suite',
    description: 'Generated test suite',
    schema: TestSuiteSchema
  },
  
  processOutput: (output) => {
    return `
# Test Suite Generated

**File:** ${output.test_file_path}
**Framework:** ${output.test_framework}
**Estimated Coverage:** ${output.coverage_estimate}%

## Test Cases (${output.test_cases.length})

${output.test_cases.map((tc, i) => `
${i + 1}. **${tc.name}** (${tc.type})
   - ${tc.description}
   - Covers: ${tc.covers.join(', ')}
`).join('\n')}

${output.setup_required ? `## Setup Required\n${output.setup_required}\n` : ''}
${output.mocks_needed ? `## Mocks Needed\n${output.mocks_needed.join(', ')}\n` : ''}

## Test Code

\`\`\`typescript
${output.test_code}
\`\`\`
    `;
  },
  
  modelConfig: {
    model: 'gemini-2.5-pro',
    temp: 0.3,
    top_p: 0.95,
    thinkingBudget: -1
  },
  
  runConfig: {
    max_time_minutes: 3,
    max_turns: 8
  },
  
  toolConfig: {
    tools: ['read_file', 'grep', 'glob']
  },
  
  promptConfig: {
    query: `
      Generate comprehensive tests for: \${source_file}
      Framework: \${framework || 'auto-detect'}
      Target coverage: \${coverage_target || 80}%
    `,
    
    systemPrompt: `
      You are Test Generator, an expert in writing comprehensive test suites.
      
      Your process:
      1. Read and analyze the source file
      2. Identify all functions, classes, methods
      3. Determine the testing framework (or use specified)
      4. Generate test cases covering:
         - Happy paths
         - Error conditions
         - Edge cases
         - Boundary values
      5. Write clean, maintainable test code
      6. Estimate code coverage
      
      Best practices:
      - Use descriptive test names
      - Group related tests
      - Mock external dependencies
      - Test one thing per test case
      - Include setup and teardown if needed
      
      Call complete_task with the complete test suite.
    `
  }
};
```

### æ¡ˆä¾‹ 3ï¼šä»£ç å®¡æŸ¥å™¨

åˆ›å»ºä¸€ä¸ªä»£ç å®¡æŸ¥å­ä»£ç†ï¼š

```typescript
const CodeReviewSchema = z.object({
  overall_score: z.number().min(0).max(10),
  summary: z.string(),
  issues: z.array(
    z.object({
      severity: z.enum(['critical', 'major', 'minor', 'suggestion']),
      category: z.enum([
        'bug',
        'security',
        'performance',
        'maintainability',
        'style'
      ]),
      file: z.string(),
      line: z.number().optional(),
      description: z.string(),
      suggestion: z.string()
    })
  ),
  strengths: z.array(z.string()),
  recommendations: z.array(z.string())
});

export const CodeReviewerAgent: AgentDefinition<
  typeof CodeReviewSchema
> = {
  name: 'code_reviewer',
  displayName: 'Code Reviewer',
  
  description: `
    Performs comprehensive code reviews.
    Identifies bugs, security issues, performance problems, and style violations.
    Provides actionable recommendations.
  `,
  
  inputConfig: {
    inputs: {
      files: {
        description: 'Comma-separated list of files to review',
        type: 'string',
        required: true
      },
      focus_areas: {
        description: 'Specific areas to focus on (security, performance, etc.)',
        type: 'string',
        required: false
      }
    }
  },
  
  outputConfig: {
    outputName: 'review',
    description: 'Code review report',
    schema: CodeReviewSchema
  },
  
  processOutput: (output) => {
    const severityEmoji = {
      critical: 'ğŸ”´',
      major: 'ğŸŸ ',
      minor: 'ğŸŸ¡',
      suggestion: 'ğŸ’¡'
    };
    
    let report = `# Code Review Report\n\n`;
    report += `**Overall Score:** ${output.overall_score}/10\n\n`;
    report += `## Summary\n${output.summary}\n\n`;
    
    if (output.strengths.length > 0) {
      report += `## Strengths âœ…\n`;
      output.strengths.forEach(s => report += `- ${s}\n`);
      report += '\n';
    }
    
    if (output.issues.length > 0) {
      report += `## Issues Found (${output.issues.length})\n\n`;
      
      const grouped = output.issues.reduce((acc, issue) => {
        if (!acc[issue.severity]) acc[issue.severity] = [];
        acc[issue.severity].push(issue);
        return acc;
      }, {} as Record<string, typeof output.issues>);
      
      for (const [severity, issues] of Object.entries(grouped)) {
        report += `### ${severityEmoji[severity as keyof typeof severityEmoji]} ${severity.toUpperCase()}\n\n`;
        issues.forEach((issue, i) => {
          report += `${i + 1}. **[${issue.category}]** ${issue.file}`;
          if (issue.line) report += `:${issue.line}`;
          report += `\n   - ${issue.description}\n`;
          report += `   - ğŸ’¡ ${issue.suggestion}\n\n`;
        });
      }
    }
    
    if (output.recommendations.length > 0) {
      report += `## Recommendations\n`;
      output.recommendations.forEach(r => report += `- ${r}\n`);
    }
    
    return report;
  },
  
  modelConfig: {
    model: 'gemini-2.5-pro',
    temp: 0.2,
    top_p: 0.95,
    thinkingBudget: -1
  },
  
  runConfig: {
    max_time_minutes: 10,
    max_turns: 20
  },
  
  toolConfig: {
    tools: ['read_file', 'grep', 'glob']
  },
  
  promptConfig: {
    query: `
      Review these files: \${files}
      ${'\${focus_areas ? `Focus on: \${focus_areas}` : ""}'}
    `,
    
    systemPrompt: `
      You are Code Reviewer, an expert in software quality and best practices.
      
      Review checklist:
      
      **Security:**
      - SQL injection vulnerabilities
      - XSS vulnerabilities
      - Insecure dependencies
      - Hardcoded secrets
      - Improper authentication/authorization
      
      **Bugs:**
      - Logic errors
      - Null pointer exceptions
      - Race conditions
      - Off-by-one errors
      - Resource leaks
      
      **Performance:**
      - Inefficient algorithms
      - Unnecessary loops
      - Memory leaks
      - Blocking operations
      - Missing caching
      
      **Maintainability:**
      - Code duplication
      - Complex functions
      - Poor naming
      - Missing documentation
      - Tight coupling
      
      **Style:**
      - Inconsistent formatting
      - Unused imports
      - Magic numbers
      - Long functions
      
      For each issue:
      1. Identify the severity
      2. Categorize it
      3. Explain the problem
      4. Suggest a fix
      
      Also note strengths and provide overall recommendations.
      
      Call complete_task with the complete review.
    `
  }
};
```

## é«˜çº§æŠ€å·§

### 1. ä½¿ç”¨ initialMessages æä¾›ç¤ºä¾‹

```typescript
promptConfig: {
  initialMessages: [
    {
      role: 'user',
      parts: [{ text: 'Analyze this code: function add(a, b) { return a + b; }' }]
    },
    {
      role: 'model',
      parts: [{ text: `
<analysis>
Function: add
Parameters: a, b
Returns: sum of a and b
Complexity: O(1)
Issues: None
Suggestions: Add type annotations
</analysis>

This is a simple addition function. Let me provide the analysis.

Tool: complete_task
Args: { analysis: "..." }
      ` }]
    }
  ]
}
```

### 2. åŠ¨æ€å·¥å…·é€‰æ‹©

```typescript
// æ ¹æ®è¾“å…¥åŠ¨æ€é€‰æ‹©å·¥å…·
static getToolsForTask(task: string): string[] {
  if (task.includes('test')) {
    return ['read_file', 'grep', 'glob'];
  } else if (task.includes('document')) {
    return ['read_file', 'ls', 'glob'];
  } else {
    return ['read_file', 'grep', 'ls', 'glob'];
  }
}
```

### 3. å¤šé˜¶æ®µè¾“å‡º

```typescript
const MultiStageSchema = z.object({
  stage1_analysis: z.object({
    files_found: z.array(z.string()),
    initial_findings: z.string()
  }),
  stage2_deep_dive: z.object({
    detailed_analysis: z.string(),
    code_snippets: z.array(z.string())
  }),
  stage3_recommendations: z.object({
    action_items: z.array(z.string()),
    priority: z.enum(['high', 'medium', 'low'])
  })
});
```

### 4. é”™è¯¯æ¢å¤

```typescript
systemPrompt: `
  ...
  
  If you encounter an error:
  1. Log it in your scratchpad
  2. Try an alternative approach
  3. If all approaches fail, document the issue
  4. Still call complete_task with partial results
  
  Example:
  <scratchpad>
  Error: File not found: src/missing.ts
  Alternative: Search for similar files
  Result: Found src/alternative.ts instead
  </scratchpad>
`
```

### 5. è¿›åº¦æŠ¥å‘Š

```typescript
// åœ¨ SubagentInvocation ä¸­
const onActivity = (activity: SubagentActivityEvent) => {
  if (activity.type === 'THOUGHT_CHUNK') {
    // è§£æè¿›åº¦
    const text = activity.data['text'] as string;
    if (text.includes('Progress:')) {
      const match = text.match(/Progress: (\d+)%/);
      if (match) {
        updateOutput?.(`â³ ${match[1]}% complete`);
      }
    }
  }
};
```

## æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

```typescript
describe('MyAgent', () => {
  it('should have valid definition', () => {
    expect(MyAgent.name).toBe('my_agent');
    expect(MyAgent.inputConfig.inputs).toBeDefined();
    expect(MyAgent.outputConfig).toBeDefined();
  });
  
  it('should generate valid schema', () => {
    const schema = convertInputConfigToJsonSchema(MyAgent.inputConfig);
    expect(schema.type).toBe('object');
    expect(schema.properties).toBeDefined();
  });
});
```

### é›†æˆæµ‹è¯•

```typescript
describe('MyAgent execution', () => {
  it('should complete successfully', async () => {
    const executor = await AgentExecutor.create(
      MyAgent,
      testConfig,
      undefined
    );
    
    const result = await executor.run(
      { task: 'test task' },
      new AbortController().signal
    );
    
    expect(result.terminate_reason).toBe(AgentTerminateMode.GOAL);
    expect(result.result).toBeDefined();
  });
  
  it('should timeout if too long', async () => {
    const slowAgent = {
      ...MyAgent,
      runConfig: { max_time_minutes: 0.01, max_turns: 100 }
    };
    
    const executor = await AgentExecutor.create(slowAgent, testConfig);
    const result = await executor.run({ task: 'slow task' }, signal);
    
    expect(result.terminate_reason).toBe(AgentTerminateMode.TIMEOUT);
  });
});
```

### E2E æµ‹è¯•

```typescript
describe('MyAgent end-to-end', () => {
  it('should work with real codebase', async () => {
    const wrapper = new SubagentToolWrapper(MyAgent, config);
    const invocation = wrapper.build({ task: 'analyze src/' });
    
    const result = await invocation.execute(signal);
    
    expect(result.llmContent).toBeDefined();
    expect(result.error).toBeUndefined();
  });
});
```

## è°ƒè¯•æŠ€å·§

### 1. å¯ç”¨è¯¦ç»†æ—¥å¿—

```typescript
modelConfig: {
  model: 'gemini-2.5-pro',
  temp: 0.1,
  top_p: 0.95,
  thinkingBudget: -1  // å…è®¸çœ‹åˆ°å®Œæ•´æ€è€ƒè¿‡ç¨‹
}
```

### 2. æ·»åŠ è°ƒè¯•è¾“å‡º

```typescript
const onActivity = (activity: SubagentActivityEvent) => {
  console.log('[DEBUG]', activity.type, activity.data);
  
  if (activity.type === 'TOOL_CALL_START') {
    console.log('Calling tool:', activity.data['name']);
    console.log('With args:', activity.data['args']);
  }
};
```

### 3. æ£€æŸ¥ Scratchpad

```typescript
systemPrompt: `
  ...
  
  IMPORTANT: Always show your scratchpad in your responses.
  This helps with debugging and understanding your thought process.
`
```

### 4. æ¨¡æ‹Ÿæ‰§è¡Œ

```typescript
// åˆ›å»ºæ¨¡æ‹Ÿå·¥å…·
const mockTools = {
  read_file: async (args) => ({ content: 'mock content' }),
  grep: async (args) => ({ matches: ['mock match'] })
};

// æµ‹è¯•æç¤ºè€Œä¸å®é™…æ‰§è¡Œ
```

## æ€§èƒ½ä¼˜åŒ–

### 1. é€‰æ‹©åˆé€‚çš„æ¨¡å‹

```typescript
// ç®€å•ä»»åŠ¡
modelConfig: {
  model: 'gemini-2.5-flash',  // æ›´å¿«
  temp: 0.5,
  top_p: 0.95
}

// å¤æ‚ä»»åŠ¡
modelConfig: {
  model: 'gemini-2.5-pro',    // æ›´å¼º
  temp: 0.1,
  top_p: 0.95
}
```

### 2. é™åˆ¶å·¥å…·é›†

```typescript
// åªæˆäºˆå¿…è¦çš„å·¥å…·
toolConfig: {
  tools: ['read_file', 'grep']  // ä¸è¦åŒ…å«ä¸éœ€è¦çš„å·¥å…·
}
```

### 3. è®¾ç½®åˆç†çš„è¶…æ—¶

```typescript
runConfig: {
  max_time_minutes: 3,  // æ ¹æ®ä»»åŠ¡å¤æ‚åº¦è°ƒæ•´
  max_turns: 10         // é˜²æ­¢æ— é™å¾ªç¯
}
```

### 4. ä¼˜åŒ–æç¤º

```typescript
systemPrompt: `
  Be concise and efficient.
  
  - Use glob before grep (faster)
  - Read only necessary files
  - Stop when you have enough information
  - Don't repeat searches
`
```

## éƒ¨ç½²æ¸…å•

- [ ] å®šä¹‰æ¸…æ™°çš„ `AgentDefinition`
- [ ] ç¼–å†™è¯¦ç»†çš„ `systemPrompt`
- [ ] è®¾è®¡åˆç†çš„è¾“å…¥è¾“å‡º Schema
- [ ] é€‰æ‹©åˆé€‚çš„å·¥å…·é›†
- [ ] è®¾ç½®é€‚å½“çš„è¶…æ—¶å’Œè½®æ¬¡é™åˆ¶
- [ ] å®ç° `processOutput` å‡½æ•°
- [ ] åœ¨ `AgentRegistry` ä¸­æ³¨å†Œ
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] ç¼–å†™é›†æˆæµ‹è¯•
- [ ] æµ‹è¯•è¾¹ç•Œæƒ…å†µ
- [ ] æµ‹è¯•é”™è¯¯å¤„ç†
- [ ] ä¼˜åŒ–æ€§èƒ½
- [ ] ç¼–å†™æ–‡æ¡£
- [ ] æ·»åŠ ä½¿ç”¨ç¤ºä¾‹

## æ€»ç»“

åˆ›å»ºè‡ªå®šä¹‰å­ä»£ç†çš„å…³é”®æ­¥éª¤ï¼š

1. **å®šä¹‰æ¸…æ™°çš„èŒè´£**ï¼šå­ä»£ç†åº”è¯¥ä¸“æ³¨äºä¸€ä¸ªç‰¹å®šä»»åŠ¡
2. **è®¾è®¡ç»“æ„åŒ–è¾“å‡º**ï¼šä½¿ç”¨ Zod Schema ç¡®ä¿ç±»å‹å®‰å…¨
3. **ç¼–å†™è¯¦ç»†çš„æç¤º**ï¼šç³»ç»Ÿæç¤ºæ˜¯è¡Œä¸ºçš„æ ¸å¿ƒ
4. **é€‰æ‹©åˆé€‚çš„å·¥å…·**ï¼šåªæˆäºˆå¿…è¦çš„å·¥å…·
5. **è®¾ç½®åˆç†çš„é™åˆ¶**ï¼šè¶…æ—¶å’Œè½®æ¬¡ä¿æŠ¤
6. **å……åˆ†æµ‹è¯•**ï¼šå•å…ƒã€é›†æˆã€E2E æµ‹è¯•
7. **ä¼˜åŒ–æ€§èƒ½**ï¼šé€‰æ‹©åˆé€‚çš„æ¨¡å‹å’Œå‚æ•°
8. **ç¼–å†™æ–‡æ¡£**ï¼šå¸®åŠ©å…¶ä»–äººä½¿ç”¨

éµå¾ªè¿™äº›åŸåˆ™ï¼Œä½ å°±èƒ½åˆ›å»ºåŠŸèƒ½å¼ºå¤§ã€è¡Œä¸ºå¯æ§çš„å­ä»£ç†ï¼
