# 执行流展示 - 实现总结

> 本文档描述执行流展示功能的**实际实现**，包含数据流动、核心组件、渲染逻辑等。

## 1. 架构概述

执行流展示采用 **消息持久化** 架构，工具调用和思考内容作为独立消息类型存储在 Store 中。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              Core 层                                     │
│  ┌──────────────────┐    ┌───────────────────────────────────────────┐  │
│  │ executeToolLoop  │───▶│     ExecutionStreamManager                │  │
│  │   (工具循环)     │    │  - 收集执行状态                           │  │
│  └──────────────────┘    │  - 发射事件 (tool:start, thinking:complete)│  │
│                          └───────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
                                      │
                               事件传递 (ExecutionEvent)
                                      ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                              CLI 层                                      │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                   ExecutionContext                                 │  │
│  │  - bindManager: 绑定 Core 的 ExecutionStreamManager               │  │
│  │  - subscribe: 允许组件订阅事件                                     │  │
│  │  - snapshot: 当前执行快照                                          │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                      │                                   │
│                               事件转发                                   │
│                                      ▼                                   │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │               useExecutionMessages Hook                            │  │
│  │  - 监听 tool:start → 创建 tool 消息                               │  │
│  │  - 监听 tool:complete → 更新 tool 消息状态                        │  │
│  │  - 监听 thinking:complete → 创建 thinking 消息（推理模型）        │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                      │                                   │
│                            消息存储/更新                                 │
│                                      ▼                                   │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                       Zustand Store                                │  │
│  │  messages: {                                                       │  │
│  │    [sessionId]: [                                                  │  │
│  │      { role: 'user', content: '...' },                            │  │
│  │      { role: 'tool', toolCall: {...} },  // 工具消息              │  │
│  │      { role: 'thinking', content: '...' }, // 思考消息            │  │
│  │      { role: 'assistant', content: '...' },                       │  │
│  │    ]                                                               │  │
│  │  }                                                                 │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                      │                                   │
│                              渲染消息                                    │
│                                      ▼                                   │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                    Session 页面渲染                                │  │
│  │  <Static items={messages}>                                         │  │
│  │    role='user'     → <UserMessage />                              │  │
│  │    role='tool'     → <ToolMessage />                              │  │
│  │    role='thinking' → <ThinkingMessage />                          │  │
│  │    role='assistant'→ <AssistantMessage />                         │  │
│  │  </Static>                                                         │  │
│  │  {isExecuting && <ExecutionStream />}  // 状态指示器              │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

## 2. 核心数据类型

### 2.1 消息类型 (CLI Store)

```typescript
// packages/cli/src/context/store.tsx

// 消息角色
type MessageRole = 'user' | 'assistant' | 'tool' | 'thinking';

// 工具调用状态
type ToolCallStatus = 'executing' | 'success' | 'error';

// 工具调用信息
interface ToolCallInfo {
  toolName: string;           // 工具名称
  toolCategory: string;       // 工具分类
  params: Record<string, any>;// 参数
  paramsSummary: string;      // 参数摘要（显示用）
  status: ToolCallStatus;     // 执行状态
  resultSummary?: string;     // 结果摘要（显示用）
  duration?: number;          // 执行耗时(ms)
  error?: string;             // 错误信息
  thinkingContent?: string;   // 工具调用前的思考内容（LLM content）
}

// 消息结构
interface Message {
  id: string;
  sessionId: string;
  role: MessageRole;
  content: string;
  timestamp: number;
  isStreaming?: boolean;
  metadata?: MessageMetadata;
  toolCall?: ToolCallInfo;    // 仅 role='tool' 时有
}
```

### 2.2 Core 层类型

```typescript
// packages/core/src/core/execution/types.ts

// 工具调用记录（包含 thinkingContent）
interface ToolCallRecord {
  id: string;
  toolName: string;
  toolCategory: string;
  params: Record<string, any>;
  paramsSummary: string;
  status: ToolCallStatus;
  startTime: number;
  endTime?: number;
  duration?: number;
  result?: any;
  resultSummary?: string;
  error?: string;
  liveOutput?: string;
  thinkingContent?: string;   // 新增：工具调用前的思考内容
}

// LLM 响应（包含 reasoningContent）
interface LLMResponse {
  content: string;            // 普通内容
  reasoningContent?: string;  // 推理模型的思考内容
  toolCalls?: ToolCall[];
  finishReason?: string;
  usage?: { ... };
}
```

## 3. 数据流动详解

### 3.1 工具调用流程

```
1. LLM 返回 response（可能包含 content + toolCalls）
   │
   ├─▶ response.content（工具调用前的思考）
   │   └─▶ 作为 thinkingContent 传给第一个工具
   │
   └─▶ response.toolCalls（工具调用列表）
       │
       ├─▶ executeToolLoop 调用 startToolCall({...thinkingContent})
       │   │
       │   └─▶ ExecutionStreamManager 发射 tool:start 事件
       │       │
       │       └─▶ useExecutionMessages 收到事件
       │           │
       │           └─▶ 创建 tool 消息（包含 thinkingContent）
       │               │
       │               └─▶ Store.insertMessageBefore(assistantPlaceholder)
       │
       ├─▶ toolManager.execute() 执行工具
       │
       └─▶ executeToolLoop 调用 completeToolCall()
           │
           └─▶ ExecutionStreamManager 发射 tool:complete 事件
               │
               └─▶ useExecutionMessages 收到事件
                   │
                   └─▶ 更新 tool 消息状态（success/error + resultSummary）
```

### 3.2 思考内容流程（推理模型）

```
1. LLM 返回 response（包含 reasoningContent）
   │
   └─▶ response.reasoningContent（推理模型的完整思考）
       │
       └─▶ executeToolLoop 调用 completeThinking(reasoningContent)
           │
           └─▶ ExecutionStreamManager 发射 thinking:complete 事件
               │
               └─▶ useExecutionMessages 收到事件
                   │
                   └─▶ 只有 content 非空时才创建 thinking 消息
                       │
                       └─▶ Store.insertMessageBefore(assistantPlaceholder)
```

### 3.3 两种思考内容的区别

| 字段 | 来源 | 何时有值 | 显示方式 |
|------|------|---------|---------|
| `response.content`（工具调用时）| 所有模型 | 工具调用时可能有 | 灰色文字，在 ToolMessage 上方 |
| `response.reasoningContent` | 推理模型 | 总是有（推理模型）| 独立 ThinkingMessage，可折叠 |

## 4. 核心组件

### 4.1 Core 层组件

| 文件 | 职责 |
|------|------|
| `ExecutionStreamManager.ts` | 管理执行状态、发射事件 |
| `executeToolLoop.ts` | 工具循环执行器，调用 startToolCall/completeToolCall |
| `summaryGenerators.ts` | 生成工具结果摘要（如 "Read 156 lines"） |

### 4.2 CLI 层组件

| 文件 | 职责 |
|------|------|
| `context/execution.tsx` | ExecutionContext，绑定 Manager、转发事件 |
| `context/store.tsx` | Zustand Store，存储 messages |
| `hooks/useExecutionMessages.ts` | 监听事件、创建/更新消息 |
| `component/message-area/tool-message.tsx` | 渲染工具消息 |
| `component/message-area/thinking-message.tsx` | 渲染思考消息（可折叠）|
| `component/execution/StatusIndicator.tsx` | 状态指示器（Spinner + 状态词）|
| `component/execution/ExecutionStream.tsx` | 执行流主组件（只含 StatusIndicator）|
| `routes/session/index.tsx` | Session 页面，渲染所有消息 |

## 5. 渲染逻辑

### 5.1 Session 页面消息渲染

```tsx
// packages/cli/src/routes/session/index.tsx

<Static items={completedMessages}>
  {(message) => {
    switch (message.role) {
      case 'user':
        return <UserMessage message={message} />;
      case 'assistant':
        return <AssistantMessage message={message} />;
      case 'tool':
        return <ToolMessage message={message} />;
      case 'thinking':
        return <ThinkingMessage message={message} />;
    }
  }}
</Static>

{/* 执行中显示状态指示器 */}
{isExecuting && <ExecutionStream />}

{/* 流式消息 */}
{streamingMessage && <AssistantMessage message={streamingMessage} />}
```

### 5.2 ToolMessage 组件

```tsx
// packages/cli/src/component/message-area/tool-message.tsx

function ToolMessage({ message }) {
  const { toolCall } = message;

  return (
    <Box flexDirection="column">
      {/* 思考内容（如果有） */}
      {toolCall.thinkingContent && (
        <Text color={colors.text}>{toolCall.thinkingContent}</Text>
      )}

      {/* 工具状态：● read_file (src/index.ts) · 120ms */}
      <Box>
        <Text color={statusColor}>{icon}</Text>
        <Text bold>{toolCall.toolName}</Text>
        <Text dimColor>({toolCall.paramsSummary})</Text>
        {toolCall.duration && <Text dimColor>· {duration}ms</Text>}
      </Box>

      {/* 结果：└ Read 156 lines */}
      <Box paddingLeft={2}>
        <Text>└ {toolCall.resultSummary || 'completed'}</Text>
      </Box>
    </Box>
  );
}
```

### 5.3 ThinkingMessage 组件

```tsx
// packages/cli/src/component/message-area/thinking-message.tsx

function ThinkingMessage({ message }) {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <Box flexDirection="column">
      {/* 标题：Thinking · (15 lines) */}
      <Text italic color={colors.textMuted}>
        Thinking {shouldCollapse && `· (${lines.length} lines)`}
      </Text>

      {/* 内容（展开/折叠） */}
      <Box paddingLeft={2}>
        <Text dimColor>{isExpanded ? fullContent : preview}</Text>
      </Box>

      {/* 展开提示 */}
      {shouldCollapse && <Text>[expand]</Text>}
    </Box>
  );
}
```

## 6. 事件类型

```typescript
// packages/core/src/core/execution/events.ts

type ExecutionEvent =
  // 生命周期
  | { type: 'execution:start'; timestamp: number }
  | { type: 'execution:complete'; stats: ExecutionStats }
  | { type: 'execution:error'; error: string }
  | { type: 'execution:cancel' }

  // 状态
  | { type: 'state:change'; state: ExecutionState; phrase: string }

  // 思考（推理模型）
  | { type: 'thinking:start' }
  | { type: 'thinking:delta'; delta: string }
  | { type: 'thinking:complete'; content: string }

  // 工具
  | { type: 'tool:start'; toolCall: ToolCallRecord }
  | { type: 'tool:output'; toolCallId: string; output: string }
  | { type: 'tool:complete'; toolCall: ToolCallRecord }
  | { type: 'tool:error'; toolCallId: string; error: string }

  // 流式输出
  | { type: 'content:delta'; delta: string }
  | { type: 'content:complete'; content: string }

  // Token 统计
  | { type: 'stats:update'; stats: Partial<ExecutionStats> };
```

## 7. 消息插入顺序

使用 `insertMessageBefore` 确保消息按正确顺序显示：

```
执行前：
[user] 用户输入
[assistant] (占位，流式中)

执行中：
[user] 用户输入
[tool] ○ read_file (执行中)     ← insertMessageBefore(assistant)
[assistant] (占位，流式中)

工具完成后：
[user] 用户输入
[tool] ● read_file (成功)       ← updateMessage
[assistant] (占位，流式中)

最终：
[user] 用户输入
[tool] ● read_file (成功)
[assistant] 最终回答
```

## 8. 关键实现细节

### 8.1 防止重复消息

`useExecutionMessages` 使用 `toolMessageMapRef` 跟踪已创建的消息：

```typescript
const toolMessageMapRef = useRef<Map<string, string>>(new Map());

// tool:start 时创建并记录
toolMessageMapRef.current.set(toolCall.id, message.id);

// tool:complete 时查找并更新
const messageId = toolMessageMapRef.current.get(toolCall.id);
if (messageId) {
  updateMessage(sessionId, messageId, {...});
}
```

### 8.2 使用 Ref 避免依赖问题

```typescript
const optionsRef = useRef(options);
optionsRef.current = options;

useEffect(() => {
  const handleEvent = (event) => {
    // 使用 optionsRef.current 获取最新值
    const { sessionId } = optionsRef.current;
    // ...
  };
}, [subscribe]); // 只依赖 subscribe
```

### 8.3 Chat 模型 vs 推理模型

```typescript
// executeToolLoop.ts

// Chat 模型：content 可能在工具调用时有值
const thinkingContent = response.content?.trim() || undefined;
// → 传给第一个工具的 thinkingContent

// 推理模型：reasoningContent 总是有值
executionStream?.completeThinking(response.reasoningContent);
// → 触发 thinking:complete 事件，创建独立 thinking 消息
```

## 9. 文件目录结构

```
packages/
├── core/src/core/
│   ├── execution/
│   │   ├── ExecutionStreamManager.ts  # 执行流管理器
│   │   ├── types.ts                   # 类型定义
│   │   ├── events.ts                  # 事件类型
│   │   ├── summaryGenerators.ts       # 摘要生成器
│   │   └── index.ts                   # 导出
│   └── llm/
│       ├── types/index.ts             # LLMResponse 类型
│       ├── services/DeepSeekService.ts # 提取 reasoning_content
│       └── utils/executeToolLoop.ts   # 工具循环（核心）
│
└── cli/src/
    ├── context/
    │   ├── execution.tsx              # ExecutionContext
    │   └── store.tsx                  # Zustand Store (Message 类型)
    ├── hooks/
    │   └── useExecutionMessages.ts    # 事件监听 → 消息创建
    ├── component/
    │   ├── execution/
    │   │   ├── ExecutionStream.tsx    # 执行流主组件
    │   │   ├── StatusIndicator.tsx    # 状态指示器
    │   │   └── index.ts               # 导出
    │   └── message-area/
    │       ├── tool-message.tsx       # 工具消息渲染
    │       ├── thinking-message.tsx   # 思考消息渲染
    │       ├── assistant-message.tsx  # 助手消息渲染
    │       └── user-message.tsx       # 用户消息渲染
    └── routes/session/
        └── index.tsx                  # Session 页面
```

## 10. 与原文档的主要差异

| 原文档设计 | 实际实现 |
|-----------|---------|
| ExecutionStream 组件渲染工具调用 | 工具调用作为独立消息，由 ToolMessage 渲染 |
| ToolCallGroup 组件 | 未实现，每个工具调用是独立消息 |
| ThinkingDisplay 在 ExecutionStream 中 | ThinkingMessage 作为独立消息组件 |
| 实时更新 snapshot 来显示工具调用 | 消息持久化到 Store，通过事件创建/更新 |
| completeThinking() 无参数 | completeThinking(content?) 支持传入内容 |
| 无 thinkingContent 字段 | ToolCallRecord 新增 thinkingContent 字段 |
| 无 reasoningContent 字段 | LLMResponse 新增 reasoningContent 字段 |

## 11. 扩展点

### 11.1 支持流式 thinking

```typescript
// 当前：thinking:delta 事件未处理
// 扩展：可以实时更新 thinking 消息内容
case 'thinking:delta': {
  const { delta } = event;
  if (thinkingMessageIdRef.current) {
    // 追加内容
    const current = getMessageById(thinkingMessageIdRef.current);
    updateMessage(sessionId, thinkingMessageIdRef.current, {
      content: current.content + delta,
    });
  }
  break;
}
```

### 11.2 工具实时输出

```typescript
// 当前：tool:output 事件未处理
// 扩展：可以实时显示长时间运行工具的输出
case 'tool:output': {
  const { toolCallId, output } = event;
  const messageId = toolMessageMapRef.current.get(toolCallId);
  if (messageId) {
    updateMessage(sessionId, messageId, {
      toolCall: { liveOutput: output },
    });
  }
  break;
}
```
