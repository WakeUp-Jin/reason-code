# Glob vs ripgrep：文件枚举 + mtime 的性能与一致性笔记（给重构用）

关联脚本：`packages/core/src/core/tool/__tests__/glob-ripgrep-performance.test.cjs`

## 1. 想解决的问题

在同一个仓库、同一组候选文件下，对“**枚举文件路径 → 获取 mtime → 按最近优先排序**”这条链路，比较两种实现：

- `glob`（npm 包）直接遍历/匹配文件，并在遍历阶段/结果里附带 `stat` 信息
- `ripgrep`：`rg --files` 负责快速枚举文件路径，再对路径做 `stat` 和排序

本文只讨论“搜索效率/搜索时间”（性能），并标出会影响“结果一致性”的关键差异点，方便重构时做取舍。

## 2. 结论（可直接落地的策略）

- **优先用 `ripgrep (rg --files)`，不可用则 fallback `glob`**：兼顾性能和可用性，且行为可控。
- **Bun 不是 ripgrep 的前置条件**：`rg` 本身是独立二进制，Node 下同样能跑；运行时差异主要在后续 `stat` 实现/成本。
- **很多场景下总耗时会“看起来差不多”**：当你后续对每个文件都要做 `stat/读取/解析` 时，整体瓶颈往往在“单文件处理”，而不在“枚举文件路径”。

## 3. 为什么 `rg` 更快但总时间可能接近

把链路拆开看：

```
总耗时 ≈ 枚举文件路径(list) + 单文件处理(stat/读取/解析) * N + 排序(sort)
```

- `rg --files` 通常在“list 阶段”明显更快（Rust 实现、遍历/过滤更高效）。
- 但如果最终必须对 `N` 个文件做 `stat`（甚至读文件内容），那么 `N * 单文件处理` 会成为主导项，前面 “list 更快” 的优势会被稀释，表现为“两者差距不大”。

在当前对比脚本里还有一个容易忽略的点：

- `rg` 方案会在到达 `--limit` 后**提前停止**枚举，并只对这 `limit` 个文件 `stat`
- `glob` 方案使用了 `stat: true`，在匹配集很大时，可能已经对**大量/全量**候选文件做过 `stat`，即使你后面只取 `limit` 个也省不掉这部分成本

因此：

- **匹配集很大且你只要 `limit` 个**：`rg` 方案往往更占优
- **匹配集不大或后处理很重**：两者的总时间可能接近

## 4. “相同文件集合”必须先对齐（否则性能和结果都不具可比性）

如果你说的“相同的文件下”是指候选文件集合一致，需要明确并对齐以下行为：

### 4.1 ignore 规则

- `rg` 默认遵守：`.gitignore` / `.ignore` / `.rgignore` 等（以及一些内置过滤规则）
- `glob`（当前脚本/常见用法）通常只靠 `ignore: ["**/node_modules/**", ...]`

重构时建议二选一并写死为“产品语义”：

1) **跟随仓库 ignore（推荐）**：更符合用户预期，也能减少枚举量  
2) **完全不跟随 ignore**：结果更“全”，但成本更高，也更容易扫到不该扫的目录

如果选 2)，需要考虑为 `rg` 明确加上 `--no-ignore`（以及对应的 `--no-ignore-parent` 等细项），否则两端永远不一致。

### 4.2 隐藏文件/目录（dotfiles）

- `rg`：需要 `--hidden` 才会包含隐藏项（但仍受 ignore 影响）
- `glob`：对应 `dot: true/false`

### 4.3 软链接与循环

- `glob` 这类库通常有 `follow` 等选项
- `rg` 对待 symlink 的默认策略不同，且会影响遍历量与结果

如果你想严格一致，需明确是否跟随 symlink，并在两端实现一致的策略。

### 4.4 glob 语义差异

`glob` 的 `**/*` 和 `rg --glob=...` 的匹配语义在一些边界情况不完全等价（路径分隔符、特殊字符、平台差异等）。重构时要么：

- 只支持“共同子集”的 pattern（并在文档里声明）
- 或在 `rg` 模式下用更严格/更受控的 pattern 转换（避免出现诡异不一致）

## 5. `limit` 与“最近 N 个文件”的正确性（容易踩坑）

如果目标是：**全量候选里找 mtime 最近的 N 个**，那么“先枚举到 N 个就停，再 stat+sort”在逻辑上是不严格正确的，因为：

- 枚举顺序（目录遍历顺序）并不等于 mtime 的先后顺序
- 提前截断会错过后面更“新”的文件

两种可选产品语义：

- **近似**（更快）：只保证“从枚举到的前 N 个里取最近”，接受漏掉更近文件
- **严格**（更正确）：遍历全量候选，对全量做 `stat`，最后取 top N（可用小顶堆/选择算法避免全量排序）

建议重构前先决定到底要哪一种，并在接口/文档里写清楚。

## 6. 并发 `stat`：决定上限的往往不是语言而是 IO

无论 Bun 还是 Node，`stat` 都会触发大量文件系统调用，性能主要受限于：

- 文件系统元数据吞吐（SSD/HDD、APFS/NTFS、网络盘等）
- OS 调度与缓存命中
- 并发度设置（过高会导致抖动/放大尾延迟）

实践建议：

- 默认并发不要太激进；先提供一个可配置项（例如 `statConcurrency`）
- 用基准脚本在你的典型项目规模下选一个“稳定”的默认值

## 7. 推荐的实现策略（明天重构的落点）

### 7.1 策略选择

1) 探测 `rg` 是否可用（存在且可执行）  
2) 可用：走 `rg --files` → 产出候选路径 → `stat` → 排序/截断  
3) 不可用：走 `glob` → 产出候选路径/mtime → 排序/截断  

### 7.2 结果语义对齐优先级

建议优先对齐：

1) 是否遵守 ignore（`.gitignore` 等）
2) 是否包含隐藏项
3) 是否跟随 symlink
4) pattern 支持范围

最后再谈“谁更快”，否则会变成“集合不同导致的假快/假慢”。

## 8. 如何测（复用现有脚本）

脚本：`packages/core/src/core/tool/__tests__/glob-ripgrep-performance.test.cjs`

建议基准时至少跑这些组合：

- 不同 `--limit`：例如 `100 / 1000 / 5000`
- 不同 `--statConcurrency`：例如 `1 / 8 / 32`
- `--includeHidden` 分别为 `0/1`

观察重点：

- `rg` 方案的 `listMs` vs `statAndSortMs`：瓶颈到底在哪一段
- 在你真实项目规模下，两条链路的“中位数”和“尾延迟”（抖动）哪个更好

## 9. 重构 Checklist（简版）

- [ ] 明确产品语义：ignore/hidden/symlink/pattern/limit 是否严格
- [ ] `rg` 可用性探测与降级路径清晰可观测（日志/埋点）
- [ ] 统一输出：路径规范化、mtime 缺失时的降级策略
- [ ] 基准脚本覆盖典型参数（limit/并发/hidden）
- [ ] 压测一次真实仓库规模，确认默认并发不会抖

