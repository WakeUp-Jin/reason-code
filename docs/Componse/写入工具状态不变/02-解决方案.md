# 解决方案：队列式渲染

## 方案概述

由于 `<Static>` 组件不会重新渲染已打印的内容，我们采用**队列式渲染**方案：

- **Static 区域**：只放已确定不会变化的消息（阻塞点之前）
- **动态区域**：放第一个"阻塞点"及其后面的所有消息

## 核心概念：阻塞点

```
阻塞点 = 第一个未完成的工具消息（pending/executing 状态）或流式消息

Static 区域：阻塞点之前的消息（状态已确定）
动态区域：阻塞点及其后面的消息（状态可能变化）
```

## 场景分析

### 场景1：并行工具执行

```
消息1: user "处理两个文件"
消息2: tool WriteFile (执行中 10s)   ← 阻塞点
消息3: tool ReadFile  (已完成 1s)
消息4: assistant "完成"

Static:  [消息1]
动态区域: [消息2, 消息3, 消息4]  ← 全部在这里，保持顺序
```

**消息2完成后**：
```
Static:  [消息1, 消息2, 消息3, 消息4]  ← 一起推入
动态区域: []
```

### 场景2：连续工具执行

```
消息1: user
消息2: tool A (完成)
消息3: tool B (执行中)    ← 阻塞点
消息4: tool C (完成)
消息5: assistant (流式)

Static:  [消息1, 消息2]
动态区域: [消息3, 消息4, 消息5]
```

## 实现代码

### 1. store.tsx - 新增 Hooks

```typescript
// packages/cli/src/context/store.tsx

// 找到第一个阻塞点（未完成的工具或流式消息）
function findBlockingIndex(messages: Message[]): number {
  return messages.findIndex((m) => {
    // 流式消息是阻塞点
    if (m.isStreaming) return true;
    // 未完成的工具是阻塞点
    if (m.role === 'tool' && m.toolCall) {
      const status = m.toolCall.status;
      return status !== 'success' && status !== 'error' && status !== 'cancelled';
    }
    return false;
  });
}

// Static 区域：阻塞点之前的消息
export function useStaticMessages(): Message[] {
  return useAppStore(
    useShallow((state) => {
      const id = state.currentSessionId;
      const messages = id ? state.messages[id] || [] : [];
      const blockingIndex = findBlockingIndex(messages);
      if (blockingIndex === -1) return messages;
      return messages.slice(0, blockingIndex);
    })
  );
}

// 动态区域：阻塞点及之后的消息（不含流式）
export function useDynamicMessages(): Message[] {
  return useAppStore(
    useShallow((state) => {
      const id = state.currentSessionId;
      const messages = id ? state.messages[id] || [] : [];
      const blockingIndex = findBlockingIndex(messages);
      if (blockingIndex === -1) return [];
      return messages.slice(blockingIndex).filter((m) => !m.isStreaming);
    })
  );
}
```

### 2. session/index.tsx - 修改渲染逻辑

```tsx
// packages/cli/src/routes/session/index.tsx

export function Session() {
  const staticMessages = useStaticMessages();
  const dynamicMessages = useDynamicMessages();
  const streamingMessage = useStreamingMessage();
  // ...

  // 渲染消息的通用函数
  const renderMessage = (message: Message) => {
    switch (message.role) {
      case 'user':
        return <UserMessage message={message} />;
      case 'assistant':
        if (!message.content) return null;
        return <AssistantMessage message={message} />;
      case 'tool':
        return <ToolMessage message={message} />;
      case 'thinking':
        return <ThinkingMessage message={message} />;
      default:
        return null;
    }
  };

  // 构建 Static 区域的 items
  const staticItems = useMemo(
    () => [
      { id: 'header', type: 'header' },
      ...staticMessages
        .filter((m) => m.role !== 'assistant' || m.content)
        .map((m) => ({ id: m.id, type: 'message', message: m })),
    ],
    [staticMessages]
  );

  return (
    <>
      {/* Static 区域 - 已完成消息 */}
      <Static items={staticItems}>
        {(item) => {
          if (item.type === 'header') return <Header />;
          return renderMessage(item.message);
        }}
      </Static>

      {/* 动态区域 - 未完成的消息 */}
      {dynamicMessages.map((m) => (
        <Box key={m.id}>{renderMessage(m)}</Box>
      ))}

      {/* 执行状态指示器 */}
      {isExecuting && !isPendingConfirm && <ExecutionStream />}

      {/* 流式消息 */}
      {streamingMessage && <AssistantMessage message={streamingMessage} />}

      {/* 输入区域 */}
      <InputArea />
    </>
  );
}
```

## 渲染流程图

```
┌─────────────────────────────────────────┐
│  Static 区域（阻塞点之前，状态已确定）    │
│  [user] [tool ✅] [assistant]           │
│  打印后固定，不会重新渲染                 │
├─────────────────────────────────────────┤
│  动态区域（阻塞点及之后，状态可能变化）   │
│  [tool 执行中 ○] [tool 已完成 ●]        │
│  响应状态更新，实时渲染                   │
├─────────────────────────────────────────┤
│  ExecutionStream                        │
│  ⠋ thinking... (esc to interrupt · 5s) │
├─────────────────────────────────────────┤
│  流式消息 + 输入区域                     │
└─────────────────────────────────────────┘
```

## 方案优点

| 优点 | 说明 |
|------|------|
| **顺序保证** | 消息永远按顺序显示，不会乱序 |
| **状态正确** | 进入 Static 的消息状态一定是最终状态 |
| **体验一致** | 用户看到的执行流程是连贯的 |
| **根本解决** | 正确处理 Static 的特性，而非绕过 |
| **性能优化** | 使用 useShallow 避免不必要的重渲染 |

## 关键文件

| 文件 | 修改内容 |
|------|----------|
| `packages/cli/src/context/store.tsx` | 添加 `findBlockingIndex`、`useStaticMessages`、`useDynamicMessages` |
| `packages/cli/src/routes/session/index.tsx` | 修改渲染逻辑，使用新 hooks |

## 测试场景

1. **快速工具**：ReadFile 应该正常显示（直接进入 Static）
2. **慢速工具**：WriteFile 执行期间在动态区域，完成后进入 Static
3. **并行工具**：多个工具同时执行，按顺序进入 Static
4. **审核工具**：等待审核期间在动态区域，确认后状态正确更新为绿色 ●

## 与原方案对比

| 原方案（简单过滤） | 新方案（队列式渲染） |
|-------------------|---------------------|
| 只过滤未完成的工具 | 按阻塞点分割消息 |
| 可能导致顺序混乱 | 保证消息顺序 |
| 治标不治本 | 根本解决问题 |
