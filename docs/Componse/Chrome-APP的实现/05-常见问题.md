# Chrome App Mode 常见问题

## 技术问题

### Q1: 为什么选择 HTTP 轮询而不是 WebSocket？

**A:** 对于本地通信场景，HTTP 轮询有以下优势：

1. **实现更简单**
   - 无需维护连接状态
   - 无需处理断线重连
   - 代码量更少

2. **性能足够**
   - 本地通信延迟 < 10ms
   - 500ms 轮询间隔完全可接受
   - 服务器压力极小

3. **调试方便**
   - 在 DevTools 中可以清晰看到每次请求
   - 容易排查问题

**何时使用 WebSocket：**
- 需要毫秒级实时性
- 需要服务器主动推送
- 需要双向通信

---

### Q2: 如何处理 Chrome 未安装的情况？

**A:** 提供多层降级方案：

```javascript
// 1. 检测 Chrome
if (!isChromeInstalled()) {
  // 2. 尝试其他 Chromium 浏览器
  if (isEdgeInstalled()) {
    openEdgeApp(url);
  } else if (isBraveInstalled()) {
    openBraveApp(url);
  } else {
    // 3. 使用默认浏览器
    import('open').then(open => open.default(url));
    console.log('请在浏览器中访问:', url);
  }
}
```

**支持的浏览器：**
- Chrome
- Edge（`msedge --app=URL`）
- Brave（`brave --app=URL`）
- Chromium（`chromium --app=URL`）

---

### Q3: 如何处理端口冲突？

**A:** 自动查找可用端口：

```javascript
async function findAvailablePort(startPort = 9527) {
  let port = startPort;
  
  while (!(await isPortAvailable(port))) {
    port++;
    if (port > startPort + 100) {
      throw new Error('无法找到可用端口');
    }
  }
  
  return port;
}

// 使用
const port = await findAvailablePort();
console.log(`使用端口: ${port}`);
```

---

### Q4: 如何实现多窗口支持？

**A:** 为每个窗口启动独立的服务器实例：

```javascript
class DesktopManager {
  constructor() {
    this.windows = new Map();
  }

  openWindow(id, type, data) {
    // 为每个窗口分配不同端口
    const port = 9527 + this.windows.size;
    
    // 启动新的服务器实例
    const server = this.createServer(port, type, data);
    
    // 打开窗口
    this.openChromeApp(`http://localhost:${port}`);
    
    // 记录窗口
    this.windows.set(id, { port, server, type, data });
  }

  closeWindow(id) {
    const window = this.windows.get(id);
    if (window) {
      window.server.close();
      this.windows.delete(id);
    }
  }
}
```

---

### Q5: 如何实现窗口间通信？

**A:** 使用共享的后端状态：

```javascript
// 后端：共享状态
const sharedState = {
  tasks: [],
  selectedTask: null
};

// 窗口 1：任务列表
app.get('/api/tasks', (req, res) => {
  res.json(sharedState.tasks);
});

app.post('/api/select-task', (req, res) => {
  sharedState.selectedTask = req.body.taskId;
  res.json({ success: true });
});

// 窗口 2：任务详情
app.get('/api/selected-task', (req, res) => {
  const task = sharedState.tasks.find(t => t.id === sharedState.selectedTask);
  res.json(task);
});
```

---

## 使用问题

### Q6: 桌面端窗口关闭后如何重新打开？

**A:** 提供重新打开命令：

```bash
# 方式 1：重启桌面端
tm desktop restart

# 方式 2：只打开窗口（服务器仍在运行）
tm desktop open

# 方式 3：自动打开（执行任何显示命令）
tm list --board
```

---

### Q7: 如何在桌面端和终端之间切换？

**A:** 使用命令行参数控制：

```bash
# 终端显示（默认）
tm list

# 桌面端显示
tm list --board

# 同时显示
tm list --both
```

**实现：**
```javascript
if (options.board || options.both) {
  desktopManager.showTodo(tasks);
}

if (!options.board || options.both) {
  console.table(tasks);
}
```

---

### Q8: 如何自定义桌面端的样式？

**A:** 提供主题配置：

```bash
# 切换主题
tm desktop theme dark
tm desktop theme light
tm desktop theme custom

# 自定义主题
# ~/.your-cli/themes/custom.css
:root {
  --primary-color: #667eea;
  --background-color: #f5f5f5;
  --text-color: #333;
}
```

---

### Q9: 如何导出桌面端显示的内容？

**A:** 提供导出功能：

```bash
# 导出为图片
tm list --board --export=tasks.png

# 导出为 PDF
tm list --board --export=tasks.pdf

# 导出为 HTML
tm list --board --export=tasks.html
```

**实现：**
```javascript
// 使用 Puppeteer 截图
import puppeteer from 'puppeteer';

async function exportToPNG(url, output) {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto(url);
  await page.screenshot({ path: output });
  await browser.close();
}
```

---

## 性能问题

### Q10: 轮询会不会影响性能？

**A:** 影响极小：

**性能数据：**
- 单次请求：< 10ms
- 每秒请求：2 次（500ms 间隔）
- CPU 占用：< 1%
- 内存占用：< 5MB

**优化方案：**
```javascript
// 智能轮询：有变化时加快，无变化时减慢
let interval = 500;

async function poll() {
  const data = await fetch('/api/view').then(r => r.json());
  
  if (hasChanged(data)) {
    interval = 200;  // 加快到 200ms
  } else {
    interval = Math.min(interval + 100, 2000);  // 最慢 2 秒
  }
  
  setTimeout(poll, interval);
}
```

---

### Q11: 如何减少内存占用？

**A:** 优化策略：

1. **按需加载组件**
   ```javascript
   // 只加载当前需要的组件
   if (type === 'todo') {
     await import('./components/todo.js');
   }
   ```

2. **清理旧数据**
   ```javascript
   // 切换视图时清理旧数据
   function switchView(type, data) {
     // 清理旧视图的 DOM
     oldView.innerHTML = '';
     
     // 渲染新视图
     newView.innerHTML = render(type, data);
   }
   ```

3. **使用虚拟滚动**
   ```javascript
   // 对于大列表，只渲染可见部分
   function renderTodoList(tasks) {
     const visibleTasks = tasks.slice(scrollTop, scrollTop + 20);
     return visibleTasks.map(renderTask).join('');
   }
   ```

---

### Q12: 如何优化启动速度？

**A:** 优化方案：

1. **预启动服务器**
   ```bash
   # 在后台预启动
   tm desktop start --background
   
   # 需要时立即显示
   tm list --board  # 无需等待启动
   ```

2. **延迟加载资源**
   ```html
   <!-- 延迟加载非关键 CSS -->
   <link rel="preload" href="style.css" as="style">
   
   <!-- 延迟加载图片 -->
   <img loading="lazy" src="image.png">
   ```

3. **缓存静态资源**
   ```javascript
   app.use(express.static('./public', {
     maxAge: '1d',
     etag: true
   }));
   ```

---

## 安全问题

### Q13: 本地服务器是否有安全风险？

**A:** 风险很小，但需要注意：

**安全措施：**

1. **只监听 localhost**
   ```javascript
   app.listen(port, 'localhost', () => {
     // 只能从本机访问
   });
   ```

2. **添加简单的认证**
   ```javascript
   const token = crypto.randomBytes(32).toString('hex');
   
   app.use((req, res, next) => {
     if (req.headers['x-token'] !== token) {
       return res.status(403).json({ error: 'Forbidden' });
     }
     next();
   });
   ```

3. **限制请求频率**
   ```javascript
   import rateLimit from 'express-rate-limit';
   
   const limiter = rateLimit({
     windowMs: 1000,
     max: 10  // 每秒最多 10 个请求
   });
   
   app.use('/api/', limiter);
   ```

---

### Q14: 如何防止 XSS 攻击？

**A:** 始终转义用户输入：

```javascript
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// 使用
function renderTask(task) {
  return `<div>${escapeHtml(task.title)}</div>`;
}
```

**或使用模板引擎：**
```javascript
// 使用 lit-html（自动转义）
import { html, render } from 'lit-html';

const template = html`
  <div>${task.title}</div>
`;

render(template, container);
```

---

## 扩展问题

### Q15: 如何添加新的组件类型？

**A:** 三步添加：

1. **定义数据格式**
   ```javascript
   {
     type: 'chart',
     data: {
       title: '任务统计',
       values: [10, 20, 30]
     }
   }
   ```

2. **添加 HTML 容器**
   ```html
   <div id="chart-view" class="view">
     <canvas id="chart-canvas"></canvas>
   </div>
   ```

3. **实现渲染函数**
   ```javascript
   function renderChart(data) {
     const ctx = document.getElementById('chart-canvas');
     new Chart(ctx, {
       type: 'bar',
       data: {
         labels: data.labels,
         datasets: [{ data: data.values }]
       }
     });
   }
   ```

---

### Q16: 如何集成第三方库？

**A:** 直接在前端引入：

```html
<!-- 使用 CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<!-- 或使用 npm -->
<script type="module">
  import Chart from './node_modules/chart.js/dist/chart.esm.js';
  import marked from './node_modules/marked/lib/marked.esm.js';
</script>
```

**推荐的库：**
- **图表**: Chart.js, ECharts
- **Markdown**: marked, markdown-it
- **代码高亮**: Prism.js, highlight.js
- **Diff**: diff2html, monaco-diff-editor

---

### Q17: 如何迁移到 Tauri？

**A:** 前端代码 100% 复用，只需重写后端：

**步骤：**

1. **创建 Tauri 项目**
   ```bash
   npm create tauri-app
   ```

2. **复制前端代码**
   ```bash
   cp -r public/* src/
   ```

3. **重写后端（Rust）**
   ```rust
   #[tauri::command]
   fn show_todo(tasks: Vec<Task>) -> Result<(), String> {
       // 发送事件到前端
       Ok(())
   }
   ```

4. **更新前端通信**
   ```javascript
   // 从 HTTP 改为 Tauri API
   // const data = await fetch('/api/view');
   const data = await invoke('get_view');
   ```

**迁移成本：** ~1 天

---

## 总结

Chrome App Mode 是一个简单但强大的解决方案：

**优势：**
- ✅ 开发简单（就是写网页）
- ✅ 调试方便（Chrome DevTools）
- ✅ 性能优秀（本地通信）
- ✅ 扩展灵活（可以迁移到 Tauri）

**适用场景：**
- CLI 工具的辅助显示
- 开发者工具
- 快速原型验证
- 内部工具

**不适用场景：**
- 需要独立桌面应用
- 需要系统深度集成
- 需要分发给普通用户
