# Chrome App Mode 核心原理

## 什么是 Chrome App Mode

Chrome App Mode 是 Chrome 浏览器的一个特殊启动模式，通过命令行参数 `--app=URL` 启动时，会隐藏浏览器的所有 UI 元素，让网页看起来像一个独立的桌面应用。

---

## 启动命令

### macOS
```bash
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome \
  --app=http://localhost:9527 \
  --window-size=800,600
```

### Windows
```bash
chrome.exe --app=http://localhost:9527 --window-size=800,600
```

### Linux
```bash
google-chrome --app=http://localhost:9527 --window-size=800,600
```

---

## 效果对比

### 普通浏览器模式
```
┌─────────────────────────────────────┐
│ ← → ⟳  http://localhost:9527  ⭐ ☰ │ ← 地址栏
├─────────────────────────────────────┤
│ 标签1 | 标签2 | 标签3 | +          │ ← 标签栏
├─────────────────────────────────────┤
│                                     │
│         网页内容                     │
│                                     │
└─────────────────────────────────────┘
```

### Chrome App Mode
```
┌─────────────────────────────────────┐
│                                     │
│         网页内容                     │
│         (全屏显示)                   │
│                                     │
└─────────────────────────────────────┘
```

**隐藏的元素：**
- ❌ 地址栏
- ❌ 标签栏
- ❌ 书签栏
- ❌ 扩展图标
- ❌ 浏览器菜单

**保留的功能：**
- ✅ 完整的网页渲染能力
- ✅ JavaScript 执行
- ✅ DevTools 调试（右键 → 检查）
- ✅ 网络请求
- ✅ 本地存储（localStorage/IndexedDB）

---

## 工作原理

### 1. 整体架构

```
┌─────────────────────────────────────────────────┐
│                   CLI 工具                       │
│  (你的命令行程序)                                │
└────────────┬────────────────────────────────────┘
             │
             │ 1. 启动 Express 服务器
             │ 2. 调用 exec('chrome --app=...')
             ↓
┌─────────────────────────────────────────────────┐
│              Express 服务器                      │
│  - 提供静态文件 (HTML/CSS/JS)                   │
│  - 提供 API 接口 (/api/view)                    │
│  - 管理当前显示的内容                            │
└────────────┬────────────────────────────────────┘
             │
             │ HTTP 请求
             ↓
┌─────────────────────────────────────────────────┐
│            Chrome App 窗口                       │
│  - 轮询 /api/view 获取最新数据                  │
│  - 根据数据类型切换组件                          │
│  - 渲染对应的视图                                │
└─────────────────────────────────────────────────┘
```

### 2. 数据流转

```
CLI 命令
  ↓
desktopManager.showTodo(tasks)
  ↓
更新 currentView = { type: 'todo', data: tasks }
  ↓
前端轮询 GET /api/view
  ↓
返回 { type: 'todo', data: tasks }
  ↓
前端切换到 TODO 组件
  ↓
渲染任务列表
```

### 3. 通信机制

**采用 HTTP 轮询（Polling）：**

```javascript
// 前端每 500ms 请求一次
setInterval(async () => {
  const response = await fetch('/api/view');
  const { type, data } = await response.json();
  
  if (type !== currentType) {
    switchView(type, data);
  }
}, 500);
```

**为什么不用 WebSocket？**
- ✅ 实现更简单
- ✅ 无需维护连接状态
- ✅ 500ms 延迟完全可接受
- ✅ 服务器压力极小（本地通信）

**如果需要实时性，可以升级为 WebSocket：**
```javascript
// 后端
io.on('connection', (socket) => {
  socket.emit('view-update', currentView);
});

// 前端
socket.on('view-update', ({ type, data }) => {
  switchView(type, data);
});
```

---

## 核心代码结构

### 后端（Express）

```javascript
// 1. 创建服务器
const app = express();

// 2. 存储当前视图
let currentView = { type: null, data: null };

// 3. 提供 API
app.get('/api/view', (req, res) => {
  res.json(currentView);
});

// 4. 提供静态文件
app.use(express.static('./public'));

// 5. 启动服务器
app.listen(9527, () => {
  // 6. 打开 Chrome App 窗口
  exec('chrome --app=http://localhost:9527');
});

// 7. 提供控制接口
export function showTodo(tasks) {
  currentView = { type: 'todo', data: { tasks } };
}
```

### 前端（HTML/JS）

```html
<!-- 1. 定义多个视图容器 -->
<div id="todo-view" class="view"></div>
<div id="image-view" class="view"></div>
<div id="diff-view" class="view"></div>
```

```javascript
// 2. 轮询获取数据
setInterval(async () => {
  const { type, data } = await fetch('/api/view').then(r => r.json());
  switchView(type, data);
}, 500);

// 3. 切换视图
function switchView(type, data) {
  // 隐藏所有视图
  document.querySelectorAll('.view').forEach(el => {
    el.classList.remove('active');
  });
  
  // 显示目标视图
  document.getElementById(`${type}-view`).classList.add('active');
  
  // 渲染数据
  render(type, data);
}

// 4. 渲染数据
function render(type, data) {
  if (type === 'todo') renderTodo(data);
  if (type === 'image') renderImage(data);
  if (type === 'diff') renderDiff(data);
}
```

---

## 关键技术点

### 1. 进程管理

```javascript
import { exec } from 'child_process';

// 启动 Chrome
const chromeProcess = exec('chrome --app=http://localhost:9527');

// 监听进程退出
chromeProcess.on('exit', (code) => {
  console.log('Chrome 窗口已关闭');
});
```

### 2. 端口管理

```javascript
// 检查端口是否被占用
import net from 'net';

function isPortAvailable(port) {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.once('error', () => resolve(false));
    server.once('listening', () => {
      server.close();
      resolve(true);
    });
    server.listen(port);
  });
}

// 使用
if (await isPortAvailable(9527)) {
  startServer(9527);
} else {
  console.log('端口 9527 已被占用');
}
```

### 3. 跨平台兼容

```javascript
function getChromeCommand(url) {
  const commands = {
    darwin: `/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --app=${url}`,
    win32: `start chrome --app=${url}`,
    linux: `google-chrome --app=${url}`
  };
  
  return commands[process.platform];
}
```

### 4. 错误处理

```javascript
exec(command, (err) => {
  if (err) {
    // Chrome 未安装或路径不对
    console.log('⚠️  无法自动打开 Chrome');
    console.log('请手动访问:', url);
    
    // 可选：尝试打开默认浏览器
    import('open').then(open => open.default(url));
  }
});
```

---

## 优势分析

### 1. 开发体验

**就是写网页：**
- 使用熟悉的 HTML/CSS/JS
- 使用任何前端框架（React/Vue/Svelte）
- 使用任何 UI 库（Tailwind/Ant Design）

**调试方便：**
- 右键 → 检查 → 打开 DevTools
- 和调试普通网页完全一样
- 支持断点、网络监控、性能分析

**热更新：**
- 改代码 → 刷新浏览器 → 看效果
- 无需重启服务器
- 无需重新编译

### 2. 性能表现

**启动速度：**
- Express 服务器：< 100ms
- Chrome 窗口：< 500ms
- 总启动时间：< 1 秒

**内存占用：**
- Express 服务器：~30MB
- Chrome 窗口：~100MB
- 总计：~130MB

**响应速度：**
- 本地 HTTP 请求：< 10ms
- 视图切换：< 100ms
- 用户体验流畅

### 3. 维护成本

**更新简单：**
- 改 HTML/CSS/JS 文件
- 用户刷新即可看到更新
- 无需重新分发

**无需打包：**
- 不需要 Webpack/Vite
- 不需要编译
- 不需要代码签名

**跨平台零成本：**
- 同一份代码
- 所有平台通用
- 无需分别编译

---

## 局限性

### 1. 依赖 Chrome

**问题：** 用户必须安装 Chrome 浏览器

**解决方案：**
- 目标用户是开发者（肯定有 Chrome）
- 可以支持其他浏览器（Edge/Brave）
- 提供降级方案（打开默认浏览器）

### 2. 系统集成有限

**无法实现：**
- 系统托盘图标
- 开机自启动
- 文件关联
- 系统通知（可以用 Web Notification API）

**如果需要这些功能：**
- 可以迁移到 Tauri
- 前端代码 100% 复用
- 只需重写后端

### 3. 窗口控制有限

**无法实现：**
- 最小化到托盘
- 置顶窗口
- 自定义标题栏

**可以实现：**
- 窗口大小控制（--window-size）
- 窗口位置控制（--window-position）
- 全屏模式（--start-fullscreen）

---

## 总结

Chrome App Mode 的核心优势在于：
- **简单** - 就是一个网页
- **快速** - 2 小时完成开发
- **灵活** - 可以使用任何前端技术
- **可扩展** - 未来可以迁移到 Tauri

对于 CLI 工具的辅助显示场景，这是最优解。
