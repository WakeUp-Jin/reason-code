## 📐 Ripgrep 二进制文件的下载策略与路径选择

一句话结论：将 ripgrep 视为“可选性能加速器”，**优先复用系统 `rg`**；如果系统没有则**默认自动下载**到用户目录的“工具自有 bin”，并通过“缓存/版本/校验/可禁用/可降级”保证可控与稳定。

---

### 1️⃣ 🎯 背景与目标

#### **背景：为什么要考虑下载二进制？**
- `rg`（ripgrep）在文件内容搜索与文件枚举（`--files`）场景通常显著快于纯 JS / system grep。
- 但把多平台二进制直接打包进 npm 包，会带来包体积膨胀、发布复杂度增加、企业合规阻力上升。

#### **目标：我们要达成什么？**
| 目标 | 解释 | 关键决策 |
|---|---|---|
| **体验** | 用户无需手动安装也可获得更快搜索 | 缺失时可下载到用户目录 |
| **可控** | 企业/离线环境也能运行 | 默认可降级，不强依赖 ripgrep |
| **可审计** | 下载来源、版本、校验可追踪 | 固定版本 + 哈希校验 + manifest |
| **可维护** | 目录结构清晰、可清理、可迁移 | 目录分层：config/state/log/bin/cache |

#### **非目标：不做什么**
- 不把 ripgrep 作为“功能必需品”（避免缺失即不可用）。
- 不把二进制写入系统目录（避免权限/污染）。

---

### 2️⃣ 📁 路径规范：XDG 与 `~/.reason`

#### **概念：XDG Base Directory 是什么？**
**核心定义**：XDG 规范用一组环境变量约定“不同类型文件应该放哪”，避免所有东西都塞进 `~/.xxx`。

| 类型 | 环境变量 | 常见默认值 | 放什么 |
|---|---|---|---|
| 配置 Config | `XDG_CONFIG_HOME` | `~/.config` | 可编辑配置、偏好 |
| 数据 Data | `XDG_DATA_HOME` | `~/.local/share` | 长期数据、资源、工具资产 |
| 状态 State | `XDG_STATE_HOME` | `~/.local/state` | 历史、会话、可恢复状态 |
| 缓存 Cache | `XDG_CACHE_HOME` | `~/.cache` | 可删除缓存、下载包缓存 |

#### **我们建议的折中方案（跨平台）**
**核心发现**：在 Linux 跟随 XDG 更符合生态；在 macOS/Windows 使用 `~/.reason` 更直观、也更一致。

| OS | 根目录选择 | `bin`（可执行） | `cache`（下载包/临时） |
|---|---|---|---|
| Linux | 遵循 XDG | `$XDG_DATA_HOME/reason/bin` | `$XDG_CACHE_HOME/reason` |
| macOS | `~/.reason` | `~/.reason/bin` | `~/.reason/cache` |
| Windows | `~/.reason`（或后续对齐 `%APPDATA%`） | `~/.reason/bin` | `~/.reason/cache` |

#### **目录分层建议（统一心智模型）**
```
reason-root/
  config/   # 用户配置（可手改、可备份）
  state/    # 运行状态（历史、会话等）
  log/      # 日志
  bin/      # 可执行文件（rg/rg.exe）
  cache/    # 下载的压缩包、临时缓存（可随时删）
```

---

### 3️⃣ 🔍 检测与下载策略（推荐）

#### **策略总览：先复用、再复用缓存、再自动下载、失败才降级**
```
请求使用 ripgrep
  ├─ 1) 系统 PATH 是否有 rg？
  │    └─ 有：直接使用（零下载）
  ├─ 2) reason 的 bin 是否已有 rg/rg.exe？
  │    └─ 有：直接使用（复用缓存）
  ├─ 3) 自动下载（可通过配置/环境变量禁用）
  │    ├─ 成功：下载 → 校验 → 解压 → 原子落盘 → 使用
  │    └─ 失败：进入降级策略
  └─ 4) 否则：降级到 git grep / system grep / JS fallback
```

#### **关键决策 1：默认自动下载，但必须可禁用**
**推荐**：默认自动下载以提升开箱体验，但提供明确“关闭开关”，满足企业/离线/受限环境：
- ✅ `REASON_RIPGREP=off` 或 `--no-download`：完全禁用下载
- ✅ `REASON_RIPGREP=auto`（默认）：按需自动下载
- ✅ 提供 `reason setup/doctor`：用于“预下载/修复/校验”（可选但强烈建议）

#### **关键决策 2：下载落地的安全与一致性**
建议在落地时做到：
- 固定版本（例如 `RIPGREP_VERSION=14.1.1`），避免不可控漂移
- 记录 manifest（版本/平台/时间/sha256/来源）
- 原子写入：先写到临时文件，再 `rename` 覆盖
- 校验：至少 sha256 校验；校验失败直接回滚

---

### 4️⃣ 🔐 权限、网络与降级边界

#### **为什么要“可禁用下载”？**
| 场景 | 典型限制 | 需要的能力 |
|---|---|---|
| 企业电脑 | 禁止运行期下载二进制、需代理、需审计 | `--no-download` / 环境变量关闭 |
| 离线环境 | 没网 | 自动降级，不阻塞主功能 |
| 受限容器 | 只读文件系统 | 可配置 `binDir` 到可写路径，或完全不用 |

#### **降级的语义**
**核心原则**：ripgrep 失败不应导致搜索工具不可用，应回退到其他策略（git/system/JS）。

---

### 5️⃣ 🧊 “缓存版本”是什么意思？为什么能复用？

#### **定义：缓存版本 = 缓存结构/语义的“强制失效开关”**
当我们升级缓存目录结构、二进制布局、manifest 规则时，旧缓存可能导致：
- 找不到文件（路径变了）
- 解析失败（manifest schema 变了）
- 行为异常（旧二进制残留）

**做法**：写入一个 `CACHE_VERSION`（或 `CACHE_SCHEMA_VERSION`）到缓存目录；启动时比对：
- 相同：复用缓存（因此“能使用到缓存”）
- 不同：清理旧缓存并写入新版本（避免脏状态）

#### **与 ripgrep 版本的区别**
- `CACHE_VERSION`：描述“缓存结构”是否兼容
- `RIPGREP_VERSION`：描述“要安装的 rg 版本”

---

### 6️⃣ 🔭 对照参考：opencode 的做法（可借鉴点）

#### **opencode 的核心策略（简化）**
- 使用 XDG 目录（data/config/state/cache），并在 data 下维护 `bin/log`
- 先找系统 `rg`，没有则下载到用户级 `bin`
- 通过缓存版本清理旧 cache，避免历史遗留影响
- 在部分发行渠道（如 Docker、包管理）直接声明系统依赖，降低运行期下载争议

#### **我们可以直接借鉴的点**
- “系统优先 + 用户 bin 兜底”的二级查找
- “bin/cache 分离”的目录结构
- “缓存版本”作为兼容性开关

---

### 7️⃣ ✅ 建议落地清单（下一步）

1) **确定根目录策略**：Linux 走 XDG；macOS/Windows 走 `~/.reason`
2) **统一 binDir 注入点**：在工具上下文或全局配置中提供 `binDir`
3) **增加自动下载路径**：系统无 `rg` 时自动下载到 `binDir`
4) **增加开关**：`--no-download`、`REASON_RIPGREP=off/auto`
5) **补齐 manifest 与校验**：记录来源与 sha256，确保可审计与可回滚
