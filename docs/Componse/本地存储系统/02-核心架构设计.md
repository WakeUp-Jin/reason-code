# æ ¸å¿ƒæ¶æ„è®¾è®¡

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### åˆ†å±‚è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         UI Layer (React/Ink)            â”‚
â”‚  - app.tsx                              â”‚
â”‚  - routes/session/inputArea.tsx         â”‚
â”‚  - component/panel/panel-model.tsx      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Hook Layer (usePersistence)        â”‚
â”‚  - saveCurrentSession()                 â”‚
â”‚  - saveAllSessions()                    â”‚
â”‚  - saveConfig()                         â”‚
â”‚  - saveAll()                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    State Layer (Zustand Store)          â”‚
â”‚  - sessions                             â”‚
â”‚  - messages                             â”‚
â”‚  - currentSessionId                     â”‚
â”‚  - initializeFromDisk()                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Persistence Layer (Storage/Config)    â”‚
â”‚  - ConfigManager                        â”‚
â”‚  - storage API                          â”‚
â”‚  - persistence/loader                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      File System (~/.reason-code)        â”‚
â”‚  - config.json                          â”‚
â”‚  - sessions/*.json                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ æ•°æ®æµè¯¦è§£

### åº”ç”¨å¯åŠ¨æµç¨‹

```typescript
// 1. app.tsx - Root ç»„ä»¶
function Root() {
  const config = configManager.getConfig();  // åŠ è½½é…ç½®

  return (
    <ThemeProvider defaultTheme={config.ui.theme} defaultMode={config.ui.mode}>
      <App />
    </ThemeProvider>
  );
}

// 2. app.tsx - App ç»„ä»¶
function App() {
  useEffect(() => {
    // åŠ è½½æ‰€æœ‰æ•°æ®
    const loadedData = loadAllData();

    if (loadedData.sessions.length > 0) {
      // æ¢å¤çŠ¶æ€
      initializeFromDisk({
        sessions: loadedData.sessions,
        messages: loadedData.messages,
        currentSessionId: loadedData.currentSessionId,
        currentAgent: loadedData.config.agent.current,
        currentModel: loadedData.config.model.current,
      });
    } else {
      // åˆ›å»ºæ–°ä¼šè¯
      createSession();
    }
  }, []);
}
```

### ä¿å­˜æµç¨‹

```typescript
// 1. ç”¨æˆ·æ“ä½œ (inputArea.tsx)
const handleSubmit = (value: string) => {
  // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ° Store
  addMessage(session.id, { role: 'user', content: value });

  // æ˜¾å¼ä¿å­˜
  saveCurrentSession();
};

// 2. Hook å±‚ (usePersistence.ts)
const saveCurrentSession = useCallback(() => {
  const session = sessions.find(s => s.id === currentSessionId);
  const sessionMessages = messages[currentSessionId] || [];

  // è°ƒç”¨å­˜å‚¨ API
  saveSession(session, sessionMessages);
}, [currentSessionId, sessions, messages]);

// 3. å­˜å‚¨å±‚ (storage.ts)
export function saveSession(session: Session, messages: Message[]): void {
  ensureStorageDir();

  const data = { session, messages };
  const filePath = join(SESSIONS_DIR, `${session.id}.json`);

  writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');
}
```

## ğŸ“¦ æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 1. ConfigManager (config/manager.ts)

**è®¾è®¡æ¨¡å¼**: å•ä¾‹æ¨¡å¼

**èŒè´£ï¼š**
- é…ç½®æ–‡ä»¶çš„åŠ è½½ã€éªŒè¯ã€ä¿å­˜
- ç¯å¢ƒå˜é‡è§£æå’Œå®‰å…¨å¤„ç†
- é…ç½®æ›´æ–°å’Œé™çº§å¤„ç†

**å®ç°ç»†èŠ‚ï¼š**

```typescript
export class ConfigManager {
  private config: ReasonCliConfig;

  // åŠ è½½é…ç½®
  loadConfig(): ReasonCliConfig {
    if (!existsSync(CONFIG_FILE)) {
      return DEFAULT_CONFIG;
    }

    // 1. è¯»å–æ–‡ä»¶
    const rawConfig = JSON.parse(readFileSync(CONFIG_FILE, 'utf-8'));

    // 2. åˆå¹¶é»˜è®¤å€¼
    const mergedConfig = deepMerge(DEFAULT_CONFIG, rawConfig);

    // 3. è§£æç¯å¢ƒå˜é‡
    const resolvedConfig = resolveConfigEnvVars(mergedConfig);

    // 4. Valibot éªŒè¯
    const result = safeValidateConfig(resolvedConfig);

    if (!result.success) {
      logger.error('Config validation failed');
      return DEFAULT_CONFIG;
    }

    return result.data!;
  }

  // ä¿å­˜é…ç½®ï¼ˆç§»é™¤ç¯å¢ƒå˜é‡å®é™…å€¼ï¼‰
  saveConfig(): void {
    const configToSave = this.stripEnvValues(this.config);
    writeFileSync(CONFIG_FILE, JSON.stringify(configToSave, null, 2));
  }

  // ç§»é™¤æ•æ„Ÿå€¼
  private stripEnvValues(config: ReasonCliConfig): ReasonCliConfig {
    // å°†å®é™… API key è½¬æ¢å›ç¯å¢ƒå˜é‡å¼•ç”¨
    // "sk-ant-xxx" â†’ "${ANTHROPIC_API_KEY}"
  }
}

// å•ä¾‹å¯¼å‡º
export const configManager = new ConfigManager();
```

**å…³é”®è®¾è®¡ï¼š**
- **å•ä¾‹æ¨¡å¼**: å…¨å±€å”¯ä¸€å®ä¾‹ï¼Œé¿å…é‡å¤åŠ è½½
- **å»¶è¿ŸåŠ è½½**: é¦–æ¬¡è°ƒç”¨ `getConfig()` æ—¶æ‰åŠ è½½
- **é”™è¯¯é™çº§**: ä»»ä½•é”™è¯¯éƒ½å›é€€åˆ°é»˜è®¤é…ç½®
- **å®‰å…¨ä¿å­˜**: è‡ªåŠ¨ç§»é™¤æ•æ„Ÿå€¼

### 2. usePersistence Hook (hooks/usePersistence.ts)

**è®¾è®¡æ¨¡å¼**: React Hooks + å‡½æ•°å¼ç¼–ç¨‹

**ä¸ºä»€ä¹ˆä¸ç”¨ä¸­é—´ä»¶ï¼š**

```typescript
// âŒ é—®é¢˜æ–¹æ¡ˆï¼šZustand ä¸­é—´ä»¶è‡ªåŠ¨ä¿å­˜
const useAppStore = create(
  persist(
    (set, get) => ({
      // ... store
    }),
    {
      name: 'app-storage',
      onRehydrateStorage: () => {
        // æ¯æ¬¡ Store å˜åŒ–éƒ½ä¿å­˜
        // é—®é¢˜ï¼šé¢‘ç¹å†™ç£ç›˜ï¼Œæ€§èƒ½å·®
      }
    }
  )
);

// âœ… æ­£ç¡®æ–¹æ¡ˆï¼šHook å±‚æ˜¾å¼æ§åˆ¶
export function usePersistence() {
  const saveCurrentSession = useCallback(() => {
    // åªåœ¨éœ€è¦æ—¶ä¿å­˜
  }, [deps]);

  return { saveCurrentSession, ... };
}
```

**å®ç°ç»†èŠ‚ï¼š**

```typescript
export function usePersistence() {
  // ä» Store è·å–çŠ¶æ€
  const currentSessionId = useAppStore((state) => state.currentSessionId);
  const sessions = useAppStore((state) => state.sessions);
  const messages = useAppStore((state) => state.messages);

  // ä¿å­˜å½“å‰ä¼šè¯
  const saveCurrentSession = useCallback(() => {
    if (!currentSessionId) return;

    const session = sessions.find(s => s.id === currentSessionId);
    if (!session) return;

    const sessionMessages = messages[currentSessionId] || [];

    try {
      saveSession(session, sessionMessages);
      logger.info(`Session ${currentSessionId} saved`);
    } catch (error) {
      logger.error(`Failed to save session`, { error });
    }
  }, [currentSessionId, sessions, messages]);

  // ä¿å­˜æ‰€æœ‰ä¼šè¯
  const saveAllSessions = useCallback(() => {
    for (const session of sessions) {
      const sessionMessages = messages[session.id] || [];
      saveSession(session, sessionMessages);
    }
  }, [sessions, messages]);

  // ä¿å­˜é…ç½®
  const saveConfig = useCallback((updates: Partial<PartialConfig>) => {
    configManager.updateConfig(updates);
  }, []);

  // ä¿å­˜æ‰€æœ‰æ•°æ®
  const saveAll = useCallback(() => {
    saveAllSessions();
    if (currentSessionId) {
      saveConfig({
        session: {
          lastSessionId: currentSessionId,
          autoSave: true,
          saveDebounce: 500,
        },
      });
    }
  }, [currentSessionId, saveAllSessions, saveConfig]);

  return {
    saveCurrentSession,
    saveAllSessions,
    saveConfig,
    saveAll,
  };
}
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```typescript
// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
function InputArea() {
  const { saveCurrentSession } = usePersistence();

  const handleSubmit = (value: string) => {
    addMessage(session.id, { role: 'user', content: value });

    // æ˜¾å¼ä¿å­˜
    saveCurrentSession();
  };
}
```

**ä¼˜åŠ¿ï¼š**
- âœ… å¯æ§ï¼šæ˜ç¡®çŸ¥é“ä½•æ—¶ä¿å­˜
- âœ… æ€§èƒ½å¥½ï¼šåªåœ¨å…³é”®æ—¶åˆ»ä¿å­˜
- âœ… æ˜“æµ‹è¯•ï¼šçº¯å‡½æ•°ï¼Œæ˜“äºå•å…ƒæµ‹è¯•
- âœ… çµæ´»ï¼šå¯ä»¥ç»„åˆä¸åŒçš„ä¿å­˜ç­–ç•¥

### 3. Valibot Schema (config/schema.ts)

**è®¾è®¡æ¨¡å¼**: Schema å®šä¹‰ + å‡½æ•°å¼éªŒè¯

**Valibot API ä½¿ç”¨ï¼š**

```typescript
import * as v from 'valibot';

// 1. åŸºç¡€ Schema
const ProviderConfigSchema = v.object({
  apiKey: v.optional(v.string()),
  baseUrl: v.optional(v.pipe(v.string(), v.url())),
  timeout: v.optional(v.pipe(v.number(), v.integer(), v.minValue(1)), 60000),
});

// 2. ç»„åˆ Schema
const ReasonCliConfigSchema = v.object({
  model: ModelConfigSchema,
  providers: ProvidersConfigSchema,
  agent: AgentConfigSchema,
  ui: UIConfigSchema,
  session: SessionConfigSchema,
});

// 3. ç±»å‹æ¨æ–­
type ReasonCliConfig = v.InferOutput<typeof ReasonCliConfigSchema>;

// 4. éªŒè¯å‡½æ•°
export function safeValidateConfig(config: unknown) {
  const result = v.safeParse(ReasonCliConfigSchema, config);
  if (result.success) {
    return { success: true, data: result.output };
  }
  return { success: false, error: result.issues };
}
```

**Valibot vs Zod å¯¹æ¯”ï¼š**

| ç‰¹æ€§ | Zod | Valibot | è¯´æ˜ |
|-----|-----|---------|------|
| `object()` | `z.object()` | `v.object()` | å¯¹è±¡å®šä¹‰ |
| `string()` | `z.string()` | `v.string()` | å­—ç¬¦ä¸² |
| `number()` | `z.number()` | `v.number()` | æ•°å­— |
| `optional()` | `z.optional()` | `v.optional()` | å¯é€‰å­—æ®µ |
| `enum()` | `z.enum()` | `v.picklist()` | æšä¸¾ |
| `record()` | `z.record()` | `v.record()` | å­—å…¸ |
| `pipe()` | `z.pipe()` | `v.pipe()` | ç®¡é“éªŒè¯ |
| ç±»å‹æ¨æ–­ | `z.infer<>` | `v.InferOutput<>` | ç±»å‹æå– |
| éªŒè¯ | `parse()` | `parse()` | åŒå |
| å®‰å…¨éªŒè¯ | `safeParse()` | `safeParse()` | åŒå |

**è¿ç§»ç¤ºä¾‹ï¼š**

```typescript
// Before (Zod)
import { z } from 'zod';

const schema = z.object({
  name: z.string(),
  age: z.number().int().positive(),
  email: z.string().email().optional(),
  role: z.enum(['admin', 'user']),
});

type User = z.infer<typeof schema>;

// After (Valibot)
import * as v from 'valibot';

const schema = v.object({
  name: v.string(),
  age: v.pipe(v.number(), v.integer(), v.minValue(1)),
  email: v.optional(v.pipe(v.string(), v.email())),
  role: v.picklist(['admin', 'user']),
});

type User = v.InferOutput<typeof schema>;
```

### 4. æ•°æ®åŠ è½½å™¨ (persistence/loader.ts)

**èŒè´£ï¼š** åº”ç”¨å¯åŠ¨æ—¶ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰æ•°æ®

**å®ç°ï¼š**

```typescript
export function loadAllData(): LoadedData {
  logger.info('Loading all data from disk...');

  // 1. ç¡®ä¿ç›®å½•å­˜åœ¨
  ensureStorageDir();

  // 2. åŠ è½½é…ç½®
  const config = configManager.loadConfig();

  // 3. åŠ è½½æ‰€æœ‰ä¼šè¯
  const { sessions, messages } = loadAllSessions();

  // 4. ç¡®å®šå½“å‰ä¼šè¯
  let currentSessionId: string | null = null;

  if (sessions.length > 0) {
    // ä¼˜å…ˆä½¿ç”¨é…ç½®ä¸­çš„ lastSessionId
    const lastSessionId = config.session.lastSessionId;
    if (lastSessionId && sessions.find(s => s.id === lastSessionId)) {
      currentSessionId = lastSessionId;
    } else {
      // å¦åˆ™ä½¿ç”¨æœ€æ–°çš„ä¼šè¯
      currentSessionId = sessions[0].id;
    }
  }

  return { config, sessions, messages, currentSessionId };
}
```

**è°ƒç”¨ä½ç½®ï¼š**

```typescript
// app.tsx
useEffect(() => {
  if (!initialized.current) {
    initialized.current = true;

    const loadedData = loadAllData();

    if (loadedData.sessions.length > 0) {
      initializeFromDisk({...loadedData});
    } else {
      createSession();
    }
  }
}, []);
```

## ğŸ” å®‰å…¨è®¾è®¡

### ç¯å¢ƒå˜é‡å¤„ç†

**è§£æå‡½æ•°ï¼š**

```typescript
// è§£æå­—ç¬¦ä¸²ä¸­çš„ç¯å¢ƒå˜é‡
export function resolveEnvVars(str: string): string {
  // åŒ¹é… ${VAR_NAME} æˆ– $VAR_NAME
  return str.replace(/\$\{([^}]+)\}|\$([A-Z_][A-Z0-9_]*)/g, (match, name1, name2) => {
    const varName = name1 || name2;
    return process.env[varName] || '';
  });
}

// é€’å½’è§£æå¯¹è±¡ä¸­çš„ç¯å¢ƒå˜é‡
export function resolveConfigEnvVars<T>(obj: T): T {
  if (typeof obj === 'string') {
    return resolveEnvVars(obj) as T;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => resolveConfigEnvVars(item)) as T;
  }

  if (obj !== null && typeof obj === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = resolveConfigEnvVars(value);
    }
    return result as T;
  }

  return obj;
}
```

**ç§»é™¤æ•æ„Ÿå€¼ï¼š**

```typescript
private stripEnvValues(config: ReasonCliConfig): ReasonCliConfig {
  const result = JSON.parse(JSON.stringify(config));

  for (const providerName in result.providers) {
    const provider = result.providers[providerName];
    if (provider && provider.apiKey) {
      // å¦‚æœä¸æ˜¯ç¯å¢ƒå˜é‡å¼•ç”¨æ ¼å¼ï¼Œè½¬æ¢ä¸ºå¼•ç”¨
      if (!provider.apiKey.startsWith('${')) {
        const envVarName = `${providerName.toUpperCase()}_API_KEY`;
        provider.apiKey = `\${${envVarName}}`;
      }
    }
  }

  return result;
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### Valibot Tree-shaking

```typescript
// Valibot æ”¯æŒæŒ‰éœ€å¯¼å…¥
import { object, string, number } from 'valibot';

// åªæ‰“åŒ…ç”¨åˆ°çš„éªŒè¯å™¨
const schema = object({
  name: string(),
  age: number(),
});

// Bundle ä¸­åªåŒ…å«ï¼š
// - object
// - string
// - number
// å…¶ä»–æœªä½¿ç”¨çš„éªŒè¯å™¨ä¸ä¼šè¢«æ‰“åŒ…
```

### ä¿å­˜é˜²æŠ–ï¼ˆå¯é€‰ï¼‰

```typescript
// æœªæ¥å¯ä»¥æ·»åŠ é˜²æŠ–ä¼˜åŒ–
import { debounce } from 'lodash';

const debouncedSave = debounce(
  () => saveCurrentSession(),
  500  // é…ç½®ä¸­çš„ saveDebounce
);

// ä½¿ç”¨
const handleChange = () => {
  updateStore();
  debouncedSave();
};
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

```typescript
// æµ‹è¯• ConfigManager
describe('ConfigManager', () => {
  it('should load default config when file not exists', () => {
    const config = configManager.loadConfig();
    expect(config).toEqual(DEFAULT_CONFIG);
  });

  it('should parse environment variables', () => {
    process.env.ANTHROPIC_API_KEY = 'test-key';
    const config = configManager.loadConfig();
    expect(config.providers.anthropic.apiKey).toBe('test-key');
  });

  it('should strip env values on save', () => {
    configManager.updateConfig({
      providers: {
        anthropic: { apiKey: 'sk-ant-xxx' }
      }
    });

    const saved = JSON.parse(readFileSync(CONFIG_FILE, 'utf-8'));
    expect(saved.providers.anthropic.apiKey).toBe('${ANTHROPIC_API_KEY}');
  });
});
```

### é›†æˆæµ‹è¯•

```typescript
// æµ‹è¯•å®Œæ•´æµç¨‹
describe('Persistence Flow', () => {
  it('should save and load session', async () => {
    // 1. åˆ›å»ºä¼šè¯
    const session = createSession('Test');

    // 2. æ·»åŠ æ¶ˆæ¯
    addMessage(session.id, { role: 'user', content: 'Hello' });

    // 3. ä¿å­˜
    saveCurrentSession();

    // 4. é‡æ–°åŠ è½½
    const loaded = loadSession(session.id);

    expect(loaded.messages).toHaveLength(1);
    expect(loaded.messages[0].content).toBe('Hello');
  });
});
```

---

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¶é—´**: 2025-12-26
