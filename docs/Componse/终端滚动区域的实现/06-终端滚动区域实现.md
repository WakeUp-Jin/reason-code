# 终端滚动区域实现

## 概述

在 CLI 聊天应用中，我们需要实现类似 Claude Code 和 Gemini CLI 的滚动体验：
- **Header 和消息区域**：可以滚动（利用终端原生滚动）
- **输入区域和 Footer**：固定在底部，不随滚动移动

## 核心概念：Ink 的 Static 组件

### 什么是 Static 组件？

Ink 的 `<Static>` 组件是实现终端滚动的关键。它的特性是：

1. **内容只渲染一次**：放入 Static 的内容会被"永久打印"到终端
2. **不会重新渲染**：即使组件状态更新，Static 内的内容也不会重新绘制
3. **利用终端原生滚动**：内容超出屏幕后，可以用终端自带的滚动功能查看

### Static vs 普通组件

```
┌─────────────────────────────────────────┐
│  Static 区域（可滚动）                    │
│  ┌─────────────────────────────────────┐│
│  │ Header (Logo + 描述)                ││
│  │ Message 1                           ││
│  │ Message 2                           ││
│  │ Message 3                           ││  ← 终端原生滚动
│  │ ...                                 ││
│  └─────────────────────────────────────┘│
├─────────────────────────────────────────┤
│  动态区域（固定在底部）                    │
│  ┌─────────────────────────────────────┐│
│  │ 流式消息（正在生成的回复）             ││
│  │ 输入框                              ││
│  │ Footer                              ││
│  └─────────────────────────────────────┘│
└─────────────────────────────────────────┘
```

## 完整实现代码

### 1. Store 层 - 消息状态管理

首先，我们需要区分"已完成的消息"和"正在流式输出的消息"：

```typescript
// packages/cli/src/context/store.tsx

// 获取已完成的消息（用于 Static 区域）
export function useCompletedMessages(): Message[] {
  return useAppStore((state) => {
    const id = state.currentSessionId;
    const messages = id ? state.messages[id] || [] : [];
    // 过滤掉正在流式输出的消息
    return messages.filter((m) => !m.isStreaming);
  });
}

// 获取正在流式输出的消息（用于动态区域）
export function useStreamingMessage(): Message | null {
  return useAppStore((state) => {
    const id = state.currentSessionId;
    const messages = id ? state.messages[id] || [] : [];
    return messages.find((m) => m.isStreaming) || null;
  });
}
```

### 2. Session 页面 - 布局实现

```tsx
// packages/cli/src/routes/session/index.tsx

import React from 'react';
import { Box, Text, Static } from 'ink';
import { useTheme } from '../../context/theme.js';
import {
  useCurrentSession,
  useCompletedMessages,
  useStreamingMessage,
} from '../../context/store.js';
import type { Message } from '../../context/store.js';
import { Header } from './header.js';
import { Footer } from './footer.js';
import { UserMessage } from '../../component/message-area/user-message.js';
import { AssistantMessage } from '../../component/message-area/assistant-message.js';
import { InputArea } from './inputArea.js';

// Static 区域的 item 类型
type StaticItem =
  | { id: string; type: 'header' }
  | { id: string; type: 'message'; message: Message };

export function Session() {
  const { colors } = useTheme();
  const session = useCurrentSession();
  const completedMessages = useCompletedMessages();
  const streamingMessage = useStreamingMessage();

  if (!session) {
    return (
      <Box flexDirection="column" alignItems="center" justifyContent="center">
        <Text color={colors.error}>No session selected</Text>
      </Box>
    );
  }

  // 构建 Static 区域的 items
  // Header 作为第一个 item，确保它被"打印"在最上面
  const staticItems: StaticItem[] = [
    { id: 'header', type: 'header' },
    ...completedMessages.map((m) => ({
      id: m.id,
      type: 'message' as const,
      message: m,
    })),
  ];

  return (
    <>
      {/* ========== Static 区域 - 可滚动 ========== */}
      <Static items={staticItems}>
        {(item: StaticItem) => {
          if (item.type === 'header') {
            return (
              <Box key="header" paddingTop={1} paddingLeft={2} paddingRight={2}>
                <Header />
              </Box>
            );
          }
          // 消息项
          return (
            <Box key={item.id} paddingLeft={2} paddingRight={2}>
              {item.message.role === 'user' ? (
                <UserMessage message={item.message} />
              ) : (
                <AssistantMessage message={item.message} />
              )}
            </Box>
          );
        }}
      </Static>

      {/* ========== 动态区域 - 固定在底部 ========== */}
      <Box flexDirection="column">
        {/* 当前流式消息 */}
        {streamingMessage && (
          <Box paddingLeft={2} paddingRight={2}>
            <AssistantMessage message={streamingMessage} />
          </Box>
        )}

        {/* 输入区域和 Footer */}
        <Box
          flexDirection="column"
          paddingLeft={2}
          paddingRight={2}
          paddingBottom={1}
          borderStyle="single"
          borderTop={true}
          borderBottom={false}
          borderLeft={false}
          borderRight={false}
          borderColor={colors.border || 'gray'}
        >
          <InputArea />
          <Footer />
        </Box>
      </Box>
    </>
  );
}
```

### 3. App 组件 - 关键布局设置

```tsx
// packages/cli/src/app.tsx

function App() {
  const { columns: width } = useTerminalSize();
  // ...

  return (
    // 关键：不设置 height，让内容自然流动
    <Box key={`app-${width}`} flexDirection="column" width={width}>
      <Session />
    </Box>
  );
}
```

## 关键实现细节

### 1. 为什么使用 React Fragment (`<>`)？

```tsx
// ❌ 错误：使用 Box 包裹会导致布局问题
return (
  <Box flexDirection="column">
    <Static>...</Static>
    <Box>动态区域</Box>
  </Box>
);

// ✅ 正确：使用 Fragment 让内容自然流动
return (
  <>
    <Static>...</Static>
    <Box>动态区域</Box>
  </>
);
```

使用 Fragment 的原因：
- 避免额外的 Box 容器干扰 Ink 的布局计算
- 让 Static 内容和动态内容自然堆叠
- 防止出现意外的滚动条

### 2. 为什么不设置 height？

```tsx
// ❌ 错误：设置固定高度会导致提前出现滚动条
<Box height={terminalHeight}>
  ...
</Box>

// ✅ 正确：让内容自然流动
<Box>
  ...
</Box>
```

如果设置了 `height={terminalHeight}`，即使内容不足以填满屏幕，Ink 也会认为需要滚动。

### 3. Static 的 items 属性

```tsx
<Static items={staticItems}>
  {(item) => (
    <Box key={item.id}>
      {/* 渲染每个 item */}
    </Box>
  )}
</Static>
```

- `items` 是一个数组，每个元素会被渲染一次
- 当数组增加新元素时，只有新元素会被渲染
- **必须提供唯一的 `key`**，Ink 用它来追踪哪些内容已经打印过

### 4. Header 放入 Static 的原因

```tsx
const staticItems: StaticItem[] = [
  { id: 'header', type: 'header' },  // Header 作为第一个 item
  ...completedMessages.map(...)
];
```

- Header 只需要渲染一次，放入 Static 可以避免重复渲染
- 当消息增多时，Header 会随着消息一起被滚动出去
- 这与 Claude Code 的行为一致

### 5. 流式消息的处理

```tsx
{/* 流式消息不在 Static 中，因为它需要实时更新 */}
{streamingMessage && (
  <Box paddingLeft={2} paddingRight={2}>
    <AssistantMessage message={streamingMessage} />
  </Box>
)}
```

流式消息（正在生成的 AI 回复）不能放入 Static，因为：
- Static 内容只渲染一次，无法更新
- 流式消息需要实时显示新增的内容
- 当流式消息完成后，它会被移到 `completedMessages`，然后通过 Static 打印

## 消息流转流程

```
用户发送消息
    │
    ▼
addMessage({ role: 'user', content: '...', isStreaming: false })
    │
    ▼
completedMessages 更新 → Static 渲染新消息
    │
    ▼
AI 开始回复
    │
    ▼
addMessage({ role: 'assistant', content: '', isStreaming: true })
    │
    ▼
streamingMessage 更新 → 动态区域显示流式消息
    │
    ▼
AI 回复完成
    │
    ▼
updateMessage({ isStreaming: false })
    │
    ▼
streamingMessage = null
completedMessages 增加 → Static 渲染完成的消息
```

## 与其他方案的对比

### 方案 1：虚拟滚动（不推荐）

```tsx
// 自己实现滚动逻辑
const [scrollOffset, setScrollOffset] = useState(0);
const visibleMessages = messages.slice(scrollOffset, scrollOffset + pageSize);
```

缺点：
- 需要自己处理键盘事件
- 无法使用终端原生滚动
- 实现复杂

### 方案 2：Ink 的 `<Box overflow="scroll">`（不推荐）

Ink 目前不支持真正的滚动容器，`overflow` 属性只是裁剪内容。

### 方案 3：Static 组件（推荐 ✅）

优点：
- 利用终端原生滚动，体验最好
- 实现简单
- 与 Claude Code、Gemini CLI 一致

## 参考项目

- **Claude Code (Kode)**: `src/screens/REPL.tsx`
- **Gemini CLI**: `src/ui/AppContainer.tsx`

## 文件位置

本功能涉及的文件：
- `packages/cli/src/routes/session/index.tsx` - 主要布局
- `packages/cli/src/context/store.tsx` - 消息状态管理
- `packages/cli/src/app.tsx` - 根布局设置

