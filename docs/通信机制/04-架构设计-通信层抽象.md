# æ¶æ„è®¾è®¡ï¼šé€šä¿¡å±‚æŠ½è±¡

## ğŸ“– æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°å¦‚ä½•è®¾è®¡**ä½è€¦åˆã€å¯æ’æ‹”**çš„é€šä¿¡å±‚ï¼Œä½¿å¾—åˆ‡æ¢é€šä¿¡æ–¹å¼ï¼ˆCLI â†’ HTTP â†’ WebSocketï¼‰åªéœ€ä¿®æ”¹å°‘é‡é…ç½®æ–‡ä»¶ï¼Œæ— éœ€æ”¹åŠ¨ä¸šåŠ¡é€»è¾‘ä»£ç ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

1. âœ… **ä¸šåŠ¡é€»è¾‘ä¸ä¾èµ–é€šä¿¡æ–¹å¼**ï¼šSessionã€Agentã€Tool å±‚æ— éœ€å…³å¿ƒåº•å±‚é€šä¿¡
2. âœ… **åˆ‡æ¢é€šä¿¡åªéœ€æ”¹é…ç½®**ï¼šä¿®æ”¹ 1-2 ä¸ªæ–‡ä»¶å³å¯åˆ‡æ¢
3. âœ… **æ”¯æŒå¤šåè®®å…±å­˜**ï¼šåŒæ—¶æ”¯æŒ CLI + HTTP + WebSocket
4. âœ… **ç»Ÿä¸€æ¥å£æŠ½è±¡**ï¼šæ‰€æœ‰é€šä¿¡æ–¹å¼å®ç°ç›¸åŒæ¥å£

## ğŸ—ï¸ åˆ†å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          åº”ç”¨å±‚ (CLI/Web/Desktop)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ä¼ è¾“å±‚æŠ½è±¡ (ITransport)               â”‚
â”‚  ç»Ÿä¸€æ¥å£ï¼šsend() / receive() / close()         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â†“           â†“           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DirectTransportâ”‚ â”‚HTTPTransportâ”‚ â”‚WSTransportâ”‚
â”‚  (è¿›ç¨‹å†…)    â”‚ â”‚ (HTTP+SSE)â”‚ â”‚(WebSocket)â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
       â”‚               â”‚            â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ä¸šåŠ¡å±‚ (Session/Agent)             â”‚
â”‚  - ä¸å…³å¿ƒä¼ è¾“æ–¹å¼                               â”‚
â”‚  - åªä¾èµ– ITransport æ¥å£                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”‘ æ ¸å¿ƒæ¥å£è®¾è®¡

### ITransport æ¥å£

```typescript
// src/transport/interface.ts

/**
 * ä¼ è¾“å±‚æŠ½è±¡æ¥å£
 * æ‰€æœ‰é€šä¿¡æ–¹å¼å¿…é¡»å®ç°æ­¤æ¥å£
 */
export interface ITransport {
  /**
   * å‘é€æ¶ˆæ¯
   */
  send(message: Message): Promise<void>

  /**
   * æ¥æ”¶äº‹ä»¶æµï¼ˆå¼‚æ­¥è¿­ä»£å™¨ï¼‰
   */
  receive(): AsyncIterable<Event>

  /**
   * å…³é—­è¿æ¥
   */
  close(): Promise<void>

  /**
   * è¿æ¥çŠ¶æ€
   */
  readonly status: TransportStatus
}

export type TransportStatus =
  | "connecting"
  | "connected"
  | "disconnected"
  | "error"

export interface Message {
  sessionID: string
  parts: Part[]
  agent?: string
  model?: Model
}

export interface Event {
  type: string
  properties: Record<string, any>
}
```

## ğŸ’» ä¸‰ç§å®ç°æ–¹å¼

### 1. DirectTransportï¼ˆCLI ç›´æ¥è°ƒç”¨ï¼‰

```typescript
// src/transport/direct.ts
import { Bus } from "../bus"
import { SessionPrompt } from "../session/prompt"

export class DirectTransport implements ITransport {
  status: TransportStatus = "connected"
  private abort: AbortController = new AbortController()

  async send(message: Message): Promise<void> {
    // ç›´æ¥è°ƒç”¨ä¸šåŠ¡å±‚
    await SessionPrompt.prompt({
      sessionID: message.sessionID,
      parts: message.parts,
      agent: message.agent,
      model: message.model
    })
  }

  async *receive(): AsyncIterable<Event> {
    const queue: Event[] = []
    let resolve: ((value: Event) => void) | null = null

    // è®¢é˜… Bus äº‹ä»¶
    const unsub = Bus.subscribeAll((event) => {
      if (resolve) {
        resolve(event)
        resolve = null
      } else {
        queue.push(event)
      }
    })

    try {
      while (!this.abort.signal.aborted) {
        if (queue.length > 0) {
          yield queue.shift()!
        } else {
          // ç­‰å¾…ä¸‹ä¸€ä¸ªäº‹ä»¶
          yield await new Promise<Event>((r) => {
            resolve = r
          })
        }
      }
    } finally {
      unsub()
    }
  }

  async close(): Promise<void> {
    this.abort.abort()
    this.status = "disconnected"
  }
}
```

### 2. HTTPTransportï¼ˆHTTP + SSEï¼‰

```typescript
// src/transport/http.ts
export class HTTPTransport implements ITransport {
  status: TransportStatus = "disconnected"
  private baseUrl: string
  private eventSource?: EventSource

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }

  async send(message: Message): Promise<void> {
    await fetch(`${this.baseUrl}/session/${message.sessionID}/message`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        parts: message.parts,
        agent: message.agent,
        model: message.model
      })
    })
  }

  async *receive(): AsyncIterable<Event> {
    this.eventSource = new EventSource(`${this.baseUrl}/event`)
    this.status = "connected"

    const queue: Event[] = []
    let resolve: ((value: Event) => void) | null = null

    this.eventSource.onmessage = (evt) => {
      const event = JSON.parse(evt.data) as Event

      if (resolve) {
        resolve(event)
        resolve = null
      } else {
        queue.push(event)
      }
    }

    this.eventSource.onerror = () => {
      this.status = "error"
    }

    while (this.status !== "disconnected") {
      if (queue.length > 0) {
        yield queue.shift()!
      } else {
        yield await new Promise<Event>((r) => {
          resolve = r
        })
      }
    }
  }

  async close(): Promise<void> {
    this.eventSource?.close()
    this.status = "disconnected"
  }
}
```

### 3. WebSocketTransportï¼ˆWebSocketï¼‰

```typescript
// src/transport/websocket.ts
export class WebSocketTransport implements ITransport {
  status: TransportStatus = "connecting"
  private ws: WebSocket

  constructor(url: string, sessionID: string) {
    this.ws = new WebSocket(`${url}?sessionID=${sessionID}`)

    this.ws.onopen = () => {
      this.status = "connected"
    }

    this.ws.onerror = () => {
      this.status = "error"
    }

    this.ws.onclose = () => {
      this.status = "disconnected"
    }
  }

  async send(message: Message): Promise<void> {
    this.ws.send(JSON.stringify({
      type: "prompt",
      data: message
    }))
  }

  async *receive(): AsyncIterable<Event> {
    const queue: Event[] = []
    let resolve: ((value: Event) => void) | null = null

    this.ws.onmessage = (evt) => {
      const event = JSON.parse(evt.data) as Event

      if (resolve) {
        resolve(event)
        resolve = null
      } else {
        queue.push(event)
      }
    }

    while (this.status !== "disconnected") {
      if (queue.length > 0) {
        yield queue.shift()!
      } else {
        yield await new Promise<Event>((r) => {
          resolve = r
        })
      }
    }
  }

  async close(): Promise<void> {
    this.ws.close()
    this.status = "disconnected"
  }
}
```

## ğŸ­ å·¥å‚æ¨¡å¼åˆ›å»º

```typescript
// src/transport/factory.ts
import { DirectTransport } from "./direct"
import { HTTPTransport } from "./http"
import { WebSocketTransport } from "./websocket"

export type TransportConfig =
  | { mode: "direct" }
  | { mode: "http"; baseUrl: string }
  | { mode: "websocket"; url: string; sessionID: string }

export class TransportFactory {
  static create(config: TransportConfig): ITransport {
    switch (config.mode) {
      case "direct":
        return new DirectTransport()

      case "http":
        return new HTTPTransport(config.baseUrl)

      case "websocket":
        return new WebSocketTransport(config.url, config.sessionID)

      default:
        throw new Error(`Unknown transport mode: ${(config as any).mode}`)
    }
  }
}
```

## ğŸ® ä¸šåŠ¡å±‚ä½¿ç”¨

### Session å±‚æ”¹é€ ï¼ˆæœ€å°æ”¹åŠ¨ï¼‰

```typescript
// src/session/client.ts
import { ITransport } from "../transport/interface"

export class SessionClient {
  constructor(private transport: ITransport) {}

  async prompt(prompt: string) {
    // å‘é€æ¶ˆæ¯
    await this.transport.send({
      sessionID: this.sessionID,
      parts: [{ type: "text", text: prompt }]
    })

    // æ¥æ”¶äº‹ä»¶
    for await (const event of this.transport.receive()) {
      if (event.type === "message.part.updated") {
        this.handlePartUpdate(event.properties)
      }

      if (event.type === "session.idle") {
        break
      }
    }
  }

  private handlePartUpdate(data: any) {
    if (data.part.type === "text" && data.delta) {
      process.stdout.write(data.delta)
    }
  }
}
```

### CLI å…¥å£ï¼ˆé…ç½®åŒ–ï¼‰

```typescript
// src/cli/main.ts
import { TransportFactory } from "../transport/factory"
import { SessionClient } from "../session/client"
import { loadConfig } from "../config"

async function cli(prompt: string) {
  // 1. åŠ è½½é…ç½®
  const config = await loadConfig()

  // 2. åˆ›å»ºä¼ è¾“å±‚
  const transport = TransportFactory.create(config.transport)

  // 3. åˆ›å»ºä¼šè¯å®¢æˆ·ç«¯
  const client = new SessionClient(transport)

  // 4. å‘é€æç¤º
  await client.prompt(prompt)

  // 5. å…³é—­è¿æ¥
  await transport.close()
}
```

## ğŸ“ é…ç½®æ–‡ä»¶

```typescript
// config.json

// CLI æ¨¡å¼ï¼ˆç›´æ¥è°ƒç”¨ï¼‰
{
  "transport": {
    "mode": "direct"
  }
}

// HTTP æ¨¡å¼ï¼ˆWeb ç«¯ï¼‰
{
  "transport": {
    "mode": "http",
    "baseUrl": "http://localhost:4096"
  }
}

// WebSocket æ¨¡å¼ï¼ˆå®æ—¶åä½œï¼‰
{
  "transport": {
    "mode": "websocket",
    "url": "ws://localhost:4096/ws",
    "sessionID": "session_01"
  }
}
```

## ğŸ”„ åˆ‡æ¢é€šä¿¡æ–¹å¼

### ä» CLI åˆ‡æ¢åˆ° HTTP

```diff
// config.json
{
  "transport": {
-   "mode": "direct"
+   "mode": "http",
+   "baseUrl": "http://localhost:4096"
  }
}
```

**éœ€è¦ä¿®æ”¹çš„æ–‡ä»¶**ï¼š
- âœ… `config.json` (1 è¡Œ)

**æ— éœ€ä¿®æ”¹çš„æ–‡ä»¶**ï¼š
- âŒ `src/session/` (ä¸šåŠ¡é€»è¾‘)
- âŒ `src/agent/` (Agent å®šä¹‰)
- âŒ `src/tool/` (å·¥å…·å®ç°)
- âŒ `src/cli/main.ts` (å…¥å£)

### ä» HTTP åˆ‡æ¢åˆ° WebSocket

```diff
// config.json
{
  "transport": {
-   "mode": "http",
-   "baseUrl": "http://localhost:4096"
+   "mode": "websocket",
+   "url": "ws://localhost:4096/ws",
+   "sessionID": "session_01"
  }
}
```

**éœ€è¦ä¿®æ”¹çš„æ–‡ä»¶**ï¼š
- âœ… `config.json` (1 è¡Œ)

## ğŸ¯ ä¾èµ–å…³ç³»å›¾

```
åº”ç”¨å±‚ (CLI/Web/Desktop)
    â†“ ä¾èµ–
ä¼ è¾“å±‚æ¥å£ (ITransport)
    â†“ å®ç°
ä¼ è¾“å±‚å®ç° (Direct/HTTP/WebSocket)
    â†“ è°ƒç”¨
ä¸šåŠ¡å±‚ (Session/Agent/Tool)
```

**å…³é”®ç‚¹**ï¼šåº”ç”¨å±‚åªä¾èµ–æ¥å£ï¼Œä¸ä¾èµ–å®ç°ã€‚

## ğŸ”Œ æ’ä»¶åŒ–æ‰©å±•

### æ·»åŠ æ–°çš„ä¼ è¾“æ–¹å¼

```typescript
// src/transport/grpc.ts
import { ITransport } from "./interface"

export class GRPCTransport implements ITransport {
  // å®ç° ITransport æ¥å£
  async send(message: Message): Promise<void> {
    // gRPC å‘é€é€»è¾‘
  }

  async *receive(): AsyncIterable<Event> {
    // gRPC æ¥æ”¶é€»è¾‘
  }

  async close(): Promise<void> {
    // gRPC å…³é—­é€»è¾‘
  }

  status: TransportStatus = "connected"
}

// æ³¨å†Œåˆ°å·¥å‚
TransportFactory.register("grpc", (config) => {
  return new GRPCTransport(config.endpoint)
})
```

### ä½¿ç”¨æ–°ä¼ è¾“æ–¹å¼

```json
// config.json
{
  "transport": {
    "mode": "grpc",
    "endpoint": "localhost:50051"
  }
}
```

## ğŸ“Š æ¶æ„ä¼˜åŠ¿å¯¹æ¯”

| è®¾è®¡ | ç´§è€¦åˆ | æ¾è€¦åˆï¼ˆæœ¬æ–¹æ¡ˆï¼‰ |
|------|--------|----------------|
| **ä»£ç å¤ç”¨** | ä½ | é«˜ |
| **åˆ‡æ¢æˆæœ¬** | é«˜ï¼ˆæ”¹å¤šå¤„ï¼‰ | ä½ï¼ˆæ”¹é…ç½®ï¼‰ |
| **æ‰©å±•æ€§** | å·® | å¼º |
| **æµ‹è¯•æ€§** | éš¾ | æ˜“ï¼ˆMock Transportï¼‰ |
| **ç»´æŠ¤æˆæœ¬** | é«˜ | ä½ |

## ğŸ§ª å•å…ƒæµ‹è¯•

### Mock Transport

```typescript
// src/transport/__tests__/mock.ts
export class MockTransport implements ITransport {
  sentMessages: Message[] = []
  mockEvents: Event[] = []

  async send(message: Message): Promise<void> {
    this.sentMessages.push(message)
  }

  async *receive(): AsyncIterable<Event> {
    for (const event of this.mockEvents) {
      yield event
    }
  }

  async close(): Promise<void> {}

  status: TransportStatus = "connected"
}

// æµ‹è¯•
const transport = new MockTransport()
transport.mockEvents = [
  { type: "text-delta", properties: { delta: "Hello" } }
]

const client = new SessionClient(transport)
await client.prompt("test")

expect(transport.sentMessages).toHaveLength(1)
```

## ğŸ“‚ æ–‡ä»¶ç»“æ„

```
src/
â”œâ”€â”€ transport/
â”‚   â”œâ”€â”€ interface.ts            # ITransport æ¥å£å®šä¹‰
â”‚   â”œâ”€â”€ factory.ts              # å·¥å‚æ¨¡å¼
â”‚   â”œâ”€â”€ direct.ts               # CLI ç›´æ¥è°ƒç”¨
â”‚   â”œâ”€â”€ http.ts                 # HTTP + SSE
â”‚   â”œâ”€â”€ websocket.ts            # WebSocket
â”‚   â””â”€â”€ __tests__/
â”‚       â””â”€â”€ mock.ts             # Mock å®ç°
â”œâ”€â”€ session/
â”‚   â””â”€â”€ client.ts               # ä¸šåŠ¡å±‚ï¼ˆä¾èµ– ITransportï¼‰
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ index.ts                # é…ç½®åŠ è½½
â”‚   â””â”€â”€ schema.ts               # é…ç½®éªŒè¯
â””â”€â”€ cli/
    â””â”€â”€ main.ts                 # CLI å…¥å£
```

## ğŸ“ è®¾è®¡æ¨¡å¼åº”ç”¨

### 1. ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰
```typescript
// ä¸åŒä¼ è¾“æ–¹å¼æ˜¯ä¸åŒçš„ç­–ç•¥
const transport = TransportFactory.create(config.transport)
```

### 2. å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰
```typescript
// æ ¹æ®é…ç½®åˆ›å»ºå¯¹åº”å®ä¾‹
TransportFactory.create({ mode: "http" })
```

### 3. é€‚é…å™¨æ¨¡å¼ï¼ˆAdapter Patternï¼‰
```typescript
// ç»Ÿä¸€æ¥å£é€‚é…ä¸åŒå®ç°
class DirectTransport implements ITransport { ... }
class HTTPTransport implements ITransport { ... }
```

### 4. è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰
```typescript
// Bus äº‹ä»¶ç³»ç»Ÿ
Bus.subscribe(Event, handler)
```

## ğŸš€ æœ€ä½³å®è·µ

### 1. é…ç½®ä¼˜å…ˆ
```typescript
// âœ… å¥½çš„åšæ³•ï¼šé…ç½®é©±åŠ¨
const transport = TransportFactory.create(config.transport)

// âŒ åçš„åšæ³•ï¼šç¡¬ç¼–ç 
const transport = new HTTPTransport("http://localhost:4096")
```

### 2. ä¾èµ–æ³¨å…¥
```typescript
// âœ… å¥½çš„åšæ³•ï¼šä¾èµ–æ³¨å…¥
class SessionClient {
  constructor(private transport: ITransport) {}
}

// âŒ åçš„åšæ³•ï¼šå†…éƒ¨åˆ›å»º
class SessionClient {
  private transport = new HTTPTransport()
}
```

### 3. é¢å‘æ¥å£ç¼–ç¨‹
```typescript
// âœ… å¥½çš„åšæ³•ï¼šä¾èµ–æ¥å£
function createClient(transport: ITransport) {}

// âŒ åçš„åšæ³•ï¼šä¾èµ–å®ç°
function createClient(transport: HTTPTransport) {}
```

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [å½“å‰æ–¹æ¡ˆï¼šCLI ç›´æ¥è°ƒç”¨](./01-å½“å‰æ–¹æ¡ˆ-CLIç›´æ¥è°ƒç”¨.md)
- [HTTP + SSE æ–¹æ¡ˆ](./02-æœªæ¥æ‰©å±•-HTTP+SSEæ–¹æ¡ˆ.md)
- [WebSocket æ–¹æ¡ˆ](./03-æœªæ¥æ‰©å±•-WebSocketæ–¹æ¡ˆ.md)
- [è¿ç§»æŒ‡å—](./05-è¿ç§»æŒ‡å—.md)

---

**æ ¸å¿ƒç†å¿µ**ï¼šé€šè¿‡æŠ½è±¡æ¥å£å®ç°ä½è€¦åˆï¼Œé€šè¿‡å·¥å‚æ¨¡å¼å®ç°å¯æ’æ‹”ï¼Œé€šè¿‡é…ç½®æ–‡ä»¶å®ç°çµæ´»åˆ‡æ¢ã€‚
